<?php include("macros.php3"); ?>

<?php heading("Futures", "futures") ?>



<?php section("overview", "overview") ?>

<P>A <EM>future</EM> is a place-holder for the undetermined result of a
(concurrent) computation. Once the computation delivers a result, the
associated future is eliminated by globally replacing it with the result value.
That value may be a future on its own.</P>

<P>Whenever a future is <EM>requested</EM> by a concurrent computation, i.e. it
tries to access its value, that computation automatically synchronizes on the
future by blocking until it becomes determined or failed.</P>

<P>If the computation associated with a future terminates with an exception,
the future is <EM>failed</EM>. A failed future carries the corresponding
exception and reraises it on every request.</P>

<P>There are three basic kinds of futures:</P>

<UL>
  <LI> <A href="#spawn"><EM>concurrent futures</EM></A> stand for the
	result of an concurrent computation </LI>
  <LI> <A href="#lazy"><EM>lazy futures</EM></A> stand for the
	result of a computation that is only performed on request </LI>
  <LI> <A href="#promise"><EM>promised futures</EM></A> stand for the
	a value that is delivered through an explicit operation </LI>
</UL>


<?php section("spawn", "concurrency") ?>

<P>A concurrent future is created by the expression</P>

<PRE class=code>
spawn <I>exp</I></PRE>

<P>which evaluates the expression <TT><I>exp</I></TT> in new thread and returns
immediately with a future of its result. When the expression has been
evaluated, the future is globally replaced by the result. We speak of
<EM>functional threads</EM>. See the below discussion on <A
href="#failed">failed futures</A> for the treatment of possible error
conditions.</P>

<P class=note><EM>Note:</EM> The presence of concurrency has subtle <A
href="incompatibilities.html#matching">implications</A>
on the semantics of pattern matching.</P>


<?php subsection("spawn-example", "Example") ?>

<P>The following expression creates a table and concurrently fills it with the
results of function <TT>f</TT>. Each entry becomes available as soon as its
calculation terminates:</P>

<PRE class=code>
Vector.tabulate (30, fn i => spawn f i)</PRE>


<?php subsection("spawn-sugar", "Syntactic sugar") ?>

<P>A derived form is provided for defining functions that always evaluate in
separate threads:</P>

<PRE class=code>
fun spawn f x y = exp</PRE>

<P>An application <TT>f a b</TT> will spawn a new thread for evaluation. See <A
href="#syntax">below</A> for a precise definition of this derived form.</P>



<?php section("lazy", "laziness") ?>

<P>An expression can be marked as lazy:</P>

<PRE class=code>
lazy <I>exp</I></PRE>

<P>A lazy expression immediately evaluates to a lazy future of the result of
<TT><I>exp</I></TT>. As soon as a thread <A href="#request">requests</A> the
future, the computation is initiated in a new thread. The lazy future is
replaced by a concurrent future and evaluation proceeds similar to <A
href="#spawn"><TT>spawn</TT></A>. In particular, <A href="#failed">failure</A>
is handled consistently.</P>


<?php subsection("lazy-example", "Example") ?>

<P>Lazy futures enable full support for the whole range of lazy programming
techniques. For example, the following function generates an infinite lazy
stream of integers:</P>

<PRE class=code>
fun enum n = lazy n :: enum (n+1)</PRE>


<?php subsection("lazy-sugar", "Syntactic sugar") ?>

<P>Analogously to <A href="#spawn-sugar"><TT>spawn</TT></A>, a derived form is
provided for defining lazy functions:</P>

<PRE class=code>
fun lazy f x y = exp</PRE>

<P>See <A href="#syntax">below</A> for a precise definition of this derived
form. It allows convenient formulation of lazy functions. For example, a lazy
variant of the <TT>map</TT> function on lists can be written</P>

<PRE class=code>
fun lazy mapl f   []    = nil
       | mapl f (x::xs) = f x :: mapl f xs</PRE>

<P>This formulation is equivalent to</P>

<PRE class=code>
fun mapl f xs = lazy (case xs of
                           []   => nil
                        | x::xs => f x :: mapl f xs)</PRE>



<?php section("promise", "promises") ?>

<P><EM>Promises</EM> are explicit handles for futures. A promise is created
through the polymorphic library function <A
href="library/promise.html"><TT>Promise.promise</TT></A>:

<PRE class=code>
val p = Promise.promise ()</PRE>

<P>Associated with every promise is a future. Creating a new promise also
creates a fresh future. The future can be extracted as

<PRE class=code>
val f = Promise.future p</PRE>

<P>A promised future is eliminated explicitly by applying

<PRE class=code>
Promise.fulfill (p, v)</PRE>

<P>to the corresponding promise, which globally replaces the future with the
value <TT><I>v</I></TT>.</P>

<P class=note><EM>Note:</EM> Promises may be thought of as single-assignment
references that allow dereferencing prior to assignment, yielding a future. The
operations <TT>promise</TT>, <TT>future</TT> and <TT>fulfill</TT> correspond to
<TT>ref</TT>, <TT>!</TT> and <TT>:=</TT>, respectively.</P>


<?php subsection("promise-example", "Example") ?>

<P>Promises essentially represent a more structured form of "logic variables"
as found in logic programming languages. Their presence allows application of
diverse idioms from concurrent logic programming to ML. Examples can be found in
the documentation of the <A href="library/promise.html#examples"><TT>Promise</TT></A>
structure.</P>


<?php section("request", "requesting a future") ?>

<P>A future is <EM>requested</EM> if it is used as an argument to a
<EM>strict</EM> operation. The following operations are strict:</P>

<UL>
  <LI> Pattern matching is strict in the examined value. </LI>
  <LI> Function (functor) application is strict in the function
       (functor) value. </LI>
  <LI> Exception raising is strict in the exception value. </LI>
  <LI> Primitive operations that need to access a value (e.g. <TT>op+</TT>,
       <TT>op=</TT>, <A href="pickling.html">pickling</A>) are strict
       in their corresponding arguments. </LI>
  <LI> <A href="packages.html#dynamic">Unpacking</A> is strict in the
       package's signature and the annotated signature. </LI>
</UL>

<P>Note however, that selecting items from a structure using
longids is non-strict.</P>

<P>If a future is requested by a thread, that thread blocks until the future
has been replaced by a non-future value (or a failed future, see <A
href="#failed">below</A>). After the value has been determined, the thread
proceeds.</P>

<P>Requesting a lazy future triggers initiation of the corresponding
computation. The future is replaced by a concurrent future of the computation's
result. The requesting thread blocks until the result is determined.</P>

<P>Requesting a promised future will block at least until a <TT>fulfill</TT>
operation has been applied to the corresponding promise. Blocking continues if
the promise is fulfilled with another future.</P>

<P><EM>Structural</EM> operations that are strict (i.e., pattern matching,
<TT>op=</TT> and <A href="pickling.html">pickling</A>) traverse all values
in a depth-first left-to-right order. Futures are requested in that order.
If traversal is terminated early, the remaining futures are not requested.
Early termination occurs if a future is failed, upon a mismatch (pattern
matching), if two partial values are not equal (<TT>op=</TT>), or if part
of a value is sited (pickling). For unpacking it is unspecified, how much of the
respective signatures is requested.</P>

<P>The implicit data-flow synchronisation implied by the future semantics
enables concurrent programming on a high level of abstraction.</P>


<?php section("failed", "failed futures") ?>

<P>If the computation associated with a concurrent or lazy future terminates
with an exception, that future cannot be eliminated. Instead, it turns into a
<EM>failed future</EM>. Promised futures can be failed explicitly by means of
the <A href="library/promise.html"><TT>Promise.fail</TT></A> function. Any
attempt to request a failed future will re-raise the exception that was the
cause of the failure.</P>

<P>A second error condition is the attempt to replace a future with itself. This
may happen if a recursive <TT>spawn</TT> or <TT>lazy</TT> expression is
unfounded, or if a promise is fulfilled with its own future. In all of
these cases, the future will be failed with the special exception
<TT>Future.Cyclic</TT>.</P>


<?php section("state", "threads and state") ?>

<P>To deal with state in a thread-safe way, the structure <TT>Ref</TT> provides
an atomic exchange operation for references:</P>

<PRE class=code>
val exchange : 'a ref * 'a -> 'a</PRE>

<P>With <TT>exchange</TT>, the content of a cell can be
replaced by a new value. The old value is returned. The <TT>exchange</TT>
operation is atomic, and can thus be used for synchronisation.
As an example, here is the implementation of a generic lock generator:</P>

<PRE class=code>
fun lock () =
    let
	val r = ref ()
    in
	fn f => fn x =>
	let
	    val new = Promise.promise ()
	    val old = Ref.exchange (r, Promise.future new)
	in
	    await old;
	    f x before
	    Promise.fulfill (new, ()))
	end
    end</PRE>

<P>The library structure <A href="library/lock.html"><TT>Lock</TT></A>
implements locks this way.</P>


<?php section("lib", "library support") ?>

<P>The following library modules provide functionality relevant for
programming with futures, promises and concurrent threads:</P>

<UL>
  <LI> <A href="library/future.html"><TT>Future</TT></A> </LI>
  <LI> <A href="library/promise.html"><TT>Promise</TT></A> </LI>
  <LI> <A href="library/thread.html"><TT>Thread</TT></A> </LI>
  <LI> <A href="library/os-process.html"><TT>OS.Process</TT></A> </LI>
  <LI> <A href="library/byneed.html"><TT>ByNeed</TT></A> </LI>
  <LI> <A href="library/lock.html"><TT>Lock</TT></A> </LI>
  <LI> <A href="library/ref.html"><TT>Ref</TT></A> </LI>
</UL>

<P><TT>ByNeed</TT> is a functor that allows creation of lazy futures
for modules. Lazy modules are also at the core of the semantics of <A
href="components.html">components</A>.</P>


<?php section("syntax", "syntax summary") ?>

<TABLE class=bnf>
  <TR>
    <TD> <I>exp</I> </TD>
    <TD align="center">::=</TD>
    <TD> ... </TD>
    <TD> </TD>
  </TR>
  <TR>
    <TD></TD> <TD></TD>
    <TD> <TT>lazy</TT> <I>exp</I> </TD>
    <TD> lazy </TD>
  </TR>
  <TR>
    <TD></TD> <TD></TD>
    <TD> <TT>spawn</TT> <I>exp</I> </TD>
    <TD> concurrent </TD>
  </TR>

  <TR></TR>
  <TR>
    <TD> <I>fvalbind</I> </TD>
    <TD align="center">::=</TD>
    <TD> &lt;<TT>lazy</TT> | <TT>spawn</TT>&gt; </TD>
    <TD> (<I>m</I>,<I>n</I>&ge;1) (*) </TD>
  </TR><TR>
    <TD></TD><TD></TD>
    <TD> &nbsp;&nbsp;
         &lt;<TT>op</TT>&gt; <I>vid atpat</I><SUB>11</SUB> ... <I>atpat</I><SUB>1<I>n</I></SUB> &lt;<TT>:</TT> ty<SUB>1</SUB>&gt;
	 <TT>=</TT> <I>exp</I><SUB>1</SUB> </TD>
  </TR><TR>
    <TD></TD><TD></TD>
    <TD> <TT>|</TT>
         &lt;<TT>op</TT>&gt; <I>vid atpat</I><SUB>21</SUB> ... <I>atpat</I><SUB>2<I>n</I></SUB> &lt;<TT>:</TT> ty<SUB>2</SUB>&gt;
	 <TT>=</TT> <I>exp</I><SUB>2</SUB> </TD>
  </TR><TR>
    <TD></TD><TD></TD>
    <TD> <TT>|</TT> ... </TD>
  </TR><TR>
    <TD></TD><TD></TD>
    <TD> <TT>|</TT>
         &lt;<TT>op</TT>&gt; <I>vid atpat</I><SUB><I>m</I>1</SUB> ... <I>atpat</I><SUB><I>mn</I></SUB> &lt;<TT>:</TT> ty<SUB><I>m</I></SUB>&gt;
	 <TT>=</TT> <I>exp</I><SUB><I>m</I></SUB> </TD>
  </TR><TR>
    <TD></TD><TD></TD>
    <TD> &lt;<TT>and</TT> <I>fvalbind</I>&gt; </TD>
  </TR>
</TABLE>


<?php subsection("syntax-derived", "derived forms") ?>

<TABLE class="bnf df">
  <TR>
    <TD>
      <BR>
      &lt;<TT>lazy</TT>&nbsp;|&nbsp;<TT>spawn</TT>&gt; <BR>
      &nbsp;&nbsp;&nbsp;&lt;<TT>op</TT>&gt;&nbsp;<I>vid</I>&nbsp;<!--
	--><I>atpat</I><SUB>11</SUB>&nbsp;...&nbsp;<I>atpat</I><SUB>1<I>n</I></SUB>&nbsp;<!--
	-->&lt;<TT>:</TT>&nbsp;ty<SUB>1</SUB>&gt;&nbsp;<!--
	--><TT>=</TT>&nbsp;<I>exp</I><SUB>1</SUB> <BR>
      <TT>|</TT>&nbsp;&lt;<TT>op</TT>&gt;&nbsp;<I>vid</I>&nbsp;<!--
	--><I>atpat</I><SUB>21</SUB>&nbsp;...&nbsp;<I>atpat</I><SUB>2<I>n</I></SUB>&nbsp;<!--
	-->&lt;<TT>:</TT>&nbsp;ty<SUB>2</SUB>&gt;&nbsp;<!--
	--><TT>=</TT>&nbsp;<I>exp</I><SUB>2</SUB> <BR>
      <TT>|</TT>&nbsp;&nbsp;&nbsp;&nbsp;... <BR>
      <TT>|</TT>&nbsp;&lt;<TT>op</TT>&gt;&nbsp;<I>vid<I>&nbsp;<!--
	--></I>atpat</I><SUB><I>m</I>1</SUB>&nbsp;...&nbsp;<I>atpat</I><SUB><I>mn</I></SUB>&nbsp;<!--
	-->&lt;<TT>:</TT>&nbsp;ty<SUB><I>m</I></SUB>&gt;&nbsp;<!--
	--><TT>=</TT>&nbsp;<I>exp</I><SUB><I>m</I></SUB> <BR>
      &lt;<TT>and</TT>&nbsp;<I>fvalbind</I>&gt;
    </TD>
    <TD>
      &lt;<TT>op</TT>&gt;&nbsp;<I>vid</I>&nbsp;<TT>=</TT>&nbsp;<!--
	--><TT>fn</TT>&nbsp;<I>vid</I><SUB>1</SUB>&nbsp;<TT>=></TT>&nbsp;...&nbsp;<!--
	--><TT>fn</TT>&nbsp;<I>vid</I><SUB><I>n</I></SUB>&nbsp;<TT>=></TT> <BR>
      &lt;<TT>lazy</TT>&nbsp;|&nbsp;<TT>spawn</TT>&gt;&nbsp;<TT>case</TT>&nbsp;<!--
	--><TT>(</TT><I>vid</I><SUB>1</SUB><TT>,</TT>...<TT>,</TT><I>vid</I><SUB><I>n</I></SUB><TT>)</TT>&nbsp;<TT>of</TT> <BR>
      &nbsp;&nbsp;&nbsp;<!--
	--><TT>(</TT><I>atpat</I><SUB>11</SUB><TT>,</TT>...<TT>,</TT><I>atpat</I><SUB>1<I>n</I></SUB><TT>)</TT>&nbsp;<!--
	--><TT>=></TT> <I>exp</I><SUB>1</SUB>&nbsp;<!--
	-->&lt;<TT>:</TT>&nbsp;ty<SUB>1</SUB>&gt; <BR>
      <TT>|</TT>&nbsp;<!--
	--><TT>(</TT><I>atpat</I><SUB>21</SUB><TT>,</TT>...<TT>,</TT><I>atpat</I><SUB>2<I>n</I></SUB><TT>)</TT>&nbsp;<!--
	--><TT>=></TT>&nbsp;<I>exp</I><SUB>2</SUB>&nbsp;<!--
	-->&lt;<TT>:</TT>&nbsp;ty<SUB>2</SUB>&gt; <BR>
      <TT>|</TT>&nbsp;&nbsp;&nbsp;&nbsp;... <BR>
      <TT>|</TT>&nbsp;<!--
	--><TT>(</TT><I>atpat</I><SUB><I>m</I>1</SUB><TT>,</TT>...<TT>,</TT><I>atpat</I><SUB><I>mn</I></SUB><TT>)</TT>&nbsp;<!--
	--><TT>=></TT>&nbsp;<I>exp</I><SUB><I>m</I></SUB>&nbsp;<!--
	-->&lt;<TT>:</TT>&nbsp;ty<SUB><I>m</I></SUB>&gt; <BR>
      &lt;<TT>and</TT>&nbsp;<I>fvalbind</I>&gt;
    </TD>
  </TR>
</TABLE>

<P><I>vid</I><SUB>1</SUB>,...,<I>vid</I><SUB><I>n</I></SUB> are distinct and new.</P>

<?php footing() ?>
