<?php include("macros.php3"); ?>
<?php heading("Batch compiler", "batch\ncompiler") ?>

<?php section("overview", "overview") ?>

<P>The standalone batch compiler is used to produce <A
href="components.html">components</A> from source files.</A>


<?php section("synopsis", "synopsis") ?>

<DL>
  <DT><TT>alicec</TT> [<I>&lt;options&gt;</I>] [<TT>-c</TT>]
    <I>&lt;input file&gt;</I> [<TT>-o</TT> <I>&lt;output file&gt;</I>]
    [<I>&lt;input file&gt;</I> [<TT>-o</TT> <I>&lt;output file&gt;</I>] ...] </DT>
  <DT><TT>alicec</TT> [<I>&lt;options&gt;</I>] <TT>-r</TT>
    <I>&lt;input file&gt;</I> [<TT>-o</TT> <I>&lt;output file&gt;</I>]
    [<I>&lt;input file&gt;</I> [<TT>-o</TT> <I>&lt;output file&gt;</I>] ...] </DT>
<!--
  <DT><TT>alicec</TT> [<I>&lt;options&gt;</I>] <TT>-x</TT>
    <I>&lt;input file&gt;</I> [<TT>-o</TT> <I>&lt;output file&gt;</I>]</DT>
-->
<!--
  <DT><TT>alicec</TT> <TT>--print-component-extension</TT></DT>
-->
</DL>


<?php section("description", "description") ?>

<P>All <I>&lt;input file&gt;</I>s are compiled as Alice source programs and corresponding components are written as output. If <I>&lt;output file&gt;</I> is
given after an <I>&lt;input file&gt;</I>, it is used as the respective output
file name, else the basename of <I>&lt;input file&gt;</I> is used with <TT>.alc</TT> as extension. Compiled components can
be executed by invoking the <A href="machine.html">virtual machine</A>.</P>

<P>An <I>&lt;input file&gt;</I> may be a URL.  See <A
href="#environment-variables">below</A> for notes on how they are
interpreted. An <I>&lt;output file&gt;</I> may only be omitted if the preceding
<I>&lt;input file&gt;</I> represents a local file.</P>

<!--
<P>In the third form, <I>&lt;input file&gt;</I> is compiled as an Alice source
and an executable component is written as output.  If <I>&lt;output
file&gt;</I> is given, it is used as the output file name, else the basename of
<I>&lt;input file&gt;</I> is used, without extension.</P>
-->

<P>To compile a component, the compiler requires access to all imported
component files whose import signature omit type information in the source file. If one does not exist, but a source file for it
(i.e., a file with same name but ending in <TT>.aml</TT>, <TT>.sml</TT>,
or <TT>.sig</TT>) can be located, the compiler first invokes itself
recursively to compile the imported component.  If a component <EM>does</EM>
exist, the compiler does <EM>not</EM> perform any check to verify whether it is
up-to-date. External tools like <TT>make</TT> have to be used, in conjunction
with the <A href="depend.html">dependency analyzer</A>, to ensure proper
recompilation if necessary.</P>

<?php if ($platform != "seam") { ?>
<P>It is possible to import Mozart components (<A
href="http://www.mozart-oz.org/documentation/apptut/node3.html">Mozart
"functors"</A>), as long as they are augmented with an Alice signature file.
See the <A href="interop.html">interop section</A> for details.</P>
<?php } ?>

<?php subsection("description-smart", "Smart Recompilation") ?>

<P>Invoking the compiler with option <TT>-r</TT> instead of <TT>-c</TT> enables <EM>smart recompilation</EM>. When the compiler is initiated in this mode, the output component is only created when it does not exist yet, or is out of date.</P>

<P>The target component file is considered out of date if either of the following holds:</P>

<UL>
  <LI>The source file is newer than the component file.
  <LI>Any imported component is newer than the component file <EM>and</EM> its
      signature no longer matches the import signature stored in the
      component file.
</UL>

<P>The smart recompilation mode is particularly useful in conjunction with tools like <TT>make</TT>. It avoids redundant regeneration of existing target files and hence can cut off subsequent recompilation further down the dependency chain. To take advantage of this, simply invoke the Alice compiler in smart recompilation mode in your Makefile and the tool figures out the rest by itself. You do not need to modify dependencies declarations (like e.g. generated by the <A href="depend.html">dependency analyzer</A> for Alice).</P>

<!--
<P>The third form just causes the compiler to print the standard extension for
components (currently <TT>alc</TT>) and exit immediately.</P>
-->


<?php section("options", "options") ?>

<DL>
  <DT><TT>--version</TT></DT>
  <DD><P>Print compiler version.</P></DD>
  <DT><TT>--assert &lt;level&gt;</TT></DT>
  <DD><P>Set assertion level (0 by default).</P></DD>
  <DT><TT>--(no-)dump-phases</TT></DT>
  <DD><P>Trace compilation phases.</P></DD>
  <DT><TT>--(no-)dump-elaboration-sig</TT></DT>
  <DD><P>Output component's export signature.</P></DD>
  <DT><TT>--(no-)warn-unused-imports</TT></DT>
  <DD><P>Warn about unused imports (on by default).</P></DD>
  <DT><TT>--(no-)warn-added-imports</TT></DT>
  <DD><P>Warn about imports inserted by the compiler for closing over implicit import signatures (off by default).</P></DD>
  <DT><TT>--(no-)warn-inaccessible-exports</TT></DT>
  <DD><P>Warn about local types occuring in the computed export signature of the component, as they will prevent the component being imported in full (on by default).</P></DD>
  <DT><TT>--(no-)warn-conventions</TT></DT>
  <DD><P>Warn about violations of standard naming conventions (on by default).</P></DD>
  <DT><TT>--(no-)warn-shadowing</TT></DT>
  <DD><P>Warn about shadowing of identifiers (off by default, gives a lot of spurious warnings).</P></DD>
  <DT><TT>--dependency-file &lt;dependency file&gt;</TT></DT>
  <DD><P>Use dependency file to automatically derive import announcements.</P></DD>
</DL>


<?php section("interop", "import management") ?>

<P>Alice employs a compilation model that is quite different from other
Standard ML systems. In particular, Alice ML requires putting explicit <A
href="components.html#source">import announcements</A> into source files to
enable separate compilation.</P>

<P>In order to allow for easier migration or sharing of SML source code with
other SML systems, the Alice compiler supports two methods for inserting import
announcements automatically:</P>

<UL>
<LI><P>If the <I>input file</I> has the file extension <TT>.sml</TT> or
<TT>.sig</TT>, then the compiler looks for a file with the same name but the
extension <TT>.import</TT>. If found, the contents of that file is prepended to
the actual input file.</P>

<LI><P>The <TT>--dependency-file</TT> option allows specifying a file listing
the dependencies between ML source files. The format of a dependency file is as
follows:</P>

<TABLE class=bnf>
  <TR>
    <TD> <I>dep-file</I> </TD>
    <TD align="center">::=</TD>
    <TD> {<I>dep-line</I>}* </TD>
  </TR><TR>
    <TD> <I>dep-line</I> </TD>
    <TD align="center">::=</TD>
    <TD> <I>file-name</I> <TT>:</TT> {<I>file-name</I>}* </TD>
  </TR>
</TABLE>

<P>The format resembles (a subset of) makefile syntax:</P>

<UL>
<LI>File names are arbitrary sequences of non-whitespace characters, excluding "#". They
are separated by white space. White space between the first file name and the
colon is optional (this implies that the first file name after the colon cannot
be ":" if the white space is omitted).
<LI> A backslash at the end of a line escapes the subsequent newline, allowing
the content of the first line to be continued on the next one.
<LI> "#" starts a comment, stretching until the end of the line. Comments are
ignored completely (including contained backslashes).
</UL>

<P>Each line is headed by a file name denoting a source file, the
<I>target</I>. After the colon follows a list of files the target
depends on, its <I>prerequisites</I>. When a source file is compiled with a
dependency file that contains its name as a target, then the source file is
modified by prepending an import announcement for each prerequisite of the
target. Extensions of target file names are ignored, a target is assumed to
denote the current source file if its base name is the same. Likewise,
prerequisites are stripped of their extension. That allows using makefile
dependencies directly as dependency files.</P>

<P>Consider the following dependency file:</P>

<PRE class=code>
# project.depend
A.alc: B.alc C.alc D.alc
B.alc:
C.alc: D.alc</PRE>

<P>By invoking</P>

<PRE class=code>
alicec --dependency-file project.depend A.sml</PRE>

<P><TT>A.sml</TT> will be compiled as if it contained the following import
announcements:</P>

<PRE class=code>
import "B"
import "C"
import "D"</PRE>

<P>Moreover, if both, a requisite and the respective target are relative paths,
then the requisite's path is rewritten relative to its target. For example,
assume:</P>

<PRE class=code>
# project.depend
sub/A.alc: B.alc ../C.alc sub/D.alc</PRE>

<P>By invoking</P>

<PRE class=code>
alicec --dependency-file project.depend sub/A.sml</PRE>

<P><TT>sub/A.sml</TT> will be compiled as if it contained the following import
announcements:</P>

<PRE class=code>
import "../B"
import "../../C"
import "D"</PRE>

<P>If a target is contained multiple times in a dependency file the
corresponding prerequisites are accumulated. The compiler may be invoked with
multiple dependency files, with the effect of invoking it with the
concatenation of those files.</P>

</UL>

<P>The first of these options essentially requires creating a separate import
file for each individual SML file. The second option allows gathering all the
necessary information into a single dependency file.</P>

<P>Please note that these methods are provided solely for better compatibility
with other SML systems. Using them for native Alice components is strongly
discouraged.</P>


<?php section("environment-variables", "environment variables") ?>

<P>The batch compiler is parameterized by the same environment variables
as the <A href="machine.html#environment-variables">virtual machine</A>,
plus:</P>

<DL>
  <DT><TT>ALICE_SOURCE_PATH</TT>
  <DD><P>specifies how source file URLs are interpreted.  If set, the value
    of this environment variable is parsed by the <TT>parse</TT> method of
    the <A href="library/resolver.html#Handler"><TT>Resolver.Handler</TT></A>
    structure.  If not set, uses only the default identity method.</P>
</DL>


<?php footing() ?>
