(* Alice Snake 2.0 - Server
*
*  Authors: Benedikt Grundmann / Sebastian Germesin
*
*  $Revision$
*
*  Last updated: $Date$ by $Author$
* 
*
*)

import structure Protocol       from "../common/Protocol"
import structure Color          from "../common/Color"
import structure Pos            from "../common/Pos"

import structure Participant    from "Participant"
import structure Remote         from "x-alice:/lib/distribution/Remote"
import structure MkHashImpMap   from "x-alice:/lib/data/MkHashImpMap"
import structure Arena          from "Arena"
import structure Random         from "x-alice:/lib/utility/Random"
import structure Snake          from "Snake"
import structure Config         from "Config"
import structure Remote         from "x-alice:/lib/distribution/Remote"
import structure Highscore      from "../common/Highscore"
import structure HighscoreIO    from "HighscoreIO"
import signature SERVER         from "SERVER-sig"
import structure MkHeap         from "../common/MkHeap"

(*
import val dummyClient          from "DummyClient"
*)
import val log                  from "../common/Log"
import structure Ctrl           from "x-alice:/lib/utility/Ctrl"

open Ctrl

fun not_yet_implemented s =
    log ("Server", "TODO: " ^ s ^ " not yet implemented.")


structure Event =
struct
    type t = int * Protocol.diff option * Protocol.diff option

    fun compare ((a,_,_), (b,_,_)) = Int.compare (a, b)

    fun equal ((a,_,_), (b,_,_)) = a = b
    
    fun time (t, _, _)  = t
end

structure Events =
struct
    structure Heap  = MkHeap (Event)
    
    type t = int ref * Heap.heap
    
    fun events () = (ref 0, Heap.heap ())

    fun add ((ref time, h), offset, e1, e2 ) = 
        Heap.insert (h, (time + offset, e1, e2))
        
    fun tick (r, h) =
        let 
            fun gather (res1, res2) =
                if not (Heap.isEmpty h) andalso
                        Event.time (Heap.minimum h) = !r then
                    case Heap.minimum h before Heap.remove h of
                        (_, NONE, NONE)     => gather (res1, res2)
                    |   (_, NONE, SOME e)   => gather (res1, e :: res2)
                    |   (_, SOME e, NONE)   => gather (e :: res1, res2)
                    |   (_, SOME e1, SOME e2) => gather (e1 :: res1, e2 ::res2)
                else (res1, res2)
        in
            r := !r + 1;
            gather ([], [])
        end
end


structure Server :> SERVER =
struct
    
    datatype state = 
        ST_JOIN         
        (* valid calls by a client:
            disconnect,
            play,
            watch,
         PC may also:
            startGame
         *)
    |   ST_GAME 
        (* valid calls by a client:
            disconnect,
            turn,
            changeView,
            giveUp
         *)
    |   ST_LEVEL_FINISHED 
        (* valid calls by a client:
            disconnect,
            giveUp
         *)
    |   ST_TOURNAMENT_FINISHED
        (* valid calls by a client:
            disconnect
         *)


    structure PMap      = MkHashImpMap (Int)

    
    fun tabulateStream (n, f) =
        let
            fun lazy endless i = 
                f i :: endless (i + 1)
            fun lazy ntimes (n, i) =
                if i >= n then []
                else f i :: ntimes (n, i + 1)
        in
            case n of 
                NONE    => endless 0
            |   SOME n  => ntimes (n, 0)
        end    

    
    (** compute possibly infinite stream of levels according
        to config *)
    fun computeLevels ({    dimensions, maxPlayers=players,
                            levels = levelNum,
                            ...
                        } : Protocol.config) =
        tabulateStream (levelNum, 
                fn _ => Arena.random { dimensions, players, walls = 4 } handle e => assert false
            ) 
            

    fun startServer (client, config : Protocol.config) =
        let
            structure Part  = Participant
            structure P     = Protocol
   
            val participants    = PMap.map () : Participant.participant PMap.map

            val state           = ref ST_JOIN
            val events          = ref (Events.events ())
            val pc_id           = 0
   
            val levels          = computeLevels config
            val startPos        = ref (List.hd levels ++ #2) 
            
            fun nextStartPos () =
                case !startPos of
                    []      => NONE
                |   g :: gs => (startPos := gs; SOME g)
           

            (* [allParticpants p] return all participants which 
               satisfy the predicate p.  
             *)
            fun allParticipants p = List.map #2 (List.filter p 
                                    (PMap.toList participants))
            
            (* [allPlayers ()] returns all snakes which are either
               still playing.
             *)
            fun allPlayers ()   = allParticipants 
                    (fn (_, p) =>
                        case !(Part.state p) of
                            Part.PLAYING _              => true
                        |   _                           => false)
            
            fun allHalfFinished ()  = allParticipants 
                    (fn (_, p) => 
                        case !(Part.state p) of 
                            Part.HALF_FINISHED _        => true
                        |   _                           => false)


            fun allNonFinished ()   = allParticipants 
                    (fn (_, p) =>
                        case !(Part.state p) of
                            Part.PLAYING _              => true
                        |   Part.HALF_FINISHED _        => true
                        |   _                           => false)


            fun allConnected () = allParticipants
                    (fn (_, p) =>
                        case !(Part.state p) of
                            Part.DISCONNECTED   => false
                        |   _                   => true)


            fun allPossiblePlayers () = allParticipants
                    (fn (_, p) =>
                        case !(Part.state p) of
                            Part.PLAYING _      => true
                        |   Part.FINISHED _     => true
                        |   Part.HALF_FINISHED _ => true
                        |   Part.DEAD _         => true
                        |   _                   => false)


            val lock        = Lock.lock ()
            
	    (* RPC call.  
               - Synchronized so that there can always be
                 only one call to a given client.
               - If an exception is raised the RPC has failed
                 and the client is removed from the connection 
                 queue!
               - Does nothing if the client is already disconnected.
             *)
            fun invoke (part, f, a) =
                let
                    (* we use this promise as a lock *)
                    val p       = Promise.promise () 
                    val id      = Part.id part
                    val _       = 
                        log ("Server", ("invoke: aquiring lock on", id))
                    val state   = Ref.exchange (Part.state part, 
                                                    Promise.future p)
                    val client  = Part.client_interface part
                in
                    ((case state of
                        Part.DISCONNECTED   => 
                            log ("Server", ("invoke: disconnected", id))
                    |   _                   => 
                        (log ("Server", ("invoke: calling", id));
                         f client a;
                         log ("Server", ("invoke: called", id))));
                    (* call was successful. state hasn't changed.
                       must fulfill the promise anyway to release
                       the lock. *)
                    log ("Server", ("releasing lock on", id));
                    Promise.fulfill (p, state));
                    log ("Server", ("lock released on", id))
                handle e => (
                    (* call failed! *)
                    log ("Server", "RPC failed: " ^ exnName e);
                    (* change state to disconnected *)
                    Promise.fulfill (p, Part.DISCONNECTED))
                end 
                
            (* Invoke f a on several clients simultaneously.
               Returns immediately -- without waiting for the
               calls to finish.
             *)
            fun invokeSeveral loc (clients, f, a) = 
                List.app (fn c => ispawn loc invoke (c, f, a)) 
                    clients 
               

            (* [withParticipant def (procName, id, f) returns a function which 
               when invoked applies the participant with id [id]
               on f unless that participant is disconnected.
             *)
            fun withParticipant default (procName, id, f) a =
                let val p = PMap.lookupExistent (participants, id)
                in
                    case !(Part.state p) of 
                        Part.DISCONNECTED   => default
                    |   _                   => f (p, a)
                end handle PMap.Unknown id =>
                    raise P.Protocol (procName ^ ": unknown client " ^ 
                            Int.toString id)
            

            fun disconnect id = Lock.sync lock (
                withParticipant () ("disconnect", id, fn (part, ()) =>
                    () 
                ))

            
            fun computePointsList () =
                List.map (fn p =>
                    let val (name, 
                            color)  = Part.nameNColor p
                        val info    = Part.playerInfo p
                        val points  = ! $ #points info
                        val gamePoints = ! $ #gamePoints info
                    in
                        { name, color, points, gamePoints }
                    end) (allPossiblePlayers ())

            fun sendPoints p =
                invokeSeveral p (allConnected (), #updatePoints, 
                    computePointsList ())

            fun play id = Lock.sync lock (
                withParticipant false ("play", id, fn (part, (name, color)) =>
                    case ! (Part.state part) of
                        (non Part.CONNECTED)    =>
                        raise P.Protocol "Server: invalid call to play"

                    |   Part.CONNECTED  =>
                        case nextStartPos () of
                            (* there is place for another player 
                                on this map ;-) *)
                            SOME (pos, dir) =>
                            let
                                val playerState = {
                                        points      = ref 0,
                                        gamePoints  = ref 0,
                                        name        = name,
                                        color       = color,
                                        deathCount  = ref 0,
                                        gatePos     = ref pos,
                                        nextDir     = ref dir
                                    }
                                val snake   = Snake.snake (id, color, pos, dir)
                                val players = allPlayers () 
                            in
                                (Part.state part) := Part.PLAYING 
                                                        (playerState, snake);
                                (* inform the other PLAYERs *)
                                invokeSeveral (_file_, _line_) 
                                    (players, #playersJoined, [(name, color)]);
                                (* inform the NEW player of the other 
                                   already connected players *)
                                ispawn (_file_, _line_) 
                                    invoke (part, #playersJoined, 
                                        List.map Part.nameNColor players);
                                true
                            end
                        |   NONE => false   
                            (* no unused gates left :-( *)
                ))
                
                
            fun watch id = Lock.sync lock (
                withParticipant () ("watch", id, fn (part, ()) => 
                    case ! (Part.state part) of
                        (non Part.CONNECTED)    =>
                        raise P.Protocol "Server: invalid call to watch"

                    |   Part.CONNECTED  =>
                        let
                            val players = allPlayers ()
                        in
                            (Part.state part) := Part.WATCHING (ref ~1);
                            (* inform the NEW player of the other 
                               already connected players *)
                            ispawn (_file_, _line_)
                                invoke (part, #playersJoined, 
                                    List.map Part.nameNColor players)
                        end
                ))


            fun turn id = Lock.sync lock (
                withParticipant () ("turn", id, fn (part, dir) => 
                    case ! (Part.state part) of
                        Part.PLAYING (state, _) =>
                        (#nextDir state) := dir
                    |   _                       =>
                        raise P.Protocol "Server: invalid call to turn"
                ))


            fun changeView id = Lock.sync lock (
                withParticipant () ("changeView", id, fn (part, hint) => 
                    not_yet_implemented ("changeView")
                ))


            fun giveUp id = Lock.sync lock (
                withParticipant () ("giveUp", id, fn (part, ()) => 
                    not_yet_implemented ("giveUp")
                ))

           
            exception TournamentFinished

            fun finishTournament () = 
                let
                    val highscore   = HighscoreIO.load ()
                    val highscore   = Highscore.merge (highscore, 
                                        computePointsList (), 0) (*FIXME*)
                    val _           = HighscoreIO.save highscore
                in
                    invokeSeveral (_file_, _line_)
                        (allConnected (), #tournamentFinished, highscore);
                    raise TournamentFinished
                end

           
            fun startNextLevel (levels, arena, startPos) =
                let
                    val _   = events := Events.events ()
                    (* get all players who are allowed to play another level *)
                    val p   = allPossiblePlayers ()

                    (* dimensions of the new level *)
                    val dims    = Array2.dimensions arena
		    val oldArena= Arena.copy arena
		    val diffs   = Arena.toDiffList arena
                in
                    (* set players state to playing and place snake *)
                    assert List.length p <= List.length startPos do
                    ListPair.app 
                        (fn (part, (pos, dir)) =>
                            let
                                val state       = Part.state part
                                val info        = Part.playerInfo part
                                val (name,color)= Part.nameNColor part
                                val id          = Part.id part
                                val snake       = Snake.snake 
                                                    (id, color, pos, dir)
                                val g           = (pos, P.GATE (color, 
                                                        P.CLOSED))
                            in
                                (#nextDir info) := dir;
                                (#gatePos info) := pos;
                                state := Part.PLAYING (info, snake);
                                Events.add (!events, Snake.belly snake + 2, 
                                                SOME g, SOME g)
                            end
                        ) (p, startPos);

		    log ("Server", "sending levelStarted");
                    invokeSeveral (_file_, _line_) 
                        (allConnected (), #levelStarted,{ dimensions = dims });
                    
		    log ("Server", (">>>>sending initial Difflist<<<<<<", diffs));
                    invokeSeveral (_file_, _line_) (allConnected (), #update, diffs);
                    
                    log ("Server", ("sending initial points"));
                    sendPoints (_file_, _line_);

                    {levels, oldArena, newArena=arena, goodies = 0}
                end
            
            
            fun finishLevel (levels) =
                (* called when no players are left *)
                let
                    val _   = assert null (allPlayers ())
                in
                    (* send level finished signal *)
                    invokeSeveral (_file_, _line_) 
                        (allConnected (), #levelFinished, ());
                    
                    case levels of
                        []  =>      (* no more levels -- tournament ended *)
                        finishTournament ()
                    |   (arena, startPos) :: ls =>
                        startNextLevel (ls, arena, startPos)
                end
                
            fun findEmptySpot (arena, nTriesLeft) =
                if nTriesLeft <= 0 then NONE
                else
                    let
                        val (rows, cols) = Array2.dimensions arena
                        val row = Random.int (rows - 2) + 1
                        val col = Random.int (cols - 2) + 1
                    in
                        if Array2.sub (arena, row, col) = P.EMPTY 
                            then SOME (row, col) 
                        else
                            findEmptySpot (arena, nTriesLeft - 1)
                    end

                
            fun mayPlaceGoody (arena, g) = 
                Option.app 
                    (fn (r, c) => Array2.update (arena, r, c, P.GOODY 5)) g
                
                    
            fun mayAppList f [] = ()
              | mayAppList f l  = f l

            val tick    = Lock.sync lock (fn {levels, oldArena, newArena, 
                                                                goodies} =>
                let
                    val _       = log ("Server", "tick")
                    val players = allPlayers ()

                    fun movePlayer (p, moved) =
                        let val snake   = Part.snake p
                            val info    = Part.playerInfo p
                        in
                            log ("Server", "moving player " ^ 
                                    Int.toString (Part.id p));
                            Snake.move (snake, !(#nextDir info));
			    (p, Snake.head snake) :: moved
                        end
                       
                    (* move all still playing snakes *)
                    val newHeadPos = List.foldl movePlayer [] players 
                    
                    (* place them on the newArena *)
                    val { dead = deadSnakes, grown = grownSnakes, 
                          finished = finishedSnakes } = 
                            Arena.placeSnakes (newArena, 
                                         List.map Part.snake players) 

                    (* open gates if necessary *)
                    val gates   =   List.foldl (fn (sn, res) =>
                        let val part    = PMap.lookupExistent 
                                                (participants, Snake.id sn)
                            val info    = Part.playerInfo part
                            val pos     = !(#gatePos info)
                            val color   = #color info
                        in
                            if Snake.belly sn >= #gateTreshold config then
                                (* Note: gate might already be open, but we
                                   do not bother to keep track and update 
                                   anyway.
                                 *)
                                let val gate    = P.GATE (color, P.OPEN)
                                    val (r, c)  = pos 
                                in
                                    Array2.update (newArena, r, c, gate);
                                    (pos, gate) :: res
                                end
                            else res
                        end) [] grownSnakes;
                    
                    (* handle events *)
                    val (diffNew, diffOld)  = Events.tick (!events)
                    val _       = List.app (fn ((r,c), p) => 
                                    Array2.update (newArena, r, c, p)) diffNew

                    (* all grown snakes have eaten a goody. *)
                    val goodies     = goodies - List.length grownSnakes
                    val _           = assert goodies >= 0

                    (* shall we place another goody? *)
                    val (goodiePos, goodies) = 
                            if goodies < #goodie config andalso 
                                    Random.real 1.0 <= #goodieProb config 
                                then case findEmptySpot (newArena, 3) of
                                        NONE    =>  (NONE, goodies)
                                    |   spot    =>  (spot, goodies + 1)
                                else (NONE, goodies)

                    val _   = mayPlaceGoody (newArena, goodiePos)

                    val _   = log ("Server", ("calculating differences", oldArena, newArena))
                    val changes = Arena.diff (oldArena, newArena)
                    val _   = log ("Server", ("differences", changes))
                    val _   = mayPlaceGoody (oldArena, goodiePos)

                    val _   = List.app (fn ((r,c), g) => 
                                Array2.update (oldArena, r, c, g)) gates

                    val _   = List.app (fn ((r, c), p) =>
                                    Array2.update (oldArena, r, c, p)) diffOld
                    val pointsChanged   = ref false
                in
                    (* broadcast differences *)
                    log ("Server", "broadcasting differences");
                    invokeSeveral (_file_, _line_) 
                        (allConnected (), #update, changes);
                    
                    (* change state of participants whose snake died to DEAD. *)
                    log ("Server", "check for dead snakes");
                    
                    List.map (fn sn =>
                        let val part        = PMap.lookupExistent 
                                                (participants, Snake.id sn)        
                            val playerInfo  = Part.playerInfo part
                            val (name, 
                                color)      = Part.nameNColor part
                            val points      = ! $ #points playerInfo
                        in
                            (Part.state part) := Part.DEAD (playerInfo, ref ~1); (*FIXME*)
                            
                            (* reset gamepoints to zero, points are not changed
                               as the snake died before entering the gate *)
                            if !(#gamePoints playerInfo) <> 0 then (
                                #gamePoints playerInfo := 0;
                                pointsChanged := true
                            ) else ();

                            (* build list of names and colors of dead snakes *)
                            Part.nameNColor part
                        end) deadSnakes ++
                            
                    (* inform the snakes, if any corpses are around *)
                    mayAppList (fn deads => invokeSeveral (_file_, _line_)
                                 (allConnected (), #playersDied, deads));
                
		    (* inform snake about their new head positions *)
		    (* FIXME: do not send headPos to dead snakes *)
		    (* send headPos to those snakes who 
		       are watching this one *)
		    List.app (fn (part, p) =>
			      ispawn (_file_, _line_)
			         invoke (part, #headPosition, p)) newHeadPos;
 
                    (* change state of participants whose snakes are 
                       finished to HALF_FINISHED, as soon as their
                       snake has entered the gate completely we change
                       it to FINISHED *)
                    log ("Server", "check for finished snakes");
                    List.map (fn sn =>
                        let val id          = Snake.id sn
                            val part        = PMap.lookupExistent 
                                                (participants, id)
                            val playerInfo  = Part.playerInfo part
                            val length      = Snake.length sn - 1
                            val body        = Snake.body sn
                            val (name, 
                                 color)     = Part.nameNColor part
                            
                            fun addPlaceBodyEvent t =
                                List.app (fn p =>
                                    Events.add (!events, t, 
                                        SOME (p, P.SNAKE_BODY color), 
                                        NONE))
                                    (List.take (body, length - t + 1))
                        in
                            Part.state part := Part.HALF_FINISHED 
                                        (playerInfo, ref length);
                                        
                            (* take the points made this game home *)
                            #points playerInfo := !(#points playerInfo) + 
                                    !(#gamePoints playerInfo);
                            pointsChanged := true;
 
                            (* reset the gamePoints *)
                            #gamePoints playerInfo := 0;
                            
                            (* schedule animation of snake going into the gate *)
                            for (1, length, addPlaceBodyEvent);
                            
                            (name, color) 
                        end) finishedSnakes ++
                        
                    (* inform the snakes *)
                    mayAppList (fn namesNColors =>
                        invokeSeveral (_file_, _line_)
                            (allConnected (), #playersFinished, namesNColors));
                    
                    (* send updated points list if necessary *)
                    if !pointsChanged then
                        sendPoints (_file_, _line_)
                    else ();

                    (* check for completely finished participants 
                     *)
                    log ("Server", "check for completely finished snakes");
                    List.app (fn part =>
                        case !(Part.state part) of
                            Part.HALF_FINISHED (info, ref 0) =>
                                Part.state part := Part.FINISHED (info, ref ~1) 
                                    (*FIXME: find snake to watch *)
                        |   Part.HALF_FINISHED (info, n) => n := !n - 1
                        |   _           => assert false
                    ) (allHalfFinished ());
                    
                        
                    (* send tick signal *)
                    log ("Server", "send tick signal");
                    invokeSeveral 
                        (_file_, _line_) (allConnected (), #tick, NONE);
  
                    (* test wether there are any living snakes left *)
                    case allNonFinished () of
                        []  => (
                        log ("Server", "no more players left");
                        finishLevel levels)
                    |   _   => ( 
                        (* swap old & new arena *)
                        log ("Server", "players left --> play next round");
                        {levels, oldArena = newArena, newArena = oldArena,
                            goodies })
                end)


            fun ticker () = 
                let
		    val (arena, pos)  = assert not (null levels) do
			                  List.hd levels

                    fun loop state =
                        let 
                            val state = tick state
                        in
                            Thread.sleep (#tick config);
                            loop state
                        end
        
                    val state = startNextLevel 
			    (List.tl levels, arena, pos)
		in
                    loop state 
                end handle  TournamentFinished  => ()

                
            val startGame = Lock.sync lock (fn () => (
                (* test wether there is any player at all... *)
                if !state = ST_JOIN then state := ST_GAME
                else raise P.Protocol "game already started";
                
                (* send startTournament signal *)
                invokeSeveral (_file_, _line_)
                    (allConnected (), #tournamentStarted, ());
                
                (* start tick signal sender *)
                ispawn (_file_, _line_) ticker ()
                ))


            val connect = Lock.sync lock (fn client_interface =>
                (* connect is only called by UCs. *)
                let (* are we still in join mode ? *)
                    val _       =   if !state = ST_JOIN then ()
                                    else raise P.Protocol "game already running"

                    (* determine id *)
                    val id      = PMap.size participants 
                    val uc      = Part.participant (id, client_interface)
                in
                    (* insert into participant map *)
                    PMap.insertDisjoint (participants, id, uc);
                    (* return adapted server interface.
                       NOTE: UCs are not allowed to call startGame
                        therefore startGame = NONE
                    *)
                    (config, {
                        disconnect  = Remote.proxy (disconnect id),
                        play        = Remote.proxy (play id),
                        turn        = Remote.proxy (turn id),
                        changeView  = Remote.proxy (changeView id),
                        giveUp      = Remote.proxy (giveUp id),
                        startGame   = NONE,
                        watch       = Remote.proxy (watch id)
                    })
                end)
            
        (* create PC representation *)
            val pc  =   Part.participant (pc_id, client)
            val pc_server_interface = 
                {   disconnect  = Remote.proxy (disconnect pc_id),
                    play        = Remote.proxy (play pc_id),
                    turn        = Remote.proxy (turn pc_id),
                    changeView  = Remote.proxy (changeView pc_id),
                    giveUp      = Remote.proxy (giveUp pc_id),
                    watch       = Remote.proxy (watch pc_id),
                    startGame   = SOME (Remote.proxy startGame)
                }
            (* add server to the participant map *)
            val _ = PMap.insertDisjoint (participants, pc_id, pc)

            (* offer the connect procedure to allow other clients
               (UCs) to connect
             *)
            val package = pack (val connect = Remote.proxy connect) :> Protocol.SERVER_CONNECTOR
            val ticket  = Remote.offer package
        in
            (* return ticket and server interface *)
            (ticket, pc_server_interface)
        end
        
end

(*

fun test () =
    let
        val (ticket, server) = Server.startServer 
                    (dummyClient, 
                { Config.defaultSingle where tick = Time.fromSeconds 3 } )
    in
        #play server ("bene", Color.fromString "yellow");    
        valOf (#startGame server) ();
        (ticket, server)
    end
    
*)
