(* Alice Snake 2.0 - Arena
 *
 *  Authors: Benedikt Grundmann / Sebastian Germesin
 *
 *  $Revision$
 *
 *  Last updated: $Date$ by $Author$
 * 
 *
 *)

import signature ARENA    from "ARENA-sig"
import structure Protocol from "../common/Protocol"
import structure Snake    from "Snake"
import structure Pos      from "../common/Pos"
import structure Random   from "x-alice:/lib/utility/Random"

structure Arena :> ARENA =
struct

    structure P = Protocol

    type arena = P.field Array2.array (* MUTABLE *)


    type config = 
	{
	 dimensions: int * int,
	 players: int,
	 walls: int
	 (* MAGIC NUMBERs ... *)
	 }
(*    
    fun random {dimensions : int * int, players,walls} =
	let
	    val (maxR,maxC) = dimensions
	    val arena = Array2.array(maxR,maxC,P.EMPTY)
	    (* initialising an empty arena with dimensions [dimensions] *)

	    fun setLimit () = (* set a wall round the level *)
		let
		    fun horizontal r = 
			if r = maxR
			    then (Array2.update(arena,maxR-1,0,P.WALL);
				  Array2.update(arena,maxR-1,maxC-1,P.WALL))
			else (Array2.update(arena,r,0,P.WALL);
			      Array2.update(arena,r,maxC-1,P.WALL);
			      horizontal(r + 1))
		    fun vertical c = 
			if c = maxC 
			    then (Array2.update(arena,0,maxC-1,P.WALL);
				  Array2.update(arena,maxR-1,maxC-1,P.WALL))
			else (Array2.update(arena,0,c,P.WALL);
			      Array2.update(arena,maxR-1,c,P.WALL);
			      vertical(c + 1))
		in
		    (horizontal (0); vertical (0))
		end

	    fun setWall   _   _ 0 = ()
	      | setWall (r,c) d n = 
		case d of
		    P.UP    => (Array2.update(arena,r,c,P.WALL);
				wall (Pos.above(r,c)) d (n-1))
		  | P.DOWN  => (Array2.update(arena,r,c,P.WALL);
				wall (Pos.below(r,c)) d (n-1))
		  | P.LEFT  => (Array2.update(arena,r,c,P.WALL);
				wall (Pos.left(r,c)) d (n-1))
		  | P.RIGHT => (Array2.update(arena,r,c,P.WALL);
				wall (Pos.right(r,c)) d (n-1))
	    (* [wall (rs,cs) d s] sets a wall in direction [d]
	       with length [s] and startposition [rs,cs] *)

	    fun chooseWall () =
		let
		    val l_horizont = Random.int (maxC div 2) - 2
		    val l_vertical = Random.int (maxR div 2) - 2
		    fun wall 0 = setWall (10,10) P.UP l_vertical
		      | wall 1 = setWall (10,10) P.DOWN l_vertical
		      | wall 2 = setWall (10,10) P.LEFT l_horizont
		      | wall 3 = setWall (10,10) P.RIGHT l_horizont
		in
		    wall (Random.int 4)
		end

	    fun setWalls n = if n = 0
				 then ()
			     else (chooseWall ();
				   setWalls (n-1))

	    fun startPointTest startlist = true (* TODO: implementation *)

	    fun startpoints 0 xs = xs
	      | startpoints p xs = 
		let
		    val (rs,cs) = (Random.int maxR,Random.int maxC)
		    val d = case Random.int 4 of
			         0 => P.UP
			       | 1 => P.DOWN
			       | 2 => P.LEFT
			       | _ => P.RIGHT
		in
		    if startPointTest(rs,cs,d)
			then startpoints (p-1) ((rs,cs,d)::xs)
		    else startpoints p xs
		end

	    fun correctionTest a = true (* TODO: implementation *)
		
	in
	    (setLimit ();
	     setWalls (Random.int walls);
	     if correctionTest arena
		 then (arena,startpoints players nil)
	     else random {dimensions,players})
	end
*)

    fun random {dimensions : int * int,players,walls} = 
	let
	    val (maxR,maxC) = dimensions
	    val arena = Array2.array(maxR,maxC,P.EMPTY)
	    (* initialising an empty arena with dimensions [dimensions] *)

	    fun setLimit () = (* set a wall round the level *)
		let
		    fun horizontal r = 
			if r = maxR
			    then (Array2.update(arena,maxR-1,0,P.WALL);
				  Array2.update(arena,maxR-1,maxC-1,P.WALL))
			else (Array2.update(arena,r,0,P.WALL);
			      Array2.update(arena,r,maxC-1,P.WALL);
			      horizontal(r + 1))
		    fun vertical c = 
			if c = maxC 
			    then (Array2.update(arena,0,maxC-1,P.WALL);
				  Array2.update(arena,maxR-1,maxC-1,P.WALL))
			else (Array2.update(arena,0,c,P.WALL);
			      Array2.update(arena,maxR-1,c,P.WALL);
			      vertical(c + 1))
		in
		    (horizontal (0); vertical (0))
		end

	    val startpointlist = nil

	in
	    setLimit ();
	    (arena,startpointlist)
	end




    fun placeSnakes (a,snakes) =
	let
	    val died = ref nil
	    val halffin = ref nil
	    val fin = ref nil

	    fun killSnake s = 
		let
		    val hb = (Snake.head s)::(Snake.body s)
		in
		    died := s::(!died);
		    List.app 
		        (fn (r,c) => Array2.update(a,r,c,P.EMPTY)) hb
		end

	    fun placeHead snake =
		let
		    val (r,c) = Snake.head snake
		    val color = Snake.color snake
		    val dir   = Snake.direction snake
		    val collObject = Array2.sub(a,r,c)
		    fun hitSnake s     nil     = false
		      | hitSnake s (sn::slist) = 
			let
			    val hb = (Snake.head sn)::(Snake.body sn)
			in
			    if List.exists (fn x => Snake.head s = x) hb
				then true
			    else hitSnake s slist
			end
			
		    val othersnakes = 
			    List.filter (fn x => not (snake = x)) snakes
		    val hit = hitSnake snake othersnakes
		in
		    Array2.update(a,r,c,P.SNAKE_HEAD(dir,color));
		    if hit
			then killSnake snake
		    else 
			case collObject of
			 P.EMPTY    => ()
		       | P.GOODIE n => Snake.eat (snake,n)
		       | P.WALL     => killSnake snake
		       | P.GATE col => 
			     if col = color andalso Snake.length snake = 1
				 then (fin := snake::(!fin);
				       Array2.update(a,r,c,collObject))
			     else
				 if col = color
				     then (halffin := snake::(!halffin);
					   Array2.update(a,r,c,collObject))
				 else killSnake snake
		       | P.SNAKE_HEAD(_,col) => 
				 if col <> color 
				     then killSnake snake
				 else ()
		       |     _      => (assert false;
					killSnake snake)
		end

	    fun placeBody snake =
		let
		    val color = Snake.color snake
		    val body =  Snake.body snake
		    fun stillDied s = color = Snake.color s
		    val stilldied = List.exists stillDied (!died)
		in
		    if stilldied
			then ()
		    else 
			List.app 
			    (fn(r,c) => Array2.update(a,
						      r,
						      c,
						      P.SNAKE_BODY(color)))
			         body
		end
		
	in
	    List.app placeHead snakes;
	    List.app placeBody snakes;
	    (!died,!halffin,!fin)
	end
    
    fun emptyCopy a =
        let val (rows, cols) = Array2.dimensions a
        in
            Array2.array (rows, cols, P.EMPTY)
        end

        
    fun removeSnakes (a,snakes) = 
	let
	    fun removeSnake s =
		let
		    val positions = (Snake.head s)::(Snake.body s)
		in
		  List.app (fn(r,c) => Array2.update(a,r,c,P.EMPTY)) positions
		end
	in
	    List.app (fn s => removeSnake s) snakes
	end
    (** removes all snakes *)

    fun diff (old,new) = (* TODO: schlangen auf old löschen *)
      let
	  val (rows, cols) = Array2.dimensions old       (* dimensions *)
	  fun help (r, c) xs = 
	      if c = cols
		  then xs
	      else 
		  if r = rows
		      then help (0, c + 1) xs
		  else
		      if Array2.sub (old, rows, cols) = 
			 Array2.sub (new, rows, cols)
			  then help (r + 1, c) xs
		      else help (r+1, c) (((r,c),Array2.sub(new, r, c))::xs)
      in
	  help (0,0) nil
      end

end







