import structure Gtk                  from "x-alice:/lib/gtk/Gtk"
import structure Gdk                  from "x-alice:/lib/gtk/Gdk"
import structure GtkCanvas            from "x-alice:/lib/gtk/GtkCanvas"
import structure Inspector            from "x-alice:/lib/tools/Inspector"
import structure Ctrl                 from "x-alice:/lib/utility/Ctrl"

import structure Color                from "../../common/Color"
import structure Config               from "../../server/Config"
import structure Protocol             from "../../common/Protocol"
import structure ArenaWidget          from "ArenaWidget"
import structure HighscoreIO          from "../../server/HighscoreIO"

import structure ConnectionWindow     from "ConnectionWindow"
import structure ServerSettingsWindow from "ServerSettingsWindow"
import structure TextWindow           from "TextWindow"
import structure QuestionWindow       from "QuestionWindow"


open Ctrl

structure MainWindow =
struct

    (* the modes in which the window can exists *)
    datatype mode = START | GAME

    val mode = ref START

    (* initialising the canvas widget *)
    val arena = ArenaWidget.initialize ()
    val canvas = ArenaWidget.toObject arena

    (* the menu bar items whose sensitivity get 
     changed some times *)
    val menu_hi_item = Gtk.menuItemNewWithLabel "Highscore"
    val menu_m_item  = Gtk.menuItemNewWithLabel "Menu"
    val menu_gu_item = Gtk.menuItemNewWithLabel "Give Up"


	(* one of the main prcedures. resets the window
	 in START mode and also the sensitivity of menu bar *)
    fun reset' () =
	(Gtk.widgetSetSensitive (menu_gu_item, false);
	 Gtk.widgetSetSensitive (menu_m_item, true);
	 Gtk.widgetSetSensitive (menu_hi_item, true);
	 Gtk.widgetHide canvas;
	 mode := START)


    (* resets window and also shows TextWindow when needed *)
    fun reset NONE = reset' ()
      | reset (SOME (title, msg)) =
	(TextWindow.mkTextWindow (title, msg); reset' ())


    (* initializing of the procedures from model_game *)
    val turn' = ref (fn d => ())
    val changeView' = ref (fn h => ())
    val giveUp' = ref (fn () => ())
    val disconnect' = ref (fn () => ())

    fun gameMode ({disconnect}, {turn, changeView, giveUp},
		   guiGame) =
	let
	    fun gameFinished h = 
		 reset (SOME ("Highscore", "highscore...!"))

	    fun update difflist = ArenaWidget.update (arena, difflist)

	    fun updatePoints p = () (* TODO: implementation *)

	    fun startLevel levinf = ArenaWidget.initLevel (arena, levinf)

	    fun headPosition p = ArenaWidget.changeView (arena, p)

	in
	    mode := GAME;
	    Gtk.widgetSetSensitive (menu_gu_item, true);
	    Gtk.widgetSetSensitive (menu_m_item, false);
	    Gtk.widgetSetSensitive (menu_hi_item, false);
	    Gtk.widgetShow canvas;
	    assert (Future.isFuture $ Promise.future guiGame) 
	    do Promise.fulfill (guiGame, {startLevel, update, 
					  updatePoints, headPosition,
					  gameFinished});
	    (* updates procedures *)
	    turn' := turn;
	    changeView' := changeView;
	    giveUp' := giveUp;
	    disconnect' := disconnect
	end
	 

    fun mkMainWindow ({connect, startServer}, gui) = 
	let

	    val _ = assert (Future.isFuture $ Promise.future gui) 
		        do Promise.fulfill (gui, {reset})

	    (* the different behaviour by pressing the quit button *)
	    fun mainQuit () = 
		case !mode of
		    START => OS.Process.exit OS.Process.success 
		  | GAME  => 
			let
			    val answer = Promise.promise ()
			    val _ = Inspector.inspect ("blblblblblb", answer)
			in
			    QuestionWindow.mkQuestionBox 
			    ("Sure?", "Do you want to quit?", answer);
			    case Promise.future answer of
			     QuestionWindow.YES    => ((!disconnect') ();
						       reset NONE)
			   | QuestionWindow.NO     => ()
			   | QuestionWindow.CANCEL => ()
			end
		     
			
	    val main_window     = Gtk.windowNew Gtk.WINDOW_TOPLEVEL
	    val dialog_vbox1 	= Gtk.vboxNew (false, 10)
	    val canvas_vbox2    = Gtk.vboxNew (false, 10)
	    val menu_m_single	= Gtk.menuItemNewWithLabel "Single-Player"
	    val menu_m_client	= Gtk.menuItemNewWithLabel "Multi-Player Client"
	    val menu_m_server	= Gtk.menuItemNewWithLabel "Multi-Player Server"
	    val menu_bar	= Gtk.menuBarNew ()
	    val menu_menu	= Gtk.menuNew ()
	    val menu_highscore	= Gtk.menuNew ()
	    val menu_quit       = Gtk.menuNew ()
	    val menu_q_item	= Gtk.menuItemNewWithLabel "Quit"
	    val menu_qu_item    = Gtk.menuItemNewWithLabel "Quit"


	    (* procedure called by pressing Client - button *)
	    fun startClient () = 
		ConnectionWindow.mkConnectToServer ({connect},
						    {reset, gameMode})

	    (* procedure called by pressing Server - button *)
	    fun startMultiPlayer () = 
		ServerSettingsWindow.mkServerSettings ({startServer},
						       {reset, gameMode})

	    (* opens the highscore window *)
	    fun openHighscore () = 
		let
		    val score = HighscoreIO.load ()
		in
		    TextWindow.mkTextWindow ("Highscore", "highscore...") 
		end

	    fun startSinglePlayer () = 
		case startServer (SOME ("Player", Color.fromString "blue"), 
				  Config.defaultSingle) of
		    FST ({start, disconnect}, _, _) => 
			(case start () of
			     FST (mGame, guiGame) => 
				 gameMode ({disconnect}, mGame, guiGame)
			   | SND   errorMsg       => 
				 reset (SOME ("ERROR!!", errorMsg)))
		  | SND    errorMsg       => reset (SOME ("ERROR!!", errorMsg))

	    fun key keyval =
		  if !mode = GAME
		      then
			  case Gdk.keyvalName keyval of
			        "Up"      => (!turn') Protocol.UP
			    |   "Down"    => (!turn') Protocol.DOWN
			    |   "Right"   => (!turn') Protocol.RIGHT
			    |   "Left"    => (!turn') Protocol.LEFT
			    | ("q" | "Q") => (!changeView') Protocol.PREV
			    | ("w" | "W") => (!changeView') Protocol.NEXT
			    |   _         => ()
		  else ()


	    fun canvasEvent [Gtk.EVENT event] = 
		(case event of
		     Gtk.GDK_KEY_PRESS {keyval, ...}	=> key keyval
		   |            _                  	=> ())
	      |  canvasEvent       _            = ()

	in

	    mode := START;
	    Gtk.windowSetTitle (main_window, "Alice Snake");
	    Gtk.windowSetDefaultSize (main_window, 800, 500);
	    Gtk.windowSetPosition (main_window, Gtk.WIN_POS_CENTER);
	    
	    Gtk.menuAppend (menu_menu, menu_m_single);
	    Gtk.menuAppend (menu_menu, menu_m_client);
	    Gtk.menuAppend (menu_menu, menu_m_server);
	    Gtk.menuAppend (menu_quit, menu_gu_item);
	    Gtk.menuAppend (menu_quit, menu_qu_item);
	    Gtk.widgetHide canvas;

	    Gtk.signalConnect (main_window, "event",
			       canvasEvent);
	    Gtk.signalConnect (main_window, "delete-event", 
			       fn _ => mainQuit ());
	    Gtk.signalConnect (menu_hi_item, "activate", 
			       fn _ => openHighscore ());
	    Gtk.signalConnect (menu_m_single, "activate", 
			       fn _ => startSinglePlayer ());
	    Gtk.signalConnect (menu_m_client, "activate", 
			       fn _ => startClient ());
	    Gtk.signalConnect (menu_m_server, "activate", 
			       fn _ => startMultiPlayer ());
	    Gtk.signalConnect (menu_qu_item, "activate", 
			       fn _ => mainQuit ());
	    Gtk.signalConnect (menu_gu_item, "activate",
			       fn _ => (!giveUp') ());

	    Gtk.menuItemSetSubmenu (menu_m_item, menu_menu);
	    Gtk.menuItemSetSubmenu (menu_q_item, menu_quit);

	    Gtk.widgetSetSensitive(menu_gu_item, false);

	    Gtk.menuBarAppend (menu_bar, menu_m_item);
	    Gtk.menuBarAppend (menu_bar, menu_hi_item);
	    Gtk.menuBarAppend (menu_bar, menu_q_item);
	    
	    Gtk.boxPackStart (dialog_vbox1, menu_bar, false, false, 0);
	    Gtk.boxPackStart (dialog_vbox1, canvas, true, true, 0);

	    Gtk.containerAdd (main_window, dialog_vbox1);

	    Gtk.widgetShowAll main_window
		
	end
end
