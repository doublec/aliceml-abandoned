import structure Gtk                  from "x-alice:/lib/gtk/Gtk"
import structure Gdk                  from "x-alice:/lib/gtk/Gdk"
import structure GtkCanvas            from "x-alice:/lib/gtk/GtkCanvas"
import structure Inspector            from "x-alice:/lib/tools/Inspector"
import structure Ctrl                 from "x-alice:/lib/utility/Ctrl"
import structure Color                from "../../common/Color"
import structure Config               from "../../server/Config"
import structure Protocol             from "../../common/Protocol"
import structure ArenaWidget          from "ArenaWidget"

import structure ConnectionWindow     from "ConnectionWindow"
import structure ServerSettingsWindow from "ServerSettingsWindow"
import structure TextWindow           from "TextWindow"
import structure QuestionWindow       from "QuestionWindow"


structure MainWindow =
struct

    open Ctrl

    datatype mode = START | GAME

    val mode = ref START

    val arena = ArenaWidget.initialize ()

    val canvas = ArenaWidget.toObject arena

    val menu_hi_item = Gtk.menuItemNewWithLabel "Highscore"
    val menu_m_item  = Gtk.menuItemNewWithLabel "Menu"
    val menu_gu_item = Gtk.menuItemNewWithLabel "Give Up"

    fun reset' () = 
	(Gtk.widgetSetSensitive (menu_gu_item, false);
	 Gtk.widgetSetSensitive (menu_m_item, true);
	 Gtk.widgetSetSensitive (menu_hi_item, true);
	 Gtk.widgetHide canvas;
	 mode := START)

    fun reset NONE = reset' ()
      | reset (SOME (title, msg)) =
	(TextWindow.mkTextWindow (title, msg); reset' ())


    fun gameMode ({turn,
		   changeView,
		   giveUp},
		   guiGame) =
	let
	    
	    fun gameFinished h = 
		reset (SOME ("Highscore", "highscore"))

	    fun update difflist = ArenaWidget.update (arena, difflist)

	    fun updatePoints p = ()

	in
	    Gtk.widgetSetSensitive (menu_gu_item, true);
	    Gtk.widgetSetSensitive (menu_m_item, false);
	    Gtk.widgetSetSensitive (menu_hi_item, false);
	    Gtk.widgetShow canvas;
	    mode := GAME;
	    Promise.fulfill (guiGame, {update, updatePoints, gameFinished})
	end
	 

    fun mkMainWindow ({connect, startServer}, gui) = 
	let

	    val _ = assert (Future.isFuture $ Promise.future gui) 
		        do Promise.fulfill (gui, {reset})

	    fun mainQuit () = 
		case !mode of
		    START => OS.Process.exit OS.Process.success 
		  | GAME  => 
			let
			    val answer = QuestionWindow.mkQuestionBox 
				("Sure?", "Do you want to quit?")
			in
			    case answer of
			     QuestionWindow.YES    => reset NONE
			   | QuestionWindow.NO     => ()
			   | QuestionWindow.CANCEL => ()
			end

	    fun startClient () = 
		ConnectionWindow.mkConnectToServer ({connect},
						    {reset, gameMode})

	    fun startMultiPlayer () = 
		ServerSettingsWindow.mkServerSettings ({startServer},
						       {reset, gameMode})

	    fun openHighscore () = () (* TODO: implementation *)

	    fun startSinglePlayer () = 
		case startServer (SOME ("Player", Color.fromString "brown"), 
				  Config.defaultSingle) of
		    FST ({start}, _) => 
			(case start () of
			     FST (mGame, guiGame) => gameMode (mGame, guiGame)
			   | SND   errorMsg       => 
				 reset (SOME ("ERROR!!", errorMsg)))
		  | SND    errorMsg       => reset (SOME ("ERROR!!", errorMsg))
		    
	    fun turn x = Inspector.inspect x

	    fun key keyval = (* abfage ob spectator oder net *)
		if !mode = GAME
		    then
			case Gdk.keyvalName keyval of
			    "Up"      => turn Protocol.UP
			  | "Down"    => turn Protocol.DOWN
			  | "Right"   => turn Protocol.RIGHT
			  | "Left"    => turn Protocol.LEFT
			  |    _      => ()
		else ()


	    fun canvasEvent [Gtk.EVENT (event)] = 
		(case event of
		     Gtk.GDK_KEY_PRESS {keyval, ...}	=> key keyval
		   |            _                  	=> ())
	      |  canvasEvent       _            = ()
		     
			
	    val main_window     = Gtk.windowNew Gtk.WINDOW_TOPLEVEL
	    val dialog_vbox1 	= Gtk.vboxNew (false, 10)
	    val menu_m_single	= Gtk.menuItemNewWithLabel "Single-Player"
	    val menu_m_client	= Gtk.menuItemNewWithLabel "Multi-Player Client"
	    val menu_m_server	= Gtk.menuItemNewWithLabel "Multi-Player Server"
	    val menu_bar	= Gtk.menuBarNew ()
	    val menu_menu	= Gtk.menuNew ()
	    val menu_highscore	= Gtk.menuNew ()
	    val menu_quit       = Gtk.menuNew ()
	    val menu_q_item	= Gtk.menuItemNewWithLabel "Quit"
	    val menu_qu_item    = Gtk.menuItemNewWithLabel "Quit"

	in

	    Gtk.windowSetTitle (main_window, "Alice Snake");
	    Gtk.windowSetDefaultSize (main_window, 800, 500);
	    Gtk.windowSetPosition (main_window, Gtk.WIN_POS_CENTER);
	    
	    Gtk.menuAppend (menu_menu, menu_m_single);
	    Gtk.menuAppend (menu_menu, menu_m_client);
	    Gtk.menuAppend (menu_menu, menu_m_server);
	    Gtk.menuAppend (menu_quit, menu_gu_item);
	    Gtk.menuAppend (menu_quit, menu_qu_item);
	    Gtk.widgetHide canvas;

	    Gtk.signalConnect (canvas, "event",
			       canvasEvent);
	    Gtk.signalConnect (main_window, "delete-event", 
			       fn _ => mainQuit ());
	    Gtk.signalConnect (menu_hi_item, "activate", 
			       fn _ => openHighscore ());
	    Gtk.signalConnect (menu_m_single, "activate", 
			       fn _ => startSinglePlayer ());
	    Gtk.signalConnect (menu_m_client, "activate", 
			       fn _ => startClient ());
	    Gtk.signalConnect (menu_m_server, "activate", 
			       fn _ => startMultiPlayer ());
	    Gtk.signalConnect (menu_qu_item, "activate", 
			       fn _ => mainQuit ()); 

	    Gtk.menuItemSetSubmenu (menu_m_item, menu_menu);
	    Gtk.menuItemSetSubmenu (menu_q_item, menu_quit);

	    Gtk.widgetSetSensitive(menu_gu_item, false);

	    Gtk.menuBarAppend (menu_bar, menu_m_item);
	    Gtk.menuBarAppend (menu_bar, menu_hi_item);
	    Gtk.menuBarAppend (menu_bar, menu_q_item);
	    
	    Gtk.boxPackStart (dialog_vbox1, menu_bar, false, false, 0);
	    
	    Gtk.containerAdd (main_window, dialog_vbox1);
	    Gtk.widgetShowAll main_window
		
	end
end
