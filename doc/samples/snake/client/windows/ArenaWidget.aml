(* Alice Snake 2.0 - GUI
*
*  Authors: Benedikt Grundmann / Sebastian Germesin
*
*  $Revision$
*
*  Last updated: $Date$ by $Author$
* 
*
*)

import signature ARENAWIDGET   from "ARENAWIDGET-sig"
import structure Gtk           from "x-alice:/lib/gtk/Gtk"
import structure Gdk           from "x-alice:/lib/gtk/Gdk"
import structure GtkCanvas     from "x-alice:/lib/gtk/GtkCanvas"
import functor   MkRedBlackMap from "x-alice:/lib/data/MkRedBlackMap"
import structure Inspector     from "x-alice:/lib/tools/Inspector"

import structure GtkBuilder    from "../GtkBuilder"

import structure Protocol      from "../../common/Protocol"
import structure Color         from "../../common/Color"
import structure Pos           from "../../common/Pos"
import structure Arena         from "../../server/Arena"

(* Overview:

 Tournament starts:
       val arena = ArenaWidget.initialize

 Level starts:
       initLevel (arena, levelinfo)
 
 every Tick:
       update (arena, difflist)
       changeView (arena, (x, y))

 new Level starts:
       initLevel (arena, levelinfo)

...

*)


fun colorConv n = Real.round (65535.0 * n)

local

    val colormap = Gdk.colormapGetSystem ()

    structure CMap = MkRedBlackMap (Color)

    fun conv c = 
	let
	    val (r, g, b) = Color.rgb c
	    val color = Gdk.allocColor (colorConv r, colorConv g, colorConv b)
	in
	    Gdk.colormapAllocColor (colormap, color, false, true);
	    color
	end

    fun convArena (r, g, b) = 
	let
	    val color = Gdk.allocColor (colorConv r, colorConv g, colorConv b)
	in
	    Gdk.colormapAllocColor (colormap, color, false, true);
	    color
	end

    val map  = List.foldl (fn (c, map) =>
			   CMap.insertDisjoint (map, c, conv c)) CMap.empty
	Color.all
	
in
    fun color c = CMap.lookupExistent (map, c);
    val black    = convArena (0.0, 0.0, 0.0);
    val green    = convArena (0.32, 0.66, 0.17);
    val red      = convArena (1.0, 0.0, 0.0);
    val white    = convArena (1.0, 1.0, 1.0)
	
end


(* some values *)
val cellSize     = 20
val windowWidth  = 400
val windowHeight = 300

val backgroundColor = green

structure P = Protocol

structure ArenaWidget :> ARENAWIDGET =
struct

    type arena_field = Gtk.object * P.field
	
    type arena_widget = 
	{
	 canvas : Gtk.object,
	 state  : arena_field Array2.array ref
	 }

    val cellSize2     = cellSize     div 2
    val windowHeight2 = windowHeight div 2
    val windowWidth2  = windowWidth  div 2
	
    fun initialize () = 
	{
	 canvas = GtkCanvas.new 0,
	 state  = ref (Array2.array(1, 1, (Gtk.null , P.EMPTY)))
	 }
	
    fun toObject ({canvas, ... } : arena_widget) : Gtk.object  = canvas
	
    fun initLevel ({canvas, state}, {dimensions = dim} : P.level_info) =
	let
	    val (rows, cols) = dim
	    val _ = GtkCanvas.setScrollRegion (canvas, 0.0, 0.0,
					       Real.fromInt(cols * cellSize),
					       Real.fromInt(rows * cellSize))
	    val _ = Gtk.widgetSetUsize (canvas, windowWidth, windowHeight)
	    val root = GtkCanvas.root canvas
	    val _ = 
		GtkCanvas.itemNew (root, Gtk.RECTANGLE,
				   [("x1", Gtk.DOUBLE 0.0),
				    ("y1", Gtk.DOUBLE 0.0),
				    ("x2", Gtk.DOUBLE (real (cols * cellSize))),
				    ("y2", Gtk.DOUBLE (real (rows * cellSize))),
				    ("fill_color_gdk", Gtk.OBJECT green),
				    ("outline_color_gdk", Gtk.OBJECT green)])
	    val arena = Array2.array (rows, cols, (Gtk.null, P.EMPTY))
	in
	    state  := arena
	end
	

    fun insertHead (canvas, x, y, d, snakecol) =
	let
	    val (ex1,ey1,ex2,ey2) = 
		case d of
		    P.UP    => (2 * cellSize div 10,
				3 * cellSize div 10,
				5 * cellSize div 10,
				3 * cellSize div 10)
		  | P.DOWN  => (2 * cellSize div 10,
				4 * cellSize div 10,
				5 * cellSize div 10,
				4 * cellSize div 10)
		  | P.LEFT  => (3 * cellSize div 10,
				2 * cellSize div 10,
				3 * cellSize div 10,
				5 * cellSize div 10)
		  | P.RIGHT => (4 * cellSize div 10,
				2 * cellSize div 10,
				4 * cellSize div 10,
				5 * cellSize div 10)
		    
	    val tonglist = 
		case d of
		    P.UP    => [(4 * cellSize div 10),
				(1 * cellSize div 10),
				(4 * cellSize div 10),
			       (~3 * cellSize div 10)]
		  | P.DOWN  => [(4 * cellSize div 10),
				(8 * cellSize div 10),
				(4 * cellSize div 10),
			       (11 * cellSize div 10)]
		  | P.LEFT  => [(1 * cellSize div 10),
				(4 * cellSize div 10),
			       (~3 * cellSize div 10),
			        (4 * cellSize div 10)]
		  | P.RIGHT => [(8 * cellSize div 10),
				(4 * cellSize div 10),
			       (11 * cellSize div 10),
				(4 * cellSize div 10)]

	    val head = 
		GtkCanvas.itemNew (canvas, GtkCanvas.GROUP,
				   [("x", Gtk.DOUBLE (real x)),
				    ("y", Gtk.DOUBLE (real y))])

	    val ground = 
		GtkCanvas.itemNew (head, GtkCanvas.ELLIPSE,
				   [("x1", Gtk.DOUBLE 0.0),
				    ("y1", Gtk.DOUBLE 0.0),
				    ("x2", Gtk.DOUBLE (real cellSize)),
				    ("y2", Gtk.DOUBLE (real cellSize)),
				    ("fill_color_gdk", Gtk.OBJECT snakecol)])

	    val tongue = 
		GtkCanvas.itemNew (head, 
				   GtkCanvas.LINE,
				   [("points", Gtk.POINTS tonglist),
				    ("fill_color_gdk", Gtk.OBJECT red),
				    ("width_pixels", Gtk.INT (cellSize div 10))])

	    val leftEye = 
		GtkCanvas.itemNew (head,
				   GtkCanvas.RECTANGLE,
				   [("x1", Gtk.DOUBLE (real ex1)),
				    ("y1", Gtk.DOUBLE (real ey1)),
				    ("x2", Gtk.DOUBLE (real (ex1 + 1))),
				    ("y2", Gtk.DOUBLE (real (ey1 + 1))),
				    ("fill_color_gdk", Gtk.OBJECT black)])
		
	    val rightEye = 
		GtkCanvas.itemNew (head,
				   GtkCanvas.RECTANGLE,
				   [("x1", Gtk.DOUBLE (real ex2)),
				    ("y1", Gtk.DOUBLE (real ey2)),
				    ("x2", Gtk.DOUBLE (real (ex2 + 1))),
				    ("y2", Gtk.DOUBLE (real (ey2 + 1))),
				    ("fill_color_gdk", Gtk.OBJECT black)])
	in
	    head
	end
	    
    fun insertBody (canvas, x, y, snakecol) =
	let
	    val body = 
		GtkCanvas.itemNew (canvas, GtkCanvas.GROUP,
				   [("x",Gtk.DOUBLE (real x)),
				    ("y",Gtk.DOUBLE (real y))])

	    val ground = 
		GtkCanvas.itemNew (body, GtkCanvas.ELLIPSE,
				   [("x1", Gtk.DOUBLE 0.0),
				    ("y1", Gtk.DOUBLE 0.0),
				    ("x2", Gtk.DOUBLE (real cellSize)),
				    ("y2", Gtk.DOUBLE (real cellSize)),
				    ("fill_color_gdk", Gtk.OBJECT snakecol)])
		
	in
	    body
	end

    fun insertOpenGate (canvas, x, y, gatecol) = 
	let
	    val gate = 
		GtkCanvas.itemNew (canvas, GtkCanvas.GROUP,
				   [("x",Gtk.DOUBLE (real x)),
				    ("y",Gtk.DOUBLE (real y))])
		
	    val ground = 
		GtkCanvas.itemNew (gate, GtkCanvas.RECTANGLE,
				   [("x1", Gtk.DOUBLE 0.0),
				    ("y1", Gtk.DOUBLE 0.0),
				    ("x2", Gtk.DOUBLE (real cellSize)),
				    ("y2", Gtk.DOUBLE (real cellSize)),
				    ("fill_color_gdk", Gtk.OBJECT gatecol),
				    ("outline_color_gdk", Gtk.OBJECT black)])
	in
	    gate
	end

    fun insertClosedGate (canvas, x, y, gatecol) = 
	let
	    val gate = 
		GtkCanvas.itemNew (canvas, GtkCanvas.GROUP,
				   [("x",Gtk.DOUBLE (real x)),
				    ("y",Gtk.DOUBLE (real y))])
		
	    val ground = 
		GtkCanvas.itemNew (gate, GtkCanvas.RECTANGLE,
				   [("x1", Gtk.DOUBLE 0.0),
				    ("y1", Gtk.DOUBLE 0.0),
				    ("x2", Gtk.DOUBLE (real cellSize)),
				    ("y2", Gtk.DOUBLE (real cellSize)),
				    ("fill_color_gdk", Gtk.OBJECT gatecol),
				    ("outline_color_gdk", Gtk.OBJECT black)])

	    val cross = 
		GtkCanvas.itemNew (gate, GtkCanvas.LINE,
				   [("points",Gdk.POINTS [1,20,400]),
				    ("fill_color_gdk",Gtk.OBJECT black),
				    ("width_pixels",Gtk.INT 2)])
	in
	    gate
	end

    fun insertWall (canvas, x, y) = 
	let
	    val wall = 
		GtkCanvas.itemNew (canvas, GtkCanvas.GROUP,
				   [("x",Gtk.DOUBLE (real x)),
				    ("y",Gtk.DOUBLE (real y))])
		
	    val ground = 
		GtkCanvas.itemNew (wall, GtkCanvas.RECTANGLE,
				   [("x1", Gtk.DOUBLE 0.0),
				    ("y1", Gtk.DOUBLE 0.0),
				    ("x2", Gtk.DOUBLE (real cellSize)),
				    ("y2", Gtk.DOUBLE (real cellSize)),
				    ("fill_color_gdk", Gtk.OBJECT red),
				    ("outline_color_gdk", Gtk.OBJECT black)])
		
	in
	    wall
	end

    fun insertGoodie (canvas, x, y, n) =
	(* where n is the amount of a goodie *)
	let
	    val goodie = 
		GtkCanvas.itemNew (canvas, GtkCanvas.GROUP,
				   [("x",Gtk.DOUBLE (real x)),
				    ("y",Gtk.DOUBLE (real y))])
		
	    val ground = 
		GtkCanvas.itemNew (goodie, GtkCanvas.ELLIPSE,
				   [("x1", Gtk.DOUBLE 0.0),
				    ("y1", Gtk.DOUBLE 0.0),
				    ("x2", Gtk.DOUBLE (real cellSize)),
				    ("y2", Gtk.DOUBLE (real cellSize)),
				    ("fill_color_gdk", Gtk.OBJECT red),
				    ("outline_color_gdk", Gtk.OBJECT black)])
		
	in
	    goodie
	end


    fun update ({canvas, state = ref arena}, difflist) =
	let
            val can = GtkCanvas.root canvas

            fun changeField (oldObj:Gtk.object, r, c, field) =
                let
                    val x = cellSize * c
                    val y = cellSize * r
                in
                    (* destroy old object if existing *)
                    if oldObj <> Gtk.null 
			then Gtk.objectDestroy oldObj
                    else ();
                    (* place the new one *)
                    case field of
		        P.EMPTY     => 
                            Array2.update (arena, r, c, (Gtk.null, field))
                    |   P.WALL      => Array2.update (arena, r, c, 
                                        (insertWall (can, x, y), field))
                    | P.GOODY n    => Array2.update (arena, r, c, 
                                        (insertGoodie (can, x, y, n), field))
                    | P.GATE (col,P.CLOSED) => Array2.update (arena, r, c, 
                                        (insertClosedGate (can, x, y, 
							   color col), 
					 field))
                    | P.GATE (col,P.OPEN) => Array2.update (arena, r, c, 
                                        (insertOpenGate (can, x, y, 
							 color col), 
					 field))
                    | P.SNAKE_HEAD (d, col) => 
                        Array2.update (arena, r, c, 
                            (insertHead (can, x, y, d, color col), field))
                    | P.SNAKE_BODY col      => 
                        Array2.update (arena, r, c, 
                            (insertBody (can, x, y, color col), field))
                end

	    fun insert ((r, c), field) = 
		let
                    val (rows, cols)    = Array2.dimensions arena
                    val _   = assert 0 <= r andalso r < rows andalso
                                0 <= c andalso c < cols
		    val (obj, f) = Array2.sub(arena, r, c)
		in 
		    if f = field  (* shouldn't happen normally *)
			then () 
		    else 
                        changeField (obj, r, c, field)
		end
	in
	    List.app insert difflist
	end 
	
    fun clamp (low, upp) v =
	if v < low then low
	else if v > upp then upp
	     else v

    fun arenaWidth (a:arena_widget) =
	let
	    val (_, cols) = Array2.dimensions (! ( #state a))
	in
	    cols * cellSize
	end


    fun arenaHeight (a:arena_widget) =
	let
	    val (rows, _) = Array2.dimensions (! ( #state a))
	in
	    rows * cellSize
	end


    fun changeView (a, (x, y)) =
	let
	    val minX = 0
	    val maxX = arenaWidth a - windowWidth2
	    val minY = 0
	    val maxY = arenaHeight a - windowHeight2
	    val x    = x * cellSize - windowWidth2
	    val y    = y * cellSize - windowHeight2
	in 
	    GtkCanvas.scrollTo(toObject a,
			       clamp (minX, maxX) x, 
			       clamp (minY, maxY) y);
	    GtkCanvas.updateNow (toObject a)
	end

end

fun testfield () =
    let

	val testfield = Array2.array(30,30,P.EMPTY)
    in
	Array2.update(testfield,2,3,
		      P.SNAKE_HEAD(P.UP,Color.fromString"turquoise"));
	Array2.update(testfield,2,5,
		      P.SNAKE_HEAD(P.DOWN,Color.fromString"blue"));
	Array2.update(testfield,2,7,
		      P.SNAKE_HEAD(P.LEFT,Color.fromString"yellow"));
	Array2.update(testfield,4,2,
		      P.SNAKE_HEAD(P.RIGHT,Color.fromString"violet"));
	Array2.update(testfield,4,4,
		      P.SNAKE_BODY(Color.fromString"silver"));
	Array2.update(testfield,4,6,
		      P.WALL);
        Array2.update(testfield,4,5, P.WALL);
	Array2.update(testfield,4,8,
		      P.GATE(Color.fromString "brown", P.CLOSED));
	testfield
    end

val testfield = testfield ()

fun test () = 
    let
	structure A = ArenaWidget
	val testarena = A.initialize ()
	val _ = ArenaWidget.initLevel (testarena, {dimensions = (30,30)})
	val canvas = ArenaWidget.toObject testarena
	fun deleteHandler _ = OS.Process.exit OS.Process.success
	val widget = 
	    GtkBuilder.Toplevel {title = "Snake ArenaWidget Test",
				 border = 0,
				 handler = [GtkBuilder.Handler("delete-event",
							       deleteHandler)],
				 inner = GtkBuilder.Window canvas}
    in
	GtkBuilder.MakeWidget widget;
	ArenaWidget.update (testarena, Arena.diff(Array2.array(30,30,P.EMPTY),
						  testfield));
	ArenaWidget.changeView (testarena,(5,5))
    end

val _ = test ()

