(*
 * Authors:
 *   Guido Tack <tack@ps.uni-sb.de>
 *
 * Copyright:
 *   Guido Tack, 2005
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Gtk from "x-alice:/lib/gtk/Gtk"
import structure Gdk from "x-alice:/lib/gtk/Gdk"
import structure PangoEnums from "x-alice:/lib/gtk/PangoEnums"
import structure FileDialog from "FileDialog"

signature USER_CONFIG =
   sig
      val reservedColor : (int * int * int)
      val errorColor : (int * int * int)
      val stringColor : (int * int * int)
      val plainColor : (int * int * int)
      val commentColor : (int * int * int)
      val historySize : int
      val stdFontName : string
   end

structure Config =
   struct

      fun createConfigDir () =
	  let
	      val dir = OS.FileSys.getApplicationConfigDir "Toplevel"
	      val parent = OS.Path.getParent dir
	  in
	      OS.FileSys.mkDir parent handle OS.SysErr _ => ();
	      OS.FileSys.mkDir dir handle OS.SysErr _ => ()
	  end

      val editorHeight = 500

      val sizeX = 750
      val sizeY = 800

      val historySize = ref 100
      val useTabs = ref true

      val cmap   = Gdk.colormapGetSystem ()
      val ugly = Gdk.colorNew(0xf0f0, 0x2020, 0xa0a0)
      val black = Gdk.colorNew(0, 0, 0)
      val red = Gdk.colorNew(0xffff, 0, 0)
      val orange = Gdk.colorNew(0xffff, 0x8000, 0)
      val blue = Gdk.colorNew(0, 0, 0xe000)
      val green = Gdk.colorNew(0, 0x8000, 0)
      val white = Gdk.colorNew(0xffff, 0xffff, 0xffff)

      val reservedColor = ref blue
      val errorColor = ref red
      val stringColor = ref orange
      val plainColor = ref black
      val commentColor = ref green

      val _ = Gdk.colormapAllocColor(cmap, black, false, true)
      val _ = Gdk.colormapAllocColor(cmap, white, false, true)
      val _ = Gdk.colormapAllocColor(cmap, ugly, false, true)
      val _ = Gdk.colormapAllocColor(cmap, red, false, true)
      val _ = Gdk.colormapAllocColor(cmap, orange, false, true)
      val _ = Gdk.colormapAllocColor(cmap, green, false, true)
      val _ = Gdk.colormapAllocColor(cmap, blue, false, true)

      val stdFontName = ref "Courier 11"
      val stdFont = ref (Gtk.pangoFontDescriptionFromString (!stdFontName))

      type tags = {err : Gtk.object,
                   log : Gtk.object,
                   plain : Gtk.object,
                   comment : Gtk.object,
                   string : Gtk.object,
                   reserved : Gtk.object,
		   bold : Gtk.object,
                   noedit : Gtk.object}

      fun makeTags buf =
          let
              val err = Gtk.textBufferCreateTag(buf, "error", "foreground-gdk", Gtk.OBJECT (!errorColor))
              val log = Gtk.textBufferCreateTag(buf, "log", "style", Gtk.INT (PangoEnums.PangoStyleToInt PangoEnums.STYLE_NORMAL))
              val plain = Gtk.textBufferCreateTag(buf, "plain", "foreground-gdk", Gtk.OBJECT (!plainColor))

              val comment = Gtk.textBufferCreateTag(buf, "comment", "foreground-gdk", Gtk.OBJECT (!commentColor))
              val string = Gtk.textBufferCreateTag(buf, "string", "foreground-gdk", Gtk.OBJECT (!stringColor))
              val reserved = Gtk.textBufferCreateTag(buf, "reserved", "foreground-gdk", Gtk.OBJECT (!reservedColor))

              val noedit = Gtk.textBufferCreateTag(buf, "noedit", "editable", Gtk.BOOL false)
              val bold = Gtk.textBufferCreateTag(buf, "bold", "weight", Gtk.INT (PangoEnums.PangoWeightToInt PangoEnums.WEIGHT_BOLD))
          in
              {err, log, plain, comment, string, reserved, bold, noedit} : tags
          end

      fun changeColor (tag, color) =
	  Gtk.objectSetObject(tag, "foreground-gdk", color)


      fun getRgbColor color =
	  (Gdk.colorGetFieldRed color,
	   Gdk.colorGetFieldGreen color,
	   Gdk.colorGetFieldBlue color)

      fun mkRgbColor (r,g,b) =
	  let val c = Gdk.colorNew(r,g,b)
	  in
	      Gdk.colormapAllocColor(cmap, c, false, true);
	      c
	  end

      fun changeColors buf =
	  let
	      val tt = Gtk.textBufferGetTagTable buf
	      val plain = Gtk.textTagTableLookup(tt, "plain")
	      val error = Gtk.textTagTableLookup(tt, "error")
	      val string = Gtk.textTagTableLookup(tt, "string")
	      val reserved = Gtk.textTagTableLookup(tt, "reserved")
	      val comment = Gtk.textTagTableLookup(tt, "comment")
	  in
	      changeColor(plain, !plainColor);
	      changeColor(error, !errorColor);
	      changeColor(string, !stringColor);
	      changeColor(reserved, !reservedColor);
	      changeColor(comment, !commentColor)
	  end

      val configDir = OS.FileSys.getApplicationConfigDir "Toplevel"
      val preferencesFile = configDir ^ "/preferences." ^ Pickle.extension
      val historyFile = configDir ^ "/history." ^ Pickle.extension

      val workDir = ref (OS.FileSys.getDir ())

      fun init() =
	  let
	      structure C = unpack (Pickle.load preferencesFile) : USER_CONFIG
	  in
	      stdFontName := C.stdFontName;
	      stdFont := Gtk.pangoFontDescriptionFromString (!stdFontName);

	      plainColor := mkRgbColor C.plainColor;
	      errorColor := mkRgbColor C.errorColor;
	      stringColor := mkRgbColor C.stringColor;
	      reservedColor := mkRgbColor C.reservedColor;
	      commentColor := mkRgbColor C.commentColor;

	      historySize := C.historySize
	  end handle (OS.SysErr _ | IO.Io _ | Package.Mismatch _) => ()

      fun save() =
	  let
	      structure C = 
	      struct
		  val reservedColor = getRgbColor (!reservedColor)
		  val errorColor = getRgbColor (!errorColor)
		  val stringColor = getRgbColor (!stringColor)
		  val plainColor = getRgbColor (!plainColor)
		  val commentColor = getRgbColor (!commentColor)
		  val historySize = !historySize
		  val stdFontName = !stdFontName
	      end
	  in
	      createConfigDir ();
	      Pickle.save(preferencesFile, pack C : USER_CONFIG)
	  end handle (OS.SysErr _ | IO.Io _) =>
	      FileDialog.message "Could not save preferences."

     (* History management *)
      fun loadHistory() =
	  let
	      structure C = unpack Pickle.load historyFile
	      			 : (val history : string list)
	  in
	      C.history
	  end handle (IO.Io _ | OS.SysErr _ | Package.Mismatch _) => []

      fun saveHistory (history, openFiles) =
	  let
	      structure C =
	      struct
		  val history = List.take(history, !historySize)
				handle Subscript => history
		  val openFiles = openFiles
		  val workDir = !workDir
	      end
	  in
	      createConfigDir ();
	      Pickle.save(historyFile,
			  pack C : (val history : string list
				    val openFiles : string list
				    val workDir : string))
	  end handle (OS.SysErr _ | IO.Io _) =>
	      FileDialog.message "Could not save history."

     (* Restore open files *)
      fun loadOpenFiles() =
	  let
	      val p = Pickle.load historyFile
	      structure O = unpack p : (val openFiles : string list)
	  in
	      (* unpack seperately, for backward compatibility *)
	      workDir :=
	      (let
		 structure D = unpack p : (val workDir : string)
	      in
		 D.workDir
	      end handle Package.Mismatch _ => OS.FileSys.getHomeDir ());
	      O.openFiles
	  end handle (IO.Io _ | OS.SysErr _ | Package.Mismatch _) => nil
		| e => (TextIO.output(TextIO.stdErr,
				    "** error loading history: uncaught \
				    \exception " ^ Exn.name e ^ "\n"); nil)
   end
