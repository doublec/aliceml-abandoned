(*
 * Authors:
 *   Guido Tack <tack@ps.uni-sb.de>
 *
 * Copyright:
 *   Guido Tack, 2005
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Stream from "x-alice:/lib/data/Stream"
import structure Gui from "Gui"
import structure Gtk from "x-alice:/lib/gtk/Gtk"
import structure Gdk from "x-alice:/lib/gtk/Gdk"
import structure OutputWriters from "OutputWriters"
import structure Evaluator from "Evaluator"
import structure Buffer from "Buffer"
import structure Config from "Config"
import structure History from "History"
import structure FileDialog from "FileDialog"
import structure SearchDialog from "SearchDialog"
import structure BufferHighlight from "BufferHighlight"
import structure Preferences from "Preferences"

structure GuiMain =
    struct
        (* Buffers *)

        val clipboard = Gtk.clipboardGet(Gdk.atomIntern("PRIMARY", false))
        datatype active_view = COMPILER | STDSTREAMS | BUFFER of Gtk.object
        val curtextview = ref COMPILER

        val numberOfPages = ref 0
        val currentPage = ref ~1

        val pages = ref nil
        fun removePage i =
            let
                val (pre,post) = List.split(!pages, i+1)
                val (pre,p) = case List.split(pre,i) of
                                  (pre, [p]) => (pre,p)
                                | _ => raise Match
                                             (* to make compiler happy *)
            in
                (pages := (List.take(pre,i)@post));
                p
            end
        fun addPage p = pages := (!pages)@[p]
        fun getPage i = List.nth (!pages, i)
        fun getCurrentPage () =
            case !currentPage of ~1 => NONE
                               | i => SOME (getPage i)
	fun findPage id = Option.map #1 (List.findi (fn (_,i) => i=id) (!pages))
            
        fun undo() =
            case getCurrentPage() of NONE => ()
                                   | SOME id => Buffer.undo id

        fun getCurViewBuf () =
            let
                val view = case (!curtextview) of
                               BUFFER view => view
                             | COMPILER => Gui.compilerout
                             | STDSTREAMS => Gui.progout
            in
                (view, Gtk.textViewGetBuffer view)
            end

        fun getCurBuf () = #2 (getCurViewBuf ())

        fun copy() = Gtk.textBufferCopyClipboard(getCurBuf(), clipboard)

        fun paste() =
            let
		val txt = Gtk.clipboardWaitForText clipboard
		val (view, buf) = getCurViewBuf()
	    in
		Gtk.textBufferBeginUserAction buf;
		Gtk.textBufferDeleteSelection(buf, true, true);
		Gtk.textBufferInsertInteractiveAtCursor(buf,txt,~1,true);
		Gtk.textBufferEndUserAction buf;
		Gtk.textViewScrollToMark(view, Gtk.textBufferGetInsert buf,
					 0.0, false, 0.0, 0.0);
		()
	    end

        fun cut() =
            Gtk.textBufferCutClipboard(getCurBuf(), clipboard, true)

        fun delete() =
            ignore (Gtk.textBufferDeleteSelection(getCurBuf(), true, true))

        fun syntax() =
            case (!curtextview) of BUFFER view =>
                BufferHighlight.highlightAll(Gtk.textViewGetBuffer view, ref false)
              | _ => ()

        fun search() =
            case getCurrentPage() of NONE => ()
                                   | SOME id => SearchDialog.search id

	fun searchAgain arg =
            case getCurrentPage() of NONE => ()
                                   | SOME id => SearchDialog.searchAgain(id, arg)

        fun replaceSearch() =
            case getCurrentPage() of NONE => ()
                                   | SOME id => SearchDialog.replace id

	fun gotoLine() =
            case getCurrentPage() of NONE => ()
                                   | SOME id => SearchDialog.gotoLine id

	fun bufferMenus activate =
	    (app (fn w => Gtk.widgetSetSensitive(w,activate))
	     [Gui.save1,Gui.save_as1,Gui.go_to_line,
	      Gui.undo,Gui.find,Gui.replace,Gui.find_again,
	      Gui.feedfile,Gui.syntax_colouring,
	      Gui.compilefile,Gui.indent_region, Gui.outdent_region];
	     app (fn w => Gtk.widgetSetSensitive(w,not activate))
	     [Gui.back_in_history,Gui.forward_in_history])

        fun changeFocus view _ =
	    let
		val _ = curtextview := view
		val _ = case getCurrentPage() of
		    NONE =>
			Gtk.widgetSetSensitive(Gui.compilefile,false)
		  | SOME id =>
			(Option.app (fn _ => Gtk.widgetSetSensitive(Gui.compilefile,true))
			 (Buffer.getFileName id);
			 Gtk.checkMenuItemSetActive(Gui.syntax_colouring,
					     Buffer.getSyntaxHighlighting id))
		val _ = case view of
		    BUFFER _ => (bufferMenus true;
				 Gtk.widgetSetSensitive(Gui.feedregion,true))
		  | COMPILER => (bufferMenus false;
				 Gtk.widgetSetSensitive(Gui.feedregion,true))
		  | STDSTREAMS => (bufferMenus false;
				   Gtk.widgetSetSensitive(Gui.feedregion,false))
		val _ = if !currentPage > 0 then
		            Gtk.widgetSetSensitive(Gui.previous_file, true)
			else
			    Gtk.widgetSetSensitive(Gui.previous_file, false)
		val _ = if !currentPage <> ~1 andalso
		            !currentPage < List.length (!pages) - 1 then
		            Gtk.widgetSetSensitive(Gui.next_file, true)
			else
			    Gtk.widgetSetSensitive(Gui.next_file, false)
	    in ()
	    end

        fun markSet (buf,_) =
            let
                val cursor = Gtk.textBufferGetInsert buf
		val (line, col) = Lock.sync Gtk.lock
		    (fn () =>
		     let
			 val iter = Gtk.textIterNew()
			 val _ = Gtk.textBufferGetIterAtMark(buf,iter,cursor)
		     in
			 (Buffer.getLine iter, Buffer.getColumn iter)
		     end) ()
            in
                Stream.send(OutputWriters.rowCol, (line, col))
            end

	val notebookSwitchEventIdP = Promise.promise()
	val notebookSwitchEventId = Promise.future notebookSwitchEventIdP
        fun switchPage notebook =
            let
                val curPage = Gtk.notebookGetCurrentPage notebook
                val scrWin = Gtk.notebookGetNthPage(notebook, curPage)
                val textView = Gtk.binGetChild scrWin
            in
		currentPage := curPage;
		case !curtextview of
		    BUFFER _ => (curtextview := BUFFER textView;
				 Option.app SearchDialog.reconnect (getCurrentPage()))
		  | _ => ()                
            end

        fun checkNotebookSize() =
            let
		 val rq1 = Gdk.rectangleNew(0,0,0,0)
		 val _ = Gtk.textViewGetVisibleRect(Gui.compilerout,rq1)
		 val rq2 = Gdk.rectangleNew(0,0,0,0)
		 val _ = Gtk.textViewGetVisibleRect(Gui.progout,rq2)

		 val buf = Gtk.textViewGetBuffer Gui.compilerout
		 val progBuf = Gtk.textViewGetBuffer Gui.progout

		 (* Hack alert: The scrollbar between the two panes *)
		 (* seems to be about 18 pixels high...*)
		 val h1 = Gdk.rectangleGetFieldHeight rq1 + 18
		 val h2 = Gdk.rectangleGetFieldHeight rq2
		 val ratio = Real.fromInt h1 / Real.fromInt (h1+h2)
	     in
		 if Gtk.notebookGetNPages Gui.notebook1 > 0
		     then (if Gtk.panedGetPosition Gui.vpaned1 = 1 then
			   let
			       val newPos = Real.fromInt (h1+h2-Config.editorHeight) * ratio
			   in
			       Gtk.panedSetPosition(Gui.vpaned2,Real.round newPos);
			       Gtk.panedSetPosition(Gui.vpaned1,Config.editorHeight)
			   end
			   else ();
			   Gtk.widgetSetSensitive(Gui.switch_to_editor, true))
		 else
		     let
			 val editorHeight = Gtk.panedGetPosition Gui.vpaned1
			 val newHeight = editorHeight+h1+h2
			 val newPos = Real.fromInt newHeight * ratio
		     in
			 Gtk.panedSetPosition(Gui.vpaned1,1);
			 Gtk.panedSetPosition(Gui.vpaned2,Real.round newPos);
			 Gtk.widgetGrabFocus Gui.compilerout;
			 Gtk.widgetSetSensitive(Gui.switch_to_editor, false)
		     end;
		 (* Hack alert: scroll to end mark seems to have no effect if
		  * performed immediately... so wait for a moment... *)
		 spawn (
		     await(Future.alarm(Time.fromMilliseconds(Int.toLarge 300)));
		     Gtk.textViewScrollToMark(Gui.compilerout,
					      Gtk.textBufferGetInsert buf,
					      0.0, false, 0.0, 0.0);
		     Gtk.textViewScrollToMark(Gui.progout,
					      Gtk.textBufferGetInsert progBuf,
					      0.0, false, 0.0, 0.0)
		 );
		 ()
	     end

        fun new' file =
            let
		val _ = Gtk.signalHandlerBlock(Gui.notebook1,
						notebookSwitchEventId)
                val {buf,view,...} = Buffer.buffer {notebook=Gui.notebook1,
                                                    id=(!numberOfPages),
                                                    file=file,
                                                    loadFile=false}
            in
                Gtk.widgetGrabFocus (view);
                Gtk.signalConnect(buf, "mark-set", markSet);
                Gtk.signalConnect(view, "focus-in-event", changeFocus (BUFFER view));
                markSet (buf, nil);
                addPage(!numberOfPages);
                numberOfPages := (!numberOfPages) + 1;
		switchPage Gui.notebook1;
		Gtk.signalHandlerUnblock(Gui.notebook1,
					  notebookSwitchEventId);
                changeFocus (BUFFER view) ();
                checkNotebookSize()
            end
        fun new() = new' NONE

        fun openGivenFile f =
	    let
	        val (buf,id) = Buffer.getBufferByName
		(OS.Path.mkAbsolute {path=f,relativeTo=OS.FileSys.getDir()})
	    in
		case buf of
		    SOME buf =>
		    Gtk.notebookSetCurrentPage(Gui.notebook1, valOf (findPage id))
		  | NONE =>
                let
		    val _ = Gtk.signalHandlerBlock(Gui.notebook1,
						    notebookSwitchEventId)
                    val {buf,view,highlight,...} =
                        Buffer.buffer {notebook=Gui.notebook1, loadFile=true,
                                       id=(!numberOfPages), file=SOME f}
                in
                    Gtk.signalConnect(buf, "mark-set", markSet);
                    Gtk.signalConnect(view, "focus-in-event", changeFocus (BUFFER view));
                    Gtk.widgetGrabFocus (view);
                    markSet (buf, nil);
                    addPage(!numberOfPages);
                    numberOfPages := (!numberOfPages) + 1;
		    switchPage Gui.notebook1;
		    Gtk.signalHandlerUnblock(Gui.notebook1,
					      notebookSwitchEventId);
		    Promise.fulfill(!highlight, SOME 0);
                    checkNotebookSize()
                end
	    end

	fun openFile () =
	    let
		val file =
		    case getCurrentPage() of
			NONE => ""
		      | SOME id =>
			    OS.Path.getParent
			    (Option.getOpt(Buffer.getFileName id,""))^"/"
	    in
		case FileDialog.openFile("Open file", file) of
		    NONE => ()
		  | SOME f => openGivenFile f
	    end
       

	fun saveGivenFileAs id =
	    let
		val file =
		    Option.getOpt(Buffer.getFileName id,"")
	    in
		case FileDialog.openFile("Save file",file) of
		    NONE => ()
		  | SOME f => Buffer.saveAs (id, f)
	    end
        fun saveFileAs () =
            case getCurrentPage() of NONE => ()
                                   | SOME id => saveGivenFileAs id

        fun saveFile () =
            case getCurrentPage() of NONE => ()
                                   | SOME id =>
                                     if Buffer.save id then ()
                                     else saveFileAs()

        (* Evaluation *)

        val evalSignal = ref NONE

        fun eval (echo,withDir) "" = ()
	  | eval (echo,withDir) text =
            (* FIXME: race condition, use promises and Ref.exchange! *)
	    case (!evalSignal) of NONE =>
	    let
                val signalP = Promise.promise()
		val signal = Promise.future signalP
		val text = if String.sub (text, String.size text - 1) = #"\n"
			   then text else text ^ "\n"
                fun find(i ,str) =
                    if i=String.size str then "\n"
                    else if Char.isSpace (String.sub(str,i)) then
                        find(i+1, str)
                    else String.extract(str, i, NONE)
		val dir = OS.FileSys.getDir()
		val srcDir = if not withDir then NONE else
			     case getCurrentPage()
			       of NONE => NONE
			        | SOME id =>
			     case !(#file(Buffer.Map.lookupExistent(Buffer.bufferMap, id)))
			       of NONE => NONE
				| SOME p => SOME(OS.Path.getParent p)
					    handle OS.Path.Path => NONE
	    in
                evalSignal := SOME signalP;
		if echo then TextIO.StreamIO.output (OutputWriters.compilerIn, find(0,text))
                else ();
		spawn (Option.app OS.FileSys.chDir srcDir;
		       Evaluator.eval (text, signal);
                       (* Hack: this fails when the feeded code cd'ed to
		        * its own directory... *)
		       Option.app (fn dir' => if dir' <> OS.FileSys.getDir() then ()
					      else OS.FileSys.chDir dir) srcDir;
		       evalSignal := NONE)
	    end
                                | SOME _ =>
                                  FileDialog.message "Still evaluating."

        fun feedFile() =
            (* FIXME: race condition, use promises and Ref.exchange! *)
            case (!evalSignal) of
	        SOME _ => FileDialog.message "Still evaluating."
	      | NONE =>
            case getCurrentPage() of NONE => ()
                                   | SOME id =>
            let
                val _ = saveFile ()
		val file = Buffer.getFileName id
            in
                case file of
                    NONE => ()
                  | SOME f =>
		    let
                	val signalP = Promise.promise()
			val signal = Promise.future signalP
			val dir = OS.FileSys.getDir()
			val srcDir' = OS.Path.getParent f
				      handle OS.Path.Path => dir
			val srcDir = if srcDir' = dir then NONE else SOME srcDir'
		    in
                	evalSignal := SOME signalP;
			spawn (Option.app OS.FileSys.chDir srcDir;
			       Evaluator.evalFile (f, signal);
                	       (* Hack: this fails when the feeded code cd'ed to
		        	* its own directory... *)
			       Option.app (fn dir' => if dir' <> OS.FileSys.getDir() then ()
						      else OS.FileSys.chDir dir) srcDir;
			       evalSignal := NONE)
		    end
            end
(*
            case (!curtextview) of BUFFER view =>
            let
                val buf = Gtk.textViewGetBuffer view
		val str = Lock.sync Gtk.lock
		    (fn () => let
		     val startiter = Gtk.textIterNew()
		     val _ = Gtk.textBufferGetStartIter(buf,startiter)
		     val enditer = Gtk.textIterNew()
		     val _ = Gtk.textBufferGetEndIter(buf,enditer)
		     in Gtk.textBufferGetText(buf, startiter, enditer, false)
		     end) ()
                val str = Gtk.utf8ToLatin1 str
            in
                eval (true,true) str
            end
                                 | _ => ()
*)
        fun addSpace(line, col, str) =
            String.tabulate(line-1, fn _ => #"\n") ^
	    String.tabulate(col, fn _ => #" ") ^ str

        fun feedSelection() =
            case (!curtextview) of BUFFER view =>
            let
                val buf = Gtk.textViewGetBuffer view

		val (sel, txt, line, col) =
		    Lock.sync Gtk.lock
		    (fn () =>
		     let
		     val startiter = Gtk.textIterNew()
		     val enditer = Gtk.textIterNew()
		     in
			 (Gtk.textBufferGetSelectionBounds(buf,
                                                           startiter,enditer),
			  Gtk.textBufferGetText(buf, startiter, enditer, false),
			  Buffer.getLine startiter,
			  Buffer.getColumn startiter)
		     end) ()
            in
                if sel
                then eval (true,true) (addSpace(line, col, Gtk.utf8ToLatin1 txt))
                else ()
            end
           | _ => ()

        fun feedLine() =
            case (!curtextview) of BUFFER view =>
            let
                val buf = Gtk.textViewGetBuffer view
		    
		val (startline, str) = Lock.sync Gtk.lock
		    (fn () =>
		     let
			 val startiter = Buffer.getCursorIter buf
			 val enditer = Gtk.textIterCopy(startiter)
		     in
			 Gtk.textIterSetLineOffset(startiter, 0);
			 Gtk.textIterForwardToLineEnd(enditer);
			 (Buffer.getLine startiter,
			  Gtk.textBufferGetText(buf,
						startiter, enditer, false))
		     end) ()
                val str = addSpace(startline, 0, Gtk.utf8ToLatin1 str)
            in
                eval (true, true) str
            end
                                 | _ => ()

        fun findNextEOL iter next =
            if next iter then
                let
                    val c = chr (Gtk.textIterGetChar iter)
                in
                    if c = #"\n" then ()
                    else if Char.isSpace c then findNextEOL iter next
                    else findEOP iter next
                end
            else ()
        and findEOP iter next =
            let
                val c = Gtk.textIterGetChar iter
            in
                if c=0 then ()
                else
                    if c=ord #"\n" then
                        findNextEOL iter next
                    else if next iter then
                        findEOP iter next
                    else ()
            end

        fun findNonWS iter next =
            let
                val c = Gtk.textIterGetChar iter
            in
                if c=0 then ()
                else if Char.isSpace (chr c) then
                    (next iter; findNonWS iter next)
                else ()
            end

        fun eolBeforeNonWS acc iter next =
            let
                val c = Gtk.textIterGetChar iter
            in
                if c=0 then acc
                else if Char.isSpace (chr c) then
                    (next iter;
                     eolBeforeNonWS (acc + (if c = ord #"\n" then 1 else 0)) iter next)
                else acc
            end

        fun paragraphIters(buf) =
            let
                val startiter = Buffer.getCursorIter buf
                val c = Gtk.textIterGetChar startiter
                val _ = if c = ord #"\n" orelse c=0 then
                            Gtk.textIterBackwardChar startiter else false
                val enditer = Gtk.textIterCopy(startiter)
                val _ = findEOP startiter Gtk.textIterBackwardChar
                val _ = findEOP enditer Gtk.textIterForwardChar
                val _ = findNonWS startiter Gtk.textIterForwardChar
                val _ = findNonWS enditer Gtk.textIterBackwardChar
                val _ = Gtk.textIterForwardChar enditer (* end is exclusive! *)
		val _ = Gtk.textIterSetLineOffset(startiter, 0)
            in
                (startiter, enditer)
            end

        fun feedRegion() =
            case (!curtextview) of BUFFER view =>
            let
                val buf = Gtk.textViewGetBuffer view

		val (str, line, col) = Lock.sync Gtk.lock
		    (fn () =>
		     let
		     val startiter = Gtk.textIterNew()
		     val enditer = Gtk.textIterNew()
		     val (startiter, enditer) = 
			 if Gtk.textBufferGetSelectionBounds(buf, startiter, enditer)
			     then (startiter, enditer)
			 else let val (start,endd) = paragraphIters(buf)
			      in Buffer.selectRange(buf, start, endd);
				  (start,endd)
			      end
		     in
			 (Gtk.textBufferGetText(buf, startiter, enditer, false),
			  Buffer.getLine startiter,
			  Buffer.getColumn startiter)
		     end) ()

                val str = addSpace(line, col, Gtk.utf8ToLatin1 str)
            in
                eval (true,true) (str^"\n")
            end
	  | COMPILER => OutputWriters.feedCurrentInput ()
	  | _ => ()

        fun compile () =
            case getCurrentPage() of NONE => ()
                                   | SOME id =>
            let
                val _ = saveFile ()
		val file = Buffer.getFileName id
            in
                case file of
                    NONE => ()
                  | SOME f => Evaluator.compileFile f
            end

        fun reallyClose p =
            (Buffer.close (getPage p);
	     removePage p;
             Gtk.notebookRemovePage(Gui.notebook1, p);
             currentPage := Gtk.notebookGetCurrentPage Gui.notebook1)

        fun close () = 
	     case getCurrentPage() of NONE => ()
	     			    | SOME id =>
            (if Buffer.canClose id then
		 reallyClose (!currentPage)
             else FileDialog.modifiedWarning
		 ("File modified.", "Discard changes and close anyway, or cancel?",
		  reallyClose, !currentPage);
             checkNotebookSize())

        fun interruptEval() =
            case (!evalSignal) of
                NONE => ()
              | SOME s => Promise.fulfill(s,Evaluator.INTERRUPT)
        fun backgroundEval() =
            case (!evalSignal) of
                NONE => ()
              | SOME s => Promise.fulfill(s,Evaluator.STOP)

        fun jumpToError (file, row, col, row', col') _ =
            case getCurrentPage() of NONE => ()
                                   | SOME id =>
            let
                val (buf,id) =
		    case file of
			NONE => (SOME (Buffer.getBuffer id), id)
		      | SOME f =>
	        Buffer.getBufferByName
		(OS.Path.mkAbsolute {path=f,relativeTo=OS.FileSys.getDir()})
	    in
		case buf of
		    NONE => ()
		  | SOME buf =>
	    Lock.sync Gtk.lock
	    (fn () =>
	    let
                val lineCount = Gtk.textBufferGetLineCount buf
                val startiter = Gtk.textIterNew()
                val _ = Gtk.textBufferGetStartIter(buf, startiter)
                val enditer = Gtk.textIterCopy startiter

		exception Off
		fun moveOffset(startiter, 0, pos) = ()
		  | moveOffset(startiter, n, pos) =
		    let
			val c = Gtk.textIterGetChar startiter
		    in
			if c = Char.ord #"\n" then
			    raise Off
			else if c = Char.ord #"\t" then
			    let
				val tabjump = 8 - pos mod 8
			    in
				Gtk.textIterForwardChar startiter;
				moveOffset(startiter, n-tabjump, pos+tabjump)
			    end
			else
			    (Gtk.textIterForwardChar startiter;
			     moveOffset(startiter, n-1, pos+1))
		    end
            in
                if row <= lineCount andalso
                   row' <= lineCount
                then
                    (Gtk.textIterSetLine(startiter, row-1);
                     Gtk.textIterSetLine(enditer, row'-1);
                     moveOffset(startiter, col, 0);
                     moveOffset(enditer, col', 0);
                     Buffer.selectRange(buf, enditer, startiter);
		     Buffer.scrollToCursor id;
		     Gtk.notebookSetCurrentPage(Gui.notebook1,
						valOf (findPage id));
                     Gtk.widgetGrabFocus (Buffer.getView id))
                    handle Off => ()
                else ()
            end) ()
	    end

        fun findErrorStart' (iter, tag) =
            if Gtk.textIterHasTag(iter, tag) then
                (Gtk.textIterBackwardChar iter; findErrorStart' (iter, tag))
            else
                ignore (Gtk.textIterForwardChar iter)
		
        fun findErrorStart (iter, tag) =
            if Gtk.textIterHasTag(iter, tag) then
		findErrorStart'(iter,tag)
            else
                if Gtk.textIterBackwardChar iter then findErrorStart(iter, tag)
		else ()

        fun parseErrorCoords s =
            let
                val (file, error) =
                    case String.tokens (fn #":" => true | _ => false) s of
                        [s1,s2] => (NONE, s1)
                      | (s1::s2::s3::_) => (SOME s1, s2)
		      | _ => raise Match (* make compiler happy *)
                val (s11,s12,s21,s22) =
                    case
                    String.tokens (fn #"-" => true
                                    | #"." => true
                                    | _ => false) error
                    of [s11,s12,s21,s22] => (s11,s12,s21,s22)
                     | _ => raise Match (* make compiler happy *)
                val s11 = Int.fromString s11
                val s12 = Int.fromString s12
                val s21 = Int.fromString s21
                val s22 = Int.fromString s22
            in
                if isNone s11 orelse isNone s12 orelse
                   isNone s21 orelse isNone s22 then
                    NONE
                else
                    SOME (file, valOf s11, valOf s12, valOf s21, valOf s22)
            end handle Match => NONE

        fun populatePopup (view, [Gtk.OBJECT menu]) =
            let
                val separator= Gtk.menuItemNew()
                val showError = Gtk.menuItemNewWithMnemonic("Jump to error location")
                val buf = Gtk.textViewGetBuffer view
                val cursor = Gtk.textBufferGetInsert(buf)
	    in
		Lock.sync Gtk.lock
		(fn () =>
		 let
		     val iter = Gtk.textIterNew()
		     val _ = Gtk.textBufferGetIterAtMark(buf,iter,cursor)
		     val errorTag =
			 Gtk.textTagTableLookup(Gtk.textBufferGetTagTable buf,
						"error")
		     val onErrorLine = Gtk.textIterHasTag(iter, errorTag)
		 in
		     Gtk.widgetSetSensitive(showError,
					    onErrorLine);
		     if onErrorLine then
			 let
			     val _ = findErrorStart (iter, errorTag)
			     val iter2 = Gtk.textIterCopy iter
			     val _ = Gtk.textIterForwardLine iter2
			     val str = Gtk.utf8ToLatin1 (Gtk.textIterGetText(iter, iter2))
			     val coords = parseErrorCoords str
			 in
			     case coords of NONE => Gtk.widgetSetSensitive(showError,
									   false)
				 
			   | SOME coords =>
				 (Gtk.signalConnect(showError, "activate", jumpToError coords);
				  ())
			 end
		     else ()
		 end) ();
                Gtk.widgetShow separator;
                Gtk.widgetShow showError;
                Gtk.containerAdd(menu, separator);
                Gtk.containerAdd(menu, showError)
            end
          | populatePopup _ = TextIO.output(TextIO.stdErr, "** Gtk is crazy: popup\n")

	fun jumpToLastError () =
	    Lock.sync Gtk.lock
	    (fn () =>
	     let
		 val buf = Gtk.textViewGetBuffer Gui.compilerout
		 val iter = Gtk.textIterNew()
		 val _ = Gtk.textBufferGetEndIter(buf, iter)
		 val errorTag =
		     Gtk.textTagTableLookup(Gtk.textBufferGetTagTable buf,
					    "error")
		 val _ = findErrorStart (iter, errorTag)
		 val iter2 = Gtk.textIterCopy iter
		 val _ = Gtk.textIterForwardLine iter2
		 val str = Gtk.utf8ToLatin1 (Gtk.textIterGetText(iter, iter2))
		 val coords = parseErrorCoords str
	     in
		 case coords of
		     NONE => ()
		   | SOME coords => jumpToError coords ()
	     end) ()

	fun indentSelection indent =
	    case getCurrentPage() of NONE => ()
	  | SOME id => Buffer.indentSelection(id, indent)

	fun reset () = Evaluator.reset()
	    
	val forwardHistory = OutputWriters.historyNext
	val backwardHistory = OutputWriters.historyPrev

	fun switchFile direction =
	    let
		val cp = !currentPage
		val np = if direction then cp+1 else cp-1
	    in
		if np<0 orelse np>List.length(!pages) then
		    ()
		else
		    Gtk.notebookSetCurrentPage(Gui.notebook1,
					       np)
	    end

	fun switchTo 0 =
	    (case getCurrentPage() of
		 NONE => ()
	       | SOME id => Gtk.widgetGrabFocus (Buffer.getView id))
	  | switchTo 1 =
		Gtk.widgetGrabFocus Gui.compilerout
	  | switchTo 2 =
		Gtk.widgetGrabFocus Gui.progout
	  | switchTo _ = ()

	fun clearIO () =
	    Lock.sync Gtk.lock
	    (fn () =>
	        Gtk.textBufferSetText(Gtk.textViewGetBuffer Gui.progout, "", ~1)
	    ) ()

	fun activateSyntax () =
	    case getCurrentPage() of
		NONE => ()
	      | SOME id =>
		    Buffer.setSyntaxHighlighting
		    (id, Gtk.checkMenuItemGetActive Gui.syntax_colouring)


	val reallyQuit = ref false
	fun doQuit () = (Config.saveHistory (History.get(),
					     Buffer.getFileNames());
			 reallyQuit := true;
			 OS.Process.exit OS.Process.success)

	exception DiscardAll
	fun quitCloseOpenFiles interactive (buffer as {id,buf,file,...} : Buffer.buffer) =
	    if Gtk.textBufferGetModified buf then
		case FileDialog.quitWarning(interactive,Option.getOpt(!file,"New File "^Int.toString id)) of
		    Gtk.RESPONSE_CANCEL => false
		  | Gtk.RESPONSE_OK => (* save *) if Buffer.save id then true
						  else (saveGivenFileAs id; true)
		  | Gtk.RESPONSE_ACCEPT => (* save as *) (saveGivenFileAs id; true)
		  | Gtk.RESPONSE_REJECT => (* discard all *) raise DiscardAll
		  | Gtk.RESPONSE_CLOSE => (* discard *) true
		  | Gtk.RESPONSE_DELETE_EVENT => if interactive then false
						 else quitCloseOpenFiles interactive buffer
		  | _ => raise Match (* make compiler happy *)
	    else true
	    
        fun quit' interactive = if !reallyQuit then ()
		      else if Buffer.haveModified ()
			       then if (Buffer.forallBuffers (quitCloseOpenFiles interactive)
					handle DiscardAll => true) then
				   doQuit ()
				    else ()
			   else doQuit ()

	fun quit () = quit' true

        fun init notebookSwitchEventId =
            (Gtk.signalConnect(Gui.compilerout, "populate-popup", populatePopup);
             Gtk.signalConnect(Gui.compilerout, "focus-in-event",
                               changeFocus COMPILER);
             Gtk.signalConnect(Gui.progout, "focus-in-event",
                               changeFocus STDSTREAMS);
	     Promise.fulfill(notebookSwitchEventIdP, notebookSwitchEventId);
	     OutputWriters.makeWriters (eval (false, false));
	     History.set (Config.loadHistory());
	     Gtk.textViewSetEditable(Gui.compilerout, false);
	     Gtk.windowSetDefaultSize(Gui.mainwidget,
				      Config.sizeX,Config.sizeY);
	     Gtk.widgetShowAll Gui.mainwidget;
             Gtk.widgetGrabFocus (Gui.compilerout);
	     OS.Process.atExit (fn () => quit' false))

	fun initDone () =
	    (Gtk.textViewSetEditable(Gui.compilerout, true);
	     Gtk.widgetSetSensitive(Gui.feed1, true);
	     app openGivenFile (Config.loadOpenFiles ()))

	fun preferences () = 
	    Preferences.showDialog()
    end
