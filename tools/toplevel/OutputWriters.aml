(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *   Guido Tack <tack@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg and Guido Tack, 2005
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Stream from "x-alice:/lib/data/Stream"
import structure Gtk from "x-alice:/lib/gtk/Gtk"
import structure Gui from "Gui"
import structure Gdk from "x-alice:/lib/gtk/Gdk"
import structure Config from "Config"
import structure History from "History"
import structure Evaluator from "Evaluator"
import structure BufferHighlight from "BufferHighlight"

structure OutputWriters =
   struct
      open Config

      (* Stream redirection *)

      fun markWriter (mark, TextPrimIO.WR ops) =
	  let
	      val mark' = Substring.full (String.str mark)
	      val writeVec = Option.valOf (#writeVec ops)
	      fun marked f sl = (writeVec mark'; f sl)
	  in
	      TextPrimIO.WR {ops where
			     writeVec = Option.map marked (#writeVec ops),
			     writeArr = Option.map marked (#writeArr ops),
			     writeVecNB = Option.map marked (#writeVecNB ops),
			     writeArrNB = Option.map marked (#writeArrNB ops)}
	  end

      val (stdin, stdInText) = Stream.stream ()
      val stdInReader = TextPrimIO.openVectorListRd stdInText
      val progStdIn = TextIO.StreamIO.mkInstream (stdInReader, "")
      val _ = TextIO.setInstream (TextIO.stdIn, progStdIn)

      val (stdText, stdWriter) = TextPrimIO.openVectorListWr ()

      val stdOutWriter = markWriter (#"\001", stdWriter)
      val progStdOut = TextIO.StreamIO.mkOutstream (stdOutWriter, IO.LINE_BUF)
      val _ = TextIO.setOutstream (TextIO.stdOut, progStdOut)

      val stdErrWriter = markWriter (#"\002", stdWriter)
      val progStdErr = TextIO.StreamIO.mkOutstream (stdErrWriter, IO.NO_BUF)
      val _ = TextIO.setOutstream (TextIO.stdErr, progStdErr)

      val (compilerText, compilerWriter) = TextPrimIO.openVectorListWr ()

      val compilerInWriter = markWriter (#"\000", compilerWriter)
      val compilerIn = TextIO.StreamIO.mkOutstream (compilerInWriter, IO.NO_BUF)

      val compilerOutWriter = markWriter (#"\001", compilerWriter)
      val compilerOut = TextIO.StreamIO.mkOutstream (compilerOutWriter, IO.LINE_BUF)
      val _ = Evaluator.setOutStream compilerOut

      val compilerErrWriter = markWriter (#"\002", compilerWriter)
      val compilerErr = TextIO.StreamIO.mkOutstream (compilerErrWriter, IO.LINE_BUF)
      val _ = Evaluator.setErrStream compilerErr

      val (traceText, compilerTraceWriter) = TextPrimIO.openVectorListWr ()
      val compilerTrace = TextIO.StreamIO.mkOutstream (compilerTraceWriter, IO.NO_BUF)
      val _ = Evaluator.setTraceStream compilerTrace

      val (rowCol, rowColText) = Stream.stream ()


      (* Highlight *)

      fun highlight (buffer, text, startOffset, startiter, enditer) =
          if Gtk.textIterGetChar startiter = ord #"#"
          then Gtk.textBufferApplyTagByName(buffer, "comment", startiter, enditer)
          else BufferHighlight.highlight(buffer, text, startOffset, false, ref false)

      fun fillBuf (view, buffer, handler, tags, noed, highlight, text) =
          let
              val iter = Gtk.textIterNew()
              val _ = Gtk.textBufferGetEndIter(buffer,iter)
	      val _ = Gtk.textIterBackwardChar iter
              val noInputYet = Gtk.textIterHasTag(iter, noed)
	      val _ = Gtk.textIterForwardChar iter
	      val _ = if noInputYet
		      then Gtk.textBufferGetEndIter(buffer, iter)
		      else ignore (Gtk.textIterBackwardToTagToggle(iter, noed))
	      val startOffset = Gtk.textIterGetOffset iter
	      val start = Gtk.textIterCopy iter
              val textUtf8 = Gtk.latin1ToUtf8 text
          in
              Gtk.signalHandlerBlock(buffer, handler);
	      Gtk.textBufferInsert(buffer, iter, textUtf8, size textUtf8);
              Gtk.textBufferGetIterAtOffset (buffer, start, startOffset);
              Gtk.textBufferGetIterAtOffset (buffer, iter, startOffset + size text);
              app (fn t => Gtk.textBufferApplyTag(buffer, t, start, iter)) tags;
              highlight (buffer, text, startOffset, start, iter);
              Gtk.textBufferApplyTag(buffer, noed, start, iter);
              Gtk.textBufferPlaceCursor(buffer,iter);
              Gtk.textViewScrollToMark(view, Gtk.textBufferGetInsert buffer,
                                       0.0, false, 0.0, 0.0);
              Gtk.signalHandlerUnblock(buffer, handler)
          end

      val fillBuf = Lock.sync Gtk.lock fillBuf
              
      val contextId = Gtk.statusbarGetContextId(Gui.statusbar, "Alice")
      val _ = Gtk.statusbarPush(Gui.statusbar,contextId, "Ready.");

      fun setStatus msg = 
          let
              val msg = if String.isPrefix "-- " msg then
                            String.extract(msg, 3, NONE)
                        else msg
              val msg = String.map (fn #"\n" => #" " | c => c) msg
          in
              (Gtk.statusbarPop(Gui.statusbar, contextId);
               Gtk.statusbarPush(Gui.statusbar, contextId, msg);
               ())
          end

      val rowColId = Gtk.statusbarGetContextId(Gui.statusbar1, "rowcol")
      val _ = Gtk.statusbarPush(Gui.statusbar1,rowColId,
                                "L 0  C 0");

      fun setRowCol (row, col) =
          let
              val r = Int.toString row
              val c = Int.toString col
              val msg = "L "^r^"  C "^c
          in
              (Gtk.statusbarPop(Gui.statusbar1, rowColId);
               Gtk.statusbarPush(Gui.statusbar1, rowColId, msg);
               ())
          end

	val cmap   = Gdk.colormapGetSystem ()
        val textColor = Gdk.colorNew(0xf0f0, 0x2020, 0xa0a0)
	val black = Gdk.colorNew(0, 0, 0)
	val white = Gdk.colorNew(65535, 65535, 65535)
	val _ = Gdk.colormapAllocColor(cmap, black, false, true)
	val _ = Gdk.colormapAllocColor(cmap, white, false, true)
	val _ = Gdk.colormapAllocColor(cmap, textColor, false, true)

        fun progInInsert (stdInStream,noedit,bold)
		(buf, [Gtk.INT off, Gtk.STRING txt, Gtk.INT size]) =
            if String.sub(txt, String.size txt - 1) = #"\n" then
                let
                    val enditer = Gtk.textIterNew()
                    val cursor = Gtk.textBufferGetInsert buf
                    val _ = Gtk.textBufferGetIterAtMark(buf,enditer,cursor)
                    val startiter = Gtk.textIterCopy enditer
                    val _ = Gtk.textIterBackwardToTagToggle(startiter,noedit)
                    val str = Gtk.textBufferGetText(buf, startiter, enditer, false)
                    val str = Gtk.utf8ToLatin1 str
                    val _ = Stream.send(stdInStream, str)
                in
                    Gtk.textBufferApplyTag(buf, noedit, startiter, enditer)
                end
            else
                let
                    val startiter = Gtk.textIterNew()
		    val _ = Gtk.textBufferGetIterAtOffset(buf, startiter, off)
                    val enditer = Gtk.textIterCopy startiter
		    val _ = Gtk.textIterForwardChars(enditer, size)
                in
                    Gtk.textBufferApplyTag(buf, bold, startiter, enditer)
                end
          | progInInsert _ _ = () (* Gtk is crazy *)

        fun lastChar' iter =
            if Gtk.textIterBackwardChar iter then
                let
                    val c = Gtk.textIterGetChar iter
                in
                    (*if c <= Char.maxOrd andalso Char.isSpace(chr c)
                    then lastChar' iter
                    else*) SOME c
                end
            else NONE
        fun lastChar(buf, off) =
            let
                val iter = Gtk.textIterNew()
            in
                (*Gtk.textBufferGetIterAtOffset(buf, iter, off);*)
		Gtk.textBufferGetEndIter(buf, iter);
		Gtk.textIterGetOffset iter = off+1
		andalso Gtk.textIterBackwardChar iter;
                lastChar' iter
            end

	fun feedCurrentInput () =
	    let
		val buf = Gtk.textViewGetBuffer Gui.compilerout
                val enditer = Gtk.textIterNew()
		val _ = Gtk.textBufferGetEndIter(buf, enditer)
		val off = Gtk.textIterGetOffset enditer
	    in
		Gtk.textBufferPlaceCursor(buf, enditer);
		lastChar(buf, off) = SOME (ord #";")
		orelse Gtk.textBufferInsertInteractive(buf,enditer,";",~1,true);
		Gtk.textBufferInsertInteractive(buf,enditer,"\n",~1,true);
		()
	    end

 	val compilerBufRef = ref NONE  (* Argh, is this hacking... *)
	val noeditRef = ref NONE
	val insertHandler = ref 0

        fun compilerInsert (eval, noedit, bold)
		(buf, [Gtk.INT off, Gtk.STRING txt, Gtk.INT size]) =
	    let
(*
                val enditer = Gtk.textIterNew()
                val cursor = Gtk.textBufferGetInsert buf
                val _ = Gtk.textBufferGetIterAtMark(buf,enditer,cursor)
                val startiter = Gtk.textIterCopy enditer
*)
                val startiter = Gtk.textIterNew()
                val enditer = Gtk.textIterNew()
	    in
		(*if String.sub(txt, String.size txt - 1) = #"\n" then*)
		if txt = "\n" then
		    if lastChar(buf, off+size-1) = SOME (ord #";") then
                	let
			    val _ = Gtk.textBufferGetIterAtOffset(buf, startiter, off)
			    val _ = Gtk.textBufferGetIterAtOffset(buf, enditer, off)
			    val _ = Gtk.textIterForwardChar enditer
			    val _ = Gtk.textBufferDelete(buf, startiter, enditer)

			    val _ = Gtk.textBufferGetEndIter(buf, startiter)
			    val _ = Gtk.signalHandlerBlock(buf, !insertHandler)
			    val _ = Gtk.textBufferInsert(buf, startiter, "\n", ~1)
			    val _ = Gtk.signalHandlerUnblock(buf, !insertHandler)

		            val _ = Gtk.textBufferGetEndIter(buf, enditer)
			    val _ = Gtk.textBufferGetEndIter(buf, startiter)
                	    val _ = Gtk.textIterBackwardToTagToggle(startiter, noedit)
                	    val _ = Gtk.textBufferApplyTag(buf, noedit, startiter, enditer)
                	    val str = Gtk.textBufferGetText(buf, startiter, enditer, false)
                	    val str = Gtk.utf8ToLatin1 str
                	in
                	    eval str;
                	    History.extend (String.substring (str, 0, String.size str-1))
                	end
		    else
			(Gtk.signalHandlerBlock(buf, !insertHandler);
			 Gtk.textBufferInsertAtCursor(buf, "  ", ~1);
			 Gtk.signalHandlerUnblock(buf, !insertHandler))
        	else
		    let
			val _ = Gtk.textBufferGetEndIter(buf, enditer)
			val _ = Gtk.textBufferGetIterAtOffset(buf, startiter, off)
			val _ = Gtk.textIterBackwardChar startiter
        		val noInputYet = Gtk.textIterHasTag(startiter, noedit)
			val _ = Gtk.textIterForwardChar startiter
			val _ = if noInputYet
				then Gtk.textBufferGetIterAtOffset(buf, startiter, off)
				else ignore (Gtk.textIterBackwardToTagToggle(startiter, noedit))
                	val str = Gtk.textBufferGetText(buf, startiter, enditer, false)
                	val str = Gtk.utf8ToLatin1 str
			val offset = Gtk.textIterGetOffset startiter
		    in
			Gtk.textBufferRemoveAllTags(buf, startiter, enditer);
                        Gtk.textBufferApplyTag(buf, bold, startiter, enditer);
                	highlight(buf, str, offset, startiter, enditer)
		    end
	    end
          | compilerInsert _ _ = () (* Gtk is crazy *)

	fun compilerDelete (noedit, bold) (buf, _) =
	    let
                val startiter = Gtk.textIterNew()
                val enditer = Gtk.textIterNew()
		val _ = Gtk.textBufferGetEndIter(buf, enditer)
		val _ = Gtk.textBufferGetEndIter(buf, startiter)
		val _ = Gtk.textIterBackwardChar startiter
        	val noInputYet = Gtk.textIterHasTag(startiter, noedit)
		val _ = Gtk.textIterForwardChar startiter
		val _ = if noInputYet
			then Gtk.textBufferGetEndIter(buf, startiter)
			else ignore (Gtk.textIterBackwardToTagToggle(startiter, noedit))
                val str = Gtk.textBufferGetText(buf, startiter, enditer, false)
                val str = Gtk.utf8ToLatin1 str
		val offset = Gtk.textIterGetOffset startiter
	    in
		Gtk.textBufferRemoveAllTags(buf, startiter, enditer);
                Gtk.textBufferApplyTag(buf, bold, startiter, enditer);
                highlight(buf, str, offset, startiter, enditer)
	    end

	fun compilerHistory direction () =
	    let
                val buf = Option.valOf (!compilerBufRef)
		val noedit = Option.valOf (!noeditRef)
		val enditer = Gtk.textIterNew()
                val _ = Gtk.textBufferGetEndIter(buf, enditer)
                val startiter = Gtk.textIterCopy enditer
		val _ = Gtk.textIterBackwardChar startiter
                val noInputYet = Gtk.textIterHasTag(startiter, noedit)
		val _ = Gtk.textIterForwardChar startiter
		val _ = if noInputYet
			then Gtk.textBufferGetEndIter(buf, startiter)
			else ignore (Gtk.textIterBackwardToTagToggle(startiter, noedit))
                val s = Gtk.textBufferGetText(buf, startiter, enditer, false)
		val s = Gtk.utf8ToLatin1 s
		val s' = Gtk.latin1ToUtf8 (direction s)
	    in
		Gtk.textBufferDelete(buf, startiter, enditer);
		Gtk.textBufferPlaceCursor(buf, startiter);
		Gtk.textBufferInsertAtCursor(buf, s', ~1);
                Gtk.textViewScrollToMark(Gui.compilerout,
					 Gtk.textBufferGetInsert buf,
                                         0.0, false, 0.0, 0.0)
	    end

      val historyPrev = compilerHistory History.backwards
      val historyNext = compilerHistory History.forwards

      fun makeWriters eval =
          let
              val progBuf = Gtk.textBufferNew Gtk.NULL
              val compilerBuf = Gtk.textBufferNew Gtk.NULL
              val {err=pErr,log=pLog,plain=pStd,noedit=pNoEd,bold=pBold,...} = makeTags progBuf
              val {err=cErr,log=cLog,plain=cStd,noedit=cNoEd,bold=cBold,...} = makeTags compilerBuf
              val pSig = Gtk.signalConnect(progBuf, "insert-text",
                                           progInInsert (stdin, pNoEd, pBold))
              val cSig = Gtk.signalConnect(compilerBuf, "insert-text",
                                           compilerInsert (eval, cNoEd, cBold))
              val cDelSig = Gtk.signalConnect(compilerBuf, "delete-range",
                                              compilerDelete (cNoEd, cBold))

              fun forward (widget, buf, signal, noed, styles, highlights) =
		  let
		      fun receive (text, mark) =
			  (if String.size text = 0 then mark else
			  if String.sub (text, 0) <= #"\002"
			  then receive (String.extract (text, 1, NONE),
					Char.ord (String.sub (text, 0)))
			  else (
			  fillBuf (widget, buf, signal,
					 [Vector.sub (styles, mark)], noed,
					 Vector.sub (highlights, mark), text);
				mark)
			  ) handle e =>
				(TextIO.output(TextIO.stdErr,
					       "** uncaught exception " ^ Exn.name e ^
					       " in output writer\n");
				 mark)
		  in
		      receive
		  end
          in
              compilerBufRef := SOME compilerBuf;
	      noeditRef := SOME cNoEd;
	      insertHandler := cSig;
	      Gtk.widgetModifyFont(Gui.compilerout, !Config.stdFont);
	      Gtk.widgetModifyFont(Gui.progout, !Config.stdFont);
              Gtk.textViewSetBuffer(Gui.progout, progBuf);
              Gtk.textViewSetBuffer(Gui.compilerout, compilerBuf);
	      spawn foldl (forward (Gui.compilerout, compilerBuf, cSig, cNoEd,
				    #[cStd, cLog, cErr],
				    #[highlight, highlight, const ()])) 1 compilerText;
	      spawn foldl (forward (Gui.progout, progBuf, pSig, pNoEd,
				    #[pStd, pStd, pErr],
				    #[const (), const (), const ()])) 1 stdText;
              spawn app setStatus traceText;
              spawn app setRowCol rowColText
          end
   end
