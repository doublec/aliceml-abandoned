(*
 * Authors:
 *   Guido Tack <tack@ps.uni-sb.de>
 *
 * Copyright:
 *   Guido Tack, 2004
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure GtkClasses from "GtkClasses"
import structure GtkDefaults from "GtkDefaults"

signature CODE_EMITTER =
  sig
      type property = string * string
      type signal = string * string * string

      type document
      val new : string -> document
      val newBuffered : string -> document
      val preamble : document -> unit
      val preambleStruct : document -> unit
      val preambleFunct : document -> unit
      val preambleIncl : document * string * string -> unit
      val postambleStruct : document -> unit
      val postambleFunct : document -> unit
      val close : document -> unit
      val getStructureName : document -> string
      val getFileName : document -> string
      val output : document * string -> unit
      val comment : document * string list -> unit
      val outputHelpers : document -> unit
      val newObject : document * 
		      string * string * property list
		      * string list * signal list
		      * (string * string * string) list -> unit
      val attachChildren : document *
			   string * string *
			   (string * property list) list 
			   -> unit
      val attachSignals : document * string * string *
			  string * signal list -> unit

  end

structure CodeEmitter :> CODE_EMITTER =
  struct
    open GtkDefaults

    type property = string * string
    type signal = string * string * string

    datatype virtual = L of string | C of virtual * virtual

    fun virtualApp f (L s) = f s
      | virtualApp f (C (v1, v2)) = (virtualApp f v1;
				     virtualApp f v2)

    datatype outbuffer = F of TextIO.outstream option * int ref
		       (*      preamble      signature     functor *)
		       | S of (virtual ref * virtual ref * virtual ref) *
			      (int ref * int ref * int ref)

    (*               output stream   filename *)
    type document = (outbuffer ref * string * string list ref)

    fun outputIndent(os, 0) = ()
      | outputIndent(os, n) = (TextIO.output(os, " ");
				  outputIndent(os, n-1))

    fun outputIndentToString(os, 0) = ()
      | outputIndentToString(os, n) = (os := (C ((!os), (L " ")));
				       outputIndentToString(os, n-1))

    fun indent(os,_,_) =
	case !os of
	    (F (_, i)) => i:= !i+2
	  | (S (_, (_,_,i))) => i:= !i+2
    fun outdent(os,_,_) =
	case !os of
	    (F (_, i)) => if (!i>=2) then i:= !i-2 else ()
	  | (S (_, (_,_,i))) => if (!i>=2) then i:= !i-2 else ()
    fun indentPre(os,_,_) =
	case !os of
	    (F (_, i)) => i:= !i+2
	  | (S (_, (i,_,_))) => i:= !i+2
    fun outdentPre(os,_,_) =
	case !os of
	    (F (_, i)) => if (!i>=2) then i:= !i-2 else ()
	  | (S (_, (i,_,_))) => if (!i>=2) then i:= !i-2 else ()
    fun indentSig(os,_,_) =
	case !os of
	    (F (_, i)) => i:= !i+2
	  | (S (_, (_,i,_))) => i:= !i+2
    fun outdentSig(os,_,_) =
	case !os of
	    (F (_, i)) => if (!i>=2) then i:= !i-2 else ()
	  | (S (_, (_,i,_))) => if (!i>=2) then i:= !i-2 else ()

    (* Char Transformation *)
    local
	fun firstLower'(x::xr) = String.implode ((Char.toLower x)::xr)
	  | firstLower' nil    = ""
    in
    fun firstLower xs = firstLower'(String.explode xs)
    end
    local
	fun firstUpper'(x::xr) = String.implode ((Char.toUpper x)::xr)
	  | firstUpper' nil    = ""
    in
    fun firstUpper xs = firstUpper'(String.explode xs)
    end

    (* insert string between elements of string list *)
    fun insertStr s nil = ""
      | insertStr s [p] = p
      | insertStr s (p::ps) = p^s^(insertStr s ps)

    (* replace reserved symbols by "_" *)
    fun cvtId s =
	let
	    fun sep (#"+" | #"-" | #"/" | #"*") = true
	      | sep (#"<" | #">" | #"=" | #"!") = true
	      | sep (#"@" | #"#" | #"$" | #"%") = true
	      | sep (#"^" | #"&" | #"'" | #"~") = true
	      | sep (#"\\" | #"|" | #"?" | #":" | #".") = true
	      | sep _ = false
	in
	    insertStr "_" (String.tokens sep s)
	end

    fun getStructureName(_,s,_) = firstUpper (cvtId s)
    fun getFileName(_,s,_) = s

    fun rememberString((_,_,r), s) = r:= s::(!r)
    fun stringIsKnown((_,_,r),s) = List.contains (!r) s

    fun cvtSigName s = String.implode (map Char.toUpper (String.explode s))

    fun output(doc as (r, f, _), s) =
	case !r of
	    (F (SOME outStream, ind)) =>
	    (outputIndent(outStream, !ind);
	     TextIO.output(outStream, s))
	  | (F (NONE, ind)) =>
	    let val os = TextIO.openOut (f^".aml") in
		r:= F (SOME os, ref 0);
		output(doc,s)
	    end
	  | S ((_,_,r), (_,_,ind)) =>
	    (outputIndentToString(r, !ind);
	     r:= (C (!r,L s)))

    fun outputPre(doc as (r, f, _), s) =
	case !r of
	    (F (SOME outStream, ind)) =>
	    (outputIndent(outStream, !ind);
	     TextIO.output(outStream, s))
	  | (F (NONE, ind)) =>
	    let val os = TextIO.openOut (f^".aml") in
		r:= F (SOME os, ind);
		outputPre(doc,s)
	    end
	  | S ((r,_,_),(ind,_,_)) =>
	    (outputIndentToString(r, !ind);
	     r:= (C (!r,L s)))

    fun outputSig(doc as (r, f, _), s) =
	case !r of
	    (F (SOME outStream, ind)) =>
	    (outputIndent(outStream, !ind);
	     TextIO.output(outStream, s))
	  | (F (NONE,ind)) =>
	    let val os = TextIO.openOut (f^".aml") in
		r:= F (SOME os, ind);
		outputSig(doc,s)
	    end
	  | S ((_,r,_),(_,ind,_)) =>
	    (outputIndentToString(r, !ind);
	     r:= (C (!r,L s)))
	
    exception CodeEmitterError of string

    (* Convert string to string containing a real number *)
    fun realString (SOME s) = Real.toString(getOpt(Real.fromString s, 0.0))
      | realString NONE = "0.0"

    (* Extract values from property list*)
    fun getProp(ps, p) =
	let
	    fun drop' nil v l = (v,l)
	      | drop' ((x,y)::xr) v l = if x=p then drop' xr (SOME y) l
					else drop' xr v ((x,y)::l)
	in
	    drop' ps NONE nil
	end
    fun forceGetProp(ps, p) =
	case getProp(ps, p) of (SOME i, psr) => (i, psr)
			     | _ => raise CodeEmitterError ("Property "^p^" missing.")
    fun getBoolProp(ps, p) = case getProp(ps, p) of
				 (SOME "True", psr) => ("true", psr)
			       | (_, psr) => ("false", psr)
    fun getIntProp(ps, p) = case getProp(ps, p) of
				(SOME i, psr) => (i, psr)
			      | (NONE, psr)   => ("0", psr)
    fun getRealProp(ps, p) =
	let
	    val (i, psr) = getProp(ps, p)
	in
	    (realString i, psr)
	end
    fun getAdjProp(ps, p) =
        let
            val (a, psr) = getProp(ps, p)
            fun sep #" " = true | sep _ = false
        in
            case a of NONE => ("0.0","0.0","0.0","0.0","0.0","0.0",psr)
                    | SOME a' =>
                      (case map (realString o SOME) (String.tokens sep a') of
                           [a1,a2,a3,a4,a5,a6] =>
                           (a1,a2,a3,a4,a5,a6,psr)
                         | _ => ("0.0","0.0","0.0","0.0","0.0","0.0",psr))
        end
	    
    (* translate Gtk name to Alice name*)
    fun translateName str =
	let
	    fun sep #"_" = true
	      | sep _    = false
	in
	    String.concat (map firstUpper (String.tokens sep str))
	end

    (* tries to guess whether s is a gtk string a la "BLABLA_BLUB" *)
    fun isGtkName s = List.all (fn x => x= #"_" orelse
					(Char.isAlpha x andalso
					 Char.toUpper x=x))
		      (String.explode s)

    (* convert gtk c++ names (a la GtkListItem) to Alice names *)
    (* (like listItem) *)
    fun cvtGtkName s = if String.isPrefix "GTK_" s then
			    String.extract(s, 4, NONE)
			else if String.isPrefix "Gtk" s then
			    if String.isPrefix "GtkVBox" s then
				"vbox"^String.extract(s,7,NONE)
			    else if String.isPrefix "GtkHBox" s then
				"hbox"^String.extract(s,7,NONE)
			    else if String.isPrefix "GtkHPaned" s then
				"hpaned"^String.extract(s,9,NONE)
			    else if String.isPrefix "GtkVPaned" s then
				"vpaned"^String.extract(s,9,NONE)
			    else if String.isPrefix "GtkHButton" s then
				"hbutton"^String.extract(s,10,NONE)
			    else if String.isPrefix "GtkVButton" s then
				"vbutton"^String.extract(s,10,NONE)
			    else if String.isPrefix "GtkHScale" s then
				"hscale"^String.extract(s,9,NONE)
			    else if String.isPrefix "GtkVScale" s then
				"vscale"^String.extract(s,9,NONE)
			    else
				(Char.toString(Char.toLower(String.sub(s,3)))^
				 String.extract(s,4,NONE))
			else s

    (* tries to guess the type of a property *)
    fun quote s = String.toCString s
    fun cvtProperty("title", s) = "\""^s^"\""
      | cvtProperty("text", s) = "\""^quote s^"\""
      | cvtProperty("invisible_char", s) =
	(case String.explode s of
	     nil => raise CodeEmitterError "Empty invisible char"
	   | (c::_) => Int.toString (Char.ord c))
      | cvtProperty(_,"True") = "true"
      | cvtProperty(_,"False") = "false"
      | cvtProperty(_,s) = if isGtkName s then
			       "Gtk."^(cvtGtkName s)
			   else s

    (* Process remaining properties *)
    fun processProperties(doc, class, id, nil) = ()
      | processProperties(doc, class, id, ("visible", "True")::ps) =
	((*output(doc, "val _ = Gtk.widgetShow "^id^"\n");*)
	 processProperties(doc, class, id, ps))
      | processProperties(doc, class, id, ("visible",_)::ps) =
	processProperties(doc, class, id, ps)
      | processProperties(doc, class, id, ("value_in_list",_)::ps) =
	processProperties(doc, class, id, ps)
      | processProperties(doc, class, id, ("allow_empty",_)::ps) =
	processProperties(doc, class, id, ps)
      | processProperties(doc, class, id, (p as ("xpad"|"ypad"), v)::ps) =
	let
	    val (method,value) = ("Gtk.miscSetField"^translateName p, v)
	in
	    if isDefault(method,value) then ()
	    else output(doc, "val _ = "^method^"("^id^","^v^")\n");
	    processProperties(doc, class, id, ps)
	end
      | processProperties(doc, class, id, ("wrap", v)::ps) =
	(* TODO *)
	processProperties(doc, class, id, ps)
      | processProperties(doc, class as ("GtkMenuItem" | "GtkCheckMenuItem" | "GtkImageMenuItem" | "GtkSeparatorMenuItem" | "GtkTearoffMenuItem"), id, ("use_underline", v)::ps) =
	processProperties(doc, class, id, ps)
      | processProperties(doc, "GtkScrolledWindow", id, ("window_placement", v)::ps) =
	processProperties(doc, "GtkScrolledWindow", id, ("placement", v)::ps)
      | processProperties(doc, "GtkScrolledWindow", id, ("hscrollbar_policy", v)::ps) =
	let
	    val (v', psr) = getProp(ps, "vscrollbar_policy")
	    val v' = "Gtk."^(cvtGtkName (Option.getOpt (v', "GTK_POLICY_ALWAYS")))
	    val v = "Gtk."^(cvtGtkName v)
	in
	    processProperties(doc, "GtkScrolledWindow", id,
			      ("policy",v^","^v')::psr)
	end
      | processProperties(doc, "GtkScrolledWindow", id, ("vscrollbar_policy", v)::ps) =
	let
	    val (v', psr) = getProp(ps, "hscrollbar_policy")
	    val v' = "Gtk."^(cvtGtkName (Option.getOpt (v', "GTK_POLICY_ALWAYS")))
	    val v = "Gtk."^(cvtGtkName v)
	in
	    processProperties(doc, "GtkScrolledWindow", id,
			      ("policy",v'^","^v)::psr)
	end
      | processProperties(doc, class, id, ("draw_indicator", v)::ps) =
	processProperties(doc, class, id, ps)
      | processProperties(doc, class, id, ("column_spacing",v)::ps) =
	processProperties(doc, class, id, ("col_spacings",v)::ps)
      | processProperties(doc, class, id, ("row_spacing",v)::ps) =
	processProperties(doc, class, id, ("row_spacings",v)::ps)
      | processProperties(doc, class, id, ("toolbar_style", v)::ps) =
	processProperties(doc, class, id, ("style",v)::ps)
      | processProperties(doc, class, id, ("layout_style", v)::ps) =
	processProperties(doc, class, id, ("layout",
					   cvtGtkName v)::ps)
      | processProperties(doc, "GtkNotebook", id,
			  ("enable_popup","True")::ps) =
	(output(doc, "val _ = Gtk.notebookPopupEnable("^id^")\n");
	 processProperties(doc, "GtkNotebook", id, ps))	
      | processProperties(doc, "GtkNotebook", id,
			  ("enable_popup","False")::ps) =
	((*output(doc, "val _ = Gtk.notebookPopupDisable("^id^")\n");*)
	 (* this is the default *)
	 processProperties(doc, "GtkNotebook", id, ps))	
      | processProperties(doc, class, id, ("can_focus", "True")::ps) =
	((*output(doc, "val _ = Gtk.widgetSetFlags("^id^","^
		       "Gtk.GtkWidgetFlagsToInt Gtk.CAN_FOCUS)\n");*)
	 (* this is the default *)
	 processProperties(doc, class, id, ps))
      | processProperties(doc, class, id, ("can_focus", _)::ps) =
	(output(doc, "val _ = Gtk.widgetUnsetFlags("^id^","^
		     "Gtk.GtkWidgetFlagsToInt Gtk.CAN_FOCUS)\n");
	 processProperties(doc, class, id, ps))
      | processProperties(doc, class, id, ("xalign",v)::ps) =
	let
	    val (yalign, psr) = getRealProp(ps, "yalign")
	    val xalign = realString(SOME v)
	in
	    processProperties(doc, class, id,
			      ("alignment",xalign^","^
					   yalign)::psr)
	end
      | processProperties(doc, class, id, ("yalign",v)::ps) =
	let
	    val (xalign, psr) = getRealProp(ps, "xalign")
	    val yalign = realString(SOME v)
	in
	    processProperties(doc, class, id,
			      ("alignment",xalign^","^
					   yalign)::psr)
	end
      | processProperties(doc, class, id, ("width_request", v)::ps) =
	let
	    val (height, psr) = getIntProp(ps, "height_request")
	in
	    processProperties(doc, class, id,
			      ("size_request",v^","^height)::psr)
	end
      | processProperties(doc, class, id, ("height_request", v)::ps) =
	let
	    val (width, psr) = getIntProp(ps, "width_request")
	in
	    processProperties(doc, class, id,
			      ("size_request",width^","^v)::psr)
	end
      | processProperties(doc, class, id, ("tooltip",v)::ps) = 
	(output(doc, "val _ = Gtk.tooltipsSetTip(Helpers.tooltips,"^
		     id^","^cvtProperty("text",v)^",\"\")\n");
	 processProperties(doc, class, id, ps))
      | processProperties(doc, class, id, ("window_position",v)::ps) =
	let
	    val (method,value) = ("Gtk.windowSetPosition",
				  "Gtk."^cvtGtkName v)
	in
	    if isDefault(method,value) then ()
	    else output(doc, "val _ = "^method^"("^id^","^value^")\n");
	    processProperties(doc, class, id, ps)
	end
      | processProperties(doc, "GtkTextView", id, (p as ("text", v))::ps) =
	(output(doc, "val _ = Gtk.textBufferSetText(Gtk.textViewGetBuffer "^id^","^
				  cvtProperty p^",~1)\n");
	 processProperties(doc, "GtkTextView", id, ps))
      | processProperties(doc, class, id, (p,v)::ps) =
	let
	    val methodname =
		GtkClasses.getMethod(class,
				     "Set"^firstUpper(translateName p))
	in
	    case methodname of
		NONE => (print ("Warning: method "^
				cvtGtkName class^
				"Set"^firstUpper(translateName p)^
				" not found.\n");
			 processProperties(doc, class, id, ps))
	      | SOME methodname =>
		((case p of "group" =>
			    let
				val gettername =
				    GtkClasses.getMethod(class,
							 "Get"^firstUpper(translateName p))
			    in
				case gettername of
				    NONE => raise CodeEmitterError ("Method "^"Get"^firstUpper(translateName p)^
								    " not found.")
				  | SOME gettername =>
				    output(doc, "val _ = Gtk."^methodname^
						"("^id^",Gtk."^gettername^"("^v^"))\n")
			    end
			| _ =>
			  let
			      val (method,value) = ("Gtk."^methodname,
						    cvtProperty(p,v))
			  in
			      if isDefault(method,value) then ()
			      else output(doc, "val _ = "^method^
					       "("^id^","^value^")\n")
			  end);
		 processProperties(doc, class, id, ps))
	end

    (* attaches accelerator keys to widgets *)
    fun processAccelerator(doc, class, id, (key, modifiers, signal)) =
	let
	    val key = "Key.K_"^key
	    val mods = String.tokens (fn #"|" => true | c => Char.isSpace c) modifiers
	    fun gdk s =
		if String.isPrefix "GDK_" s then
		    "(Gdk.GdkModifierTypeToInt Gdk."^String.extract(s, 4, NONE)^")"
		else s
	    val mods = map gdk mods
	    val mods =
		case mods of
		    nil => ""
		  | [m]=> m
		  | (m::mr) => String.concat ((map (fn m => m^"+") mr)@[m])
	in
	    output(doc, "val _ = Gtk.widgetAddAccelerator("^id^",\""^
		   signal^"\",Helpers.accelGroup,Key.keyvalToInt "^key^
		   ","^mods^",Gtk.GtkAccelFlagsToInt Gtk.ACCEL_VISIBLE)\n")
	end
    fun processAccelerators(doc, class, id, accels) =
	app (fn a => processAccelerator(doc, class, id, a)) accels

    (* computes name of constructor and label *)
    fun getConstructor(class, prop) =
	(case getProp(prop, "label") of
	     (SOME l, psr) =>
	     (case getProp(psr, "use_stock") of
		  (SOME "True", psr) =>
		      (case class of
			   "GtkButton" =>
			       ("Gtk."^cvtGtkName(class)^"NewFromStock", SOME ("\""^l^"\""), psr)
			 | _ =>
			       ("Gtk."^cvtGtkName(class)^"NewFromStock", SOME ("\""^l^"\",Helpers.accelGroup"), psr))
		| (_, psr) =>
		  (case class of
		       "GtkListItem" =>
		       ("Gtk."^cvtGtkName(class)^"NewWithLabel", SOME ("\""^l^"\""), psr)
		     | _ =>
		       ("Gtk."^cvtGtkName(class)^"NewWithMnemonic", SOME ("\""^l^"\""), psr)))
	   | (NONE, psr)   =>
	     ("Gtk."^cvtGtkName(class)^"New", NONE, psr))

    (* emits code for a GtkAdjustment *)
    fun newAdjustment(doc, id, prop) =
	let
	    val (adjustment, psr) = forceGetProp(prop, "adjustment")
	    val adjustment = insertStr ","
				       (map (fn x => realString (SOME x))
					    (String.tokens (fn x => x= #" ")
							   adjustment))
	in
	    output(doc, "val "^id^" = Gtk.adjustmentNew("^adjustment^")\n");
	    psr
	end

    (* Emit code for object creation *)
    fun newObject'(doc, "GtkWindow", id, prop, access, sign, accel) =
	let
	    val (typ, psr) = forceGetProp(prop, "type")
	in
	    output(doc, "val "^id^" = Gtk.windowNew(Gtk."^
			cvtGtkName(typ)^")\n");
	    processProperties(doc, "GtkWindow", id, psr);
	    output(doc, "val _ = Gtk.windowAddAccelGroup("^id^",Helpers.accelGroup)\n");
	    processAccelerators(doc, "GtkWindow", id, accel)
	end
      | newObject'(doc, "GtkLabel", id, prop, access, sign, accel) =
	let
	    val (label, psr) = forceGetProp(prop, "label")
	in
	    output(doc, "val "^id^" = Gtk.labelNew(\""^
			label^"\")\n");
	    processProperties(doc, "GtkLabel", id, psr);
	    processAccelerators(doc, "GtkLabel", id, accel)
	end
      | newObject'(doc, "GtkFrame", id, prop, access, sign, accel) =
	let
	    val (lxalign, psr) = getRealProp(prop, "label_xalign")
	    val (lyalign, psr) = getRealProp(psr,  "label_yalign")
	in
	    output(doc, "val "^id^" = Gtk.frameNew(\"\")\n");
	    if lxalign<>"0.0" andalso lyalign<>"0.0" then
		output(doc, "val _ = Gtk.frameSetLabelAlign("^id^","^
			    lxalign^","^lyalign^")\n")
	    else ();
	    processProperties(doc, "GtkFrame", id, psr);
	    processAccelerators(doc, "GtkFrame", id, accel)
	end
      | newObject'(doc, class as ("GtkVBox" | "GtkHBox"),
		   id, prop, access, sign, accel) =
	let
	    val (homogeneous, psr) = getBoolProp(prop, "homogeneous")
	    val (spacing, psr)     = forceGetProp(psr, "spacing")
	in
	    output(doc, "val "^id^" = Gtk."^cvtGtkName(class)^
			"New("^homogeneous^","^spacing^")\n");
	    processProperties(doc, class, id, psr);
	    processAccelerators(doc, class, id, accel)
	end
      | newObject'(doc, "GtkTable", id, prop, access, sign, accel) =
	let
	    val (rows, psr) = getIntProp(prop, "n_rows")
	    val (cols, psr) = getIntProp(psr, "n_columns")
	    val (homogeneous, psr) = getBoolProp(psr, "homogeneous")
	in
	    output(doc, "val "^id^" = Gtk.tableNew("^
			rows^","^cols^","^homogeneous^")\n");
	    processProperties(doc, "GtkTable", id, psr);
	    processAccelerators(doc, "GtkTable", id, accel)
	end
      | newObject'(doc, class as "GtkRadioButton",
		   id, prop, access, sign, accel) =
	let
	    val (constr, label, psr) = getConstructor(class, prop)
	    val (group, psr) = getProp(psr, "group")
	    val label = case label of SOME l => ","^l
				    | _ => ""
	in
	    case group of
		SOME g =>
		output(doc, "val "^id^" = "^constr^"FromWidget("^g^label^")\n")
	      | NONE => 
		output(doc, "val "^id^" = "^constr^"(Gtk.NULL"^label^")\n");
	    processProperties(doc, class, id, psr);
	    processAccelerators(doc, class, id, accel)
	end
      | newObject'(doc, class as "GtkRadioMenuItem",
		   id, prop, access, sign, accel) =
	let
	    val (constr, label, psr) = getConstructor(class, prop)
	    val label = case label of SOME l => ","^l
				    | _ => ""
	in
	    output(doc, "val "^id^" = "^constr^"(Gtk.NULL"^label^")\n");
	    processProperties(doc, class, id, psr);
	    processAccelerators(doc, class, id, accel)
	end
      | newObject'(doc, "GtkSpinButton", id, prop, access, sign, accel) =
	let
	    val psr = newAdjustment(doc, id^"_adj", prop)
	    val (climb_rate, psr) = getRealProp(psr, "climb_rate")
	    val (digits, psr) = getIntProp(psr, "digits")
	in
	    output(doc, "val "^id^" = Gtk.spinButtonNew("^id^"_adj,"^
			climb_rate^","^digits^")\n")
	end
      | newObject'(doc, "GtkImage", id, prop, access, sign, accel) =
	let
	    val (stock, psr) = getProp(prop, "stock")
	    val (icon_size, psr) = getIntProp(psr, "icon_size")
	in
	    case stock of
		SOME s =>
		(output(doc, "val "^id^" = Gtk.imageNewFromStock("
			     ^"\""^s^"\","^
			     "Gtk.IntToGtkIconSize("^icon_size^"))\n");
		 processProperties(doc, "GtkImage", id, psr);
		 processAccelerators(doc, "GtkImage", id, accel))
	      | NONE => ()
	end
      | newObject'(doc, "GtkList", id, prop, access, sign, accel) = ()
      | newObject'(doc, "Custom", id, prop, access, sign, accel) = ()
      | newObject'(doc, "GtkScrolledWindow", id, prop, access, sign, accel) =
        let
            val (width, psr)  = getIntProp(prop, "width_request")
            val (height, psr) = getIntProp(psr, "height_request")
        in
            output(doc, "val "^id^"_xa = Gtk.adjustmentNew(0.0,0.0,"^
                        width^".0"^",1.0,"^width^".0,"^width^".0)\n");
            output(doc, "val "^id^"_ya = Gtk.adjustmentNew(0.0,0.0,"^
                        height^".0"^",1.0,"^height^".0,"^height^".0)\n");
            output(doc, "val "^id^" = "^"Gtk.scrolledWindowNew("^
                        id^"_xa,"^id^"_ya)\n");

            (* process full properties, we just abused width&height! *)
            processProperties(doc, "GtkScrolledWindow", id, prop);
	    processAccelerators(doc, "GtkScrolledWindow", id, accel)
        end
      | newObject'(doc, class as ("GtkVScale" | "GtkHScale"), id,
                   prop, access, sign, accel) =
        let
            val (a1,a2,a3,a4,a5,a6,psr) = getAdjProp(prop, "adjustment")
        in
            output(doc, "val "^id^"_adj = Gtk.adjustmentNew("^
                        a1^","^a2^","^a3^","^a4^","^a5^","^a6^")\n");
            output(doc, "val "^id^" = Gtk."^cvtGtkName class^"New("^
                        id^"_adj)\n");
            processProperties(doc, class, id, psr);
	    processAccelerators(doc, class, id, accel)
        end
      | newObject'(doc, class, id, prop, access, sign, accel) =
	let
	    val (constr, label, psr) = getConstructor(class, prop)
	    val label = getOpt(label, "")
	in
	    output(doc, "val "^id^" = "^constr^"("^label^")\n");
	    processProperties(doc, class, id, psr);
	    processAccelerators(doc, class, id, accel)
	end
	
    fun newObject(doc, class, id, prop, access, sign, accel) =
         newObject'(doc, class, cvtId(id), prop, access, sign, accel)

    fun makeChildrenList children =
	"["^(insertStr "," (List.map (fn (c,_) => c) children))^"]"

    (* Attach children to container etc. *)
    fun attachBoxChild (doc,id) (c, nil) =
	output(doc, "val _ = Gtk.boxPackStart("^id^","^c^",true,true,0)\n")
      | attachBoxChild (doc,id) (c, props) =
	let
	    val (expand, psr) = getBoolProp(props, "expand")
	    val (fill, psr)   = getBoolProp(psr, "fill")
	    val (padding, psr) = getIntProp(psr, "padding")
	    val (packType, psr) = getProp(psr, "pack_type")
	    val packType = case packType of
			       SOME "GTK_PACK_END" => "End"
			     | _ => "Start"
	in
	    output(doc, "val _ = Gtk.boxPack"^packType^
			"("^id^","^c^","^expand^","^
			fill^","^padding^")\n")
	end
    fun attachFrameChild (doc,id) (c,nil) =
	output(doc, "val _ = Gtk.containerAdd("^id^","^c^")\n")
      | attachFrameChild (doc,id) (c,props) =
	case getProp(props, "type") of
	    (SOME "label_item", psr) =>
	    output(doc, "val _ = Gtk.frameSetLabelWidget("^id^","^c^")\n")
	  | _ =>
	    output(doc, "val _ = Gtk.containerAdd("^id^","^c^")\n")
    fun attachTableChild (doc, id) (c, props) =
	let
	    val (left_attach, psr) = getIntProp(props, "left_attach")
	    val (right_attach, psr) = getIntProp(psr, "right_attach")
	    val (top_attach, psr) = getIntProp(psr, "top_attach")
	    val (bottom_attach, psr) = getIntProp(psr, "bottom_attach")
	in
	    output(doc, "val _ = Gtk.tableAttach("^id^","^c^","^
			left_attach^","^right_attach^","^
			top_attach^","^bottom_attach^
			",Gtk.FILL,Gtk.FILL,0,0)\n")
	end
    fun attachFixedChild (doc, id) (c, props) =
	let
	    val (xpos, psr) = getIntProp(props, "x")
	    val (ypos, psr) = getIntProp(psr, "y")
	in
	    output(doc, "val _ = Gtk.fixedPut("^id^","^c^","^
			xpos^","^ypos^")\n")
	end
    fun attachNotebookChildren(doc, id, _, nil) = ()
      | attachNotebookChildren(doc, id, n, (c,props)::ps) =
	case getProp(props, "type") of
	    (SOME "tab", psr) =>
	    (output(doc,
		    "val _ = Gtk.notebookSetTabLabel("^
		    id^",Gtk.notebookGetNthPage("^
		    id^","^Int.toString n^"),"^c^")\n");
	     attachNotebookChildren(doc, id, n+1, ps))
	  | (_, psr) =>
	    let
		val (expand,psr) = getBoolProp(props, "tab_expand")
		val (fill, psr)  = getBoolProp(psr, "tab_fill")
	    in
		output(doc, "val _ = Gtk.containerAdd("^
			    id^","^c^")\n");
		attachNotebookChildren(doc, id, n, ps)
	    end
    fun attachPaneChildren(doc, class, id, [(c1,p1),(c2,p2)]) =
	let
	    val (shrink1, psr1) = getBoolProp(p1, "shrink")
	    val (resize1, psr1) = getBoolProp(psr1, "resize")
	    val (shrink2, psr2) = getBoolProp(p2, "shrink")
	    val (resize2, psr2) = getBoolProp(psr2, "resize")
	in
	    output(doc,
		   "val _ = Gtk.panedPack1("^id^","^c1^","^
		   resize1^","^shrink1^")\n");
	    output(doc,
		   "val _ = Gtk.panedPack2("^id^","^c2^","^
		   resize2^","^shrink2^")\n")
	end
      | attachPaneChildren _ = raise CodeEmitterError "Pane must have exactly 2 children"

    fun attachComboChildren(doc, id, [_,(l,_)]) =
	output(doc,
	       "val _ = List.app "^
	       "(fn c => Gtk.containerAdd(Gtk.comboGetFieldList "^id^","^
	       "c)) "^l^"\n")
      | attachComboChildren _ = raise CodeEmitterError "Combo must have exactly 2 children"
    fun attachChildren'(doc, ("GtkHBox"
			     | "GtkVBox"
			     | "GtkButtonBox"
			     | "GtkBox"), id, children) =
	List.app (attachBoxChild(doc,id)) children
      | attachChildren'(doc, "GtkMenuItem", id, children) =
	List.app (fn (c,_) =>
		     output(doc, "val _ = Gtk.menuItemSetSubmenu("^
				 cvtId(id)^","^cvtId(c)^")\n"))
		 children
      | attachChildren'(doc, "GtkFrame", id, children) =
	List.app (attachFrameChild(doc,id)) children
      | attachChildren'(doc, "GtkTable", id, children) =
	List.app (attachTableChild(doc,id)) children
      | attachChildren'(doc, "GtkFixed", id, children) =
	List.app (attachFixedChild(doc,id)) children
      | attachChildren'(doc, "GtkNotebook", id, children) =
	attachNotebookChildren(doc,id,0,children)
      | attachChildren'(doc, "GtkCombo", id, children) =
	attachComboChildren(doc, id, children)
      | attachChildren'(doc, "GtkList", id, children) =
	output(doc, "val "^id^" = ["^
		    (insertStr "," (map (fn (x,y)=>x) children))^"]\n")
      | attachChildren'(doc, class as ("GtkHPaned"|"GtkVPaned"),
			id, children) =
	attachPaneChildren(doc, class, id, children)
      | attachChildren'(doc, "GtkImageMenuItem", id, nil) = ()
      | attachChildren'(doc, "GtkImageMenuItem", id, [(child,_)]) =
	output(doc, "val _ = Gtk.imageMenuItemSetImage("^id^","^child^")\n")
      | attachChildren'(_, "GtkImageMenuItem", _, _) =
	raise CodeEmitterError "GtkImageMenuItem can have none or one child"
      | attachChildren'(doc, "GtkOptionMenu", id, [(child,_)]) =
	output(doc,
	       "val _ = Gtk.optionMenuSetMenu("^id^","^
	       child^")\n")
      | attachChildren'(doc, "GtkOptionMenu", id, _) =
	raise CodeEmitterError "GtkOptionMenu requires exactly one child"
      | attachChildren'(_,_,_,nil) = ()
      | attachChildren'(doc, class, id, [(child,_)]) =
	output(doc, "val _ = Gtk.containerAdd("^
		    id^","^child^")\n")
      | attachChildren'(doc, class, id, children) =
	output(doc, "val _ = Helpers.containerAddList("^
		    id^","^makeChildrenList children^")\n");
    fun attachChildren(doc, class, id, children) =
	attachChildren'(doc, class, cvtId(id),
			map (fn (i,v) => (cvtId i,v)) children)

    fun attachSignals(doc,str,class,id,nil) = ()
      | attachSignals(doc,str,class,id,(n,h,a)::sr) =
	let
	    val h = cvtId h
	    val id = cvtId id
            val n = if n="delete_event" then "delete-event" else n
	in
	    if stringIsKnown(doc,h) then ()
	    else
		(outputSig(doc,
			   "val "^h^" : Gtk.callback_function\n");
		 rememberString(doc, h));
	    output(doc, "val "^id^"_"^h^" = Gtk.signalConnect"^
			(if a="yes" then "After" else "")^
			"("^str^"."^id^", \""^n^"\",S."^
			h^")\n");
	    attachSignals(doc,str,class,id,sr)
	end

    fun outputHelpers doc =
	(output(doc, "structure Helpers = struct\n");
	 indent(doc);
	 output(doc, "val accelGroup = Gtk.accelGroupNew()\n");
	 output(doc, "val tooltips = Gtk.tooltipsNew()\n");
	 output(doc, "fun containerAddList(cont, children) = \n");
	 indent(doc);
	 output(doc, "List.app (fn c => Gtk.containerAdd(cont,c)) children\n");
	 outdent(doc);
	 outdent(doc);
	 output(doc, "end\n\n"))

    (* Emit a pretty-printed comment *)
    fun comment' output (doc,[c]) = output(doc, "(* "^c^" *)\n")
      | comment' output (doc,nil) = output(doc, "(* *)\n")
      | comment' output (doc,cs) =
	let
	    fun com' nil = output(doc, " *)\n")
	      | com' (c::cs) =
		(output(doc, " * "^c^"\n");
		 com' cs)
	in
	    output(doc, "(*\n");
	    com' cs
	end
    val comment = comment' output
    val commentPre = comment' outputPre
    val commentSig = comment' outputSig

    (* Preamble, general stuff in the header *)
    fun preamble doc =
	(commentPre(doc,
		 ["This is a generated file, created by alice-glade.",
		  "Modifications may get lost."]);
	 outputPre(doc, "\n\n");
	 outputPre(doc,
		   "import structure Gtk from \"x-alice:/lib/gtk/Gtk\"\n");
	 outputPre(doc,
		   "import structure Gdk from \"x-alice:/lib/gtk/Gdk\"\n\n");
	 outputPre(doc,
		   "import structure Key from \"x-alice:/lib/gtk/Key\"\n\n"))

    fun preambleStruct doc =
	(output(doc, "structure "^getStructureName doc^" =\n");
	 indent(doc);
	 output(doc, "struct\n");
	 indent(doc))

    fun preambleFunct doc =
	(outputSig(doc,"signature "^cvtSigName(getStructureName doc)^
		       "_SIG =\n");
	 indentSig(doc);
	 outputSig(doc,"sig\n");
	 indentSig(doc);
	 output(doc, "functor "^getStructureName doc^
		     "(structure S : "^
		     cvtSigName(getStructureName doc)^"_SIG) =\n");
	 indent(doc);
	 output(doc, "struct\n");
	 indent(doc))

    fun preambleIncl(doc, str, f) =
	outputPre(doc,"import structure "^str^" from \""^f^"\"\n\n");

    (* Close the structure *)
    fun postambleStruct doc =
	(outdent(doc);
	 output(doc, "end\n");
	 outdent(doc);
	 output(doc, "\n");
	 comment(doc, ["Created by alice-glade"]))

    (* Close the structure *)
    fun postambleFunct doc =
	(outdentSig(doc);
	 outputSig(doc,"end\n\n");
	 outdent(doc);
	 output(doc, "end\n");
	 outdent(doc);
	 output(doc, "\n");
	 comment(doc, ["Created by alice-glade"]))

    fun new fileName =
	(ref (F (NONE, ref 0)), fileName, ref nil)

    fun newBuffered fileName =
	(ref (S ((ref (L ""),ref (L ""),ref (L "")),
		 (ref 0, ref 0, ref 0))), fileName, ref nil)

    fun close doc = case !(#1 doc) of
			F(SOME os, _) => 
			TextIO.closeOut os
		      | F (NONE,_) => ()
		      | S ((s1,s2,s3),_) =>
			(case (!s1,!s2,!s3) of
			    (L "", L "", L "") => ()
			  | (s1,s2,s3) =>
			    let
				val doc' = new (#2 doc)
			    in
				virtualApp (fn x => output(doc', x)) s1;
				virtualApp (fn x => output(doc', x)) s2;
				virtualApp (fn x => output(doc', x)) s3;
				close doc'
			    end)
			

  end
