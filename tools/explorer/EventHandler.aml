(*
 * Author:
 *   Guido Tack <tack@ps.uni-sb.de>
 *
 * Copyright:
 *   Guido Tack, 2003
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Gtk            from "x-alice:/lib/gtk/Gtk"
import structure Gdk            from "x-alice:/lib/gtk/Gdk"
import structure GnomeCanvas    from "x-alice:/lib/gtk/GnomeCanvas"

import structure Types          from "Types"
import structure Defaults       from "Defaults"
import structure TreeNode       from "TreeNode"
import structure VisualNode     from "VisualNode"
import structure GtkNode        from "GtkNode"
import structure ExplorerNode   from "ExplorerNode"
import structure ExplorerSearch from "ExplorerSearch"
import structure OptionsWindow  from "OptionsWindow"
import structure ExplorerGUI    from "ExplorerGUI"

structure EventHandler =
  struct

  open Types

  fun nodeEvent (state, serve) event =
      case (!state) of
	  SOME(state as ({canvas={canvas=canvas,...},tree=tree,
			  currentNode=currentNode,
			  inspect=inspect,
                          curInspAction=curInspAction,
			  scale=scale,...}:
			 Types.explorer_state)) =>
	  (case event of
	       (_, [Gdk.EVENT event]) =>
	       serve (fn () =>
                 case event of
		     Gdk.EVENT_BUTTON_PRESS {x=x,y=y,...} =>
		     let
			 val (findX, depth) =
                             GtkNode.findByXY(canvas,!scale,
					      x,y)
			 val t = !tree
			 val n = TreeNode.findByX (t, depth, 0, findX)
			 val (x,y) = TreeNode.getCenter n
		     in
                         case ExplorerNode.curNodeStatus n of
                             Types.FAILED => ()
                           | _ => 
			     (currentNode := SOME n;
			      GtkNode.drawShadow (state, x, y, n))
		     end
                   | Gdk.EVENT_2BUTTON_PRESS {x=x,y=y,...} =>
		     let
			 val (findX, depth) =
                             GtkNode.findByXY(canvas,!scale,
					      x,y)
			 val t = !tree
			 val n = TreeNode.findByX (t, depth, 0, findX)
			 val (x,y) = TreeNode.getCenter n
		     in
                         case ExplorerNode.curNodeStatus n of
                             (Types.FAILED | Types.UNKNOWN) => ()
                           | _ =>
                             if ExplorerNode.isHidden n then () else
			     (currentNode := SOME n;
			      GtkNode.drawShadow (state, x, y, n);
                              List.app
                                  (fn (i,s) => 
                                      if s= !curInspAction then
                                          i (ExplorerNode.recomputeSpace n)
                                      else ()) (!inspect))
		     end
		   | _ => ())
	     | _ => ())
	| _ => ()

  val itr = Real.fromInt

  fun destroyMainWindow (resetCanvas,
                         serve,
                         state as ref (SOME {window=window,rootSpace=rootSpace,
                                             tree=tree,...})
			 : explorer_state option ref) =
      (Gtk.widgetHide window;
       rootSpace := NONE;
       resetCanvas serve state;
       ExplorerNode.discardTree (!tree) )
    | destroyMainWindow _ = ()

  fun setBBox (ref (SOME ({canvas={canvas=canvas,...}, ...}: explorer_state)),
	       (minx, maxx, depth)) =
      let
	  val xMin   = Real.round((itr minx)* (TreeNode.defScale))
	  val xMax   = Real.round((itr maxx)* (TreeNode.defScale))
	  val xDim   = abs xMin + (abs xMax)
	  val yDim   = Real.round((itr((depth+1)*TreeNode.verSpaceI) *
				   TreeNode.defScale))
      in
	  GnomeCanvas.setScrollRegion(canvas, itr xMin, 0.0,
				      itr xMax, Real.fromInt yDim)
      end
    | setBBox _ = ()

  fun refresh (cmw, serve, state) =
      case !state of
          (SOME (rstate as {canvas={canvas=canvas,...},
                            window=window,
                            tree=ref tree,
                            scale=ref scale,
			    currentNode=ref cn,
                            ...}
		 : explorer_state)) =>
          let
	      val shape = TreeNode.layoutNode tree
	      val (minx, maxx, depth) = TreeNode.getBBox shape
          in
              Gtk.widgetShowAll window;
              setBBox (state, (minx, maxx, depth));
              Gtk.layoutFreeze canvas;
	      VisualNode.adjust (rstate, tree, 0, 0, TreeNode.verSpaceI, 0);
	      (case cn of NONE => ()
		        | SOME cn =>
		          let
			      val (x,y) = TreeNode.getCenter cn
		          in
			      GtkNode.drawShadow (rstate, x, y, cn)
		          end);
              Gtk.layoutThaw canvas;
              GnomeCanvas.setPixelsPerUnit(canvas,
                                           scale*Defaults.floatScaleBase)
          end
        | NONE =>(state := !(cmw serve);
		  refresh (cmw, serve, state))

  fun refreshAfterSearch (node, cmw) (serve, state) =
      (VisualNode.hideFailed node; refresh (cmw, serve, state))

  fun exitHandler (resetCanvas, serve, state) _ =
      serve (fn () => destroyMainWindow (resetCanvas, serve, state))
  fun nodeHideHandler (cmw, serve, state) _ = 
      serve (fn () =>
		(VisualNode.toggleHide state;
		 refresh (cmw, serve, state)))
  fun nodeUnhideHandler (cmw, serve, state) _ =
      serve (fn () =>
                case !state of
                    SOME {tree=ref tree,currentNode=ref cn,...} =>
		    (VisualNode.unhideAll (Option.getOpt(cn,tree));
		     refresh (cmw, serve, state))
                  | _ => ())
  fun hideFailedHandler (cmw, serve, state) _ =
      serve (fn () =>
                case !state of
                    SOME {tree=ref tree,currentNode=ref cn,...} =>
		    (VisualNode.hideFailed (Option.getOpt(cn,tree));
		     refresh (cmw, serve, state))
                  | _ => ())

  fun exploreOneHandler (cmw, serve, state) _ =
      serve (fn () =>
                case !state of
                    SOME {currentNode=ref (SOME cn),...} =>
                    ExplorerSearch.search
                        (serve, state, refreshAfterSearch (cn, cmw),
                         1, SOME cn)
                  | _ => ())

  fun exploreAllHandler (cmw, serve, state) _ =
      serve (fn () =>
                case !state of
                    SOME {currentNode=ref (SOME cn),...} =>
                    ExplorerSearch.search
                        (serve, state, refreshAfterSearch (cn, cmw),
                         0, SOME cn)
                  | _ => ())

  fun exploreNHandler (cmw, serve, state) _ =
      serve (fn () =>
                case !state of
                    SOME {currentNode=ref (SOME cn),breakAfter=ref breakAfter,
                          ...} =>
                    ExplorerSearch.search
                        (serve, state, refreshAfterSearch (cn, cmw),
                         breakAfter, SOME cn)
                  | _ => ())
                                                
  fun resetHandler (cmw, resetCanvas, serve, state) _ =
      serve (fn () =>
                case !state of
                    SOME {rootSpace=ref (SOME rs),...} =>
                    ExplorerSearch.initSearch (serve, state,
                                               fn (x,y) => refresh (cmw,x,y),
                                               resetCanvas, rs)
                  | _ => ())

  fun selectInspectionAction (serve,
                              state : explorer_state option ref) event = 
      serve (fn () =>
                case !state of
                    SOME {curInspAction=curInspAction,...} =>
                    (case event of (obj, _) =>
                       if (Gtk.checkMenuItemGetFieldActive obj)=1 then
                           let
                               val label = Gtk.binGetChild obj
                           in
                               curInspAction := Gtk.labelGetText label
                           end
                       else
                           ())
                  | _ => ())

  fun viewOptionsHandler (mw, serve, state) _ =
      let
          val configure = OptionsWindow.newOptionsWindow (mw, serve, state)
      in
          Gtk.windowSetPosition(configure, Gtk.WIN_POS_MOUSE);
          Gtk.widgetShowAll configure
      end

  fun debugHandler (serve, state) _ =
      serve (fn () =>
                case !state of
                    SOME {debug=debug,...} =>
                    Types.setDebug state (not (!debug))
                  | NONE => ())


  fun zoomToFitHandler (serve, state : Types.explorer_state option ref) _ =
      serve (fn () =>
                case !state of
                    SOME {canvas={canvas=canvas,...},tree=ref tree,
                          scale=scale,...} =>
                    let
                        val shape = TreeNode.getShape tree
	                val (minx, maxx, depth) = TreeNode.getBBox shape
	                val xSize = Gtk.adjustmentGetFieldPageSize
                                        ExplorerGUI.scrolledwindow_xa
	                val ySize = Gtk.adjustmentGetFieldPageSize
                                        ExplorerGUI.scrolledwindow_ya
	                val xMin   = Real.round((itr minx)*(TreeNode.defScale))
	                val xMax   = Real.round((itr maxx)*(TreeNode.defScale))
	                val xDim   = itr (abs xMin + (abs xMax))
	                val yDim   = (itr((depth+1)*TreeNode.verSpaceI) *
				      TreeNode.defScale)

                        val xScale = ySize / yDim
                        val yScale = xSize / xDim

                        val scaleTo = Real.min(xScale,yScale)
                        val scaleTo = Real.max(0.1,scaleTo)
                        val scaleTo = Real.min(3.0,scaleTo)
                    in
		        GnomeCanvas.setPixelsPerUnit(canvas, scaleTo);
                        Gtk.rangeSetValue(ExplorerGUI.scale,scaleTo);
		        scale := scaleTo / Defaults.floatScaleBase
                    end
                  | _ => ())
end
