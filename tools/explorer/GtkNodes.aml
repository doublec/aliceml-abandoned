(*
 * Authors:
 *   Guido Tack <tack@ps.uni-sb.de>
 *
 * Copyright:
 *   Guido Tack, 2004
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure TreeNode  from "TreeNode"
import structure Gtk       from "x-alice:/lib/gtk/Gtk"
import structure Gdk       from "x-alice:/lib/gtk/Gdk"
import structure GnomeCanvas from "x-alice:/lib/gtk/GnomeCanvas"

import structure Types from "Types"

structure GtkNode =
struct
  val map   = Gdk.colormapGetSystem ()
  val black = Gdk.colorNew(0,0,0)
  val blue  = Gdk.colorNew(100*256,112*256,255*256)
  val red   = Gdk.colorNew(238*256,44*256,44*256)
  val green = Gdk.colorNew(60*256,179*256,113*256)
  val white = Gdk.colorNew(65535, 65535, 65535)
  val gray  = Gdk.colorNew(30000, 30000, 30000)
  val lightgray = Gdk.colorNew(60000,60000,60000)
  val _     = Gdk.colormapAllocColor(map, black, false, true)
  val _     = Gdk.colormapAllocColor(map, white, false, true)
  val _     = Gdk.colormapAllocColor(map, blue,  false, true)
  val _     = Gdk.colormapAllocColor(map, red,   false, true)
  val _     = Gdk.colormapAllocColor(map, green,  false, true)
  val _     = Gdk.colormapAllocColor(map, gray,  false, true)

  val succColor = green
  val failedColor = red
  val choiceColor = blue

  val shadowColor = gray

  val itr = Real.fromInt

  fun makeGroup parent =
      GnomeCanvas.itemCreate(parent,
			     GnomeCanvas.groupGetType(),
			     [("x", Gtk.REAL 0.0),
			      ("y", Gtk.REAL 0.0)])

  fun drawHidden group shadow scale myX myY =
      let
	  val color = if shadow then shadowColor else failedColor
	  val outline = if shadow then shadowColor else black
	  val width = Real.round(10.0*256.0*scale)
	  val sHorSpace = Real.round((itr TreeNode.horSpaceI)*scale/2.0)
	  val sVerSpace = Real.round((itr TreeNode.verSpaceI)*scale)
	  val x0 = myX
	  val y0 = myY - width
	  val x1 = myX - sHorSpace
	  val y1 = myY + sVerSpace
	  val x2 = myX + sHorSpace
	  val y2 = myY + sVerSpace
	  val points = [x0,y0,x1,y1,x2,y2,x0,y0]
      in
	  (GnomeCanvas.itemCreate(group,
				  GnomeCanvas.polygonGetType(),
				  [("points", Gtk.OBJECT
						  (GnomeCanvas.makePoints points)),
				   ("fill_color_gdk", Gtk.OBJECT color),
				   ("outline_color_gdk", Gtk.OBJECT outline)
				   ]
				  ))	  
      end

  fun drawSuccNode group shadow scale myX myY =
      let
	  val color = if shadow then shadowColor else succColor
	  val outline = if shadow then shadowColor else black
	  val width = Real.round(10.0*256.0*scale)
	  val x0 = myX - width
	  val x1 = myX
	  val x2 = myX + width
	  val y0 = myY - width
	  val y1 = myY
	  val y2 = myY + width
	  val points = [x0,y1,x1,y0,x2,y1,x1,y2,x0,y1,x0,y1]
      in
	  (GnomeCanvas.itemCreate(group,
				  GnomeCanvas.polygonGetType(),
				  [("points", Gtk.OBJECT
						  (GnomeCanvas.makePoints points)),
				   ("fill_color_gdk", Gtk.OBJECT color),
				   ("outline_color_gdk", Gtk.OBJECT outline)
				   ]
				  ))	  
      end

  fun drawFailedNode group shadow scale myX myY =
      let
	  val color = if shadow then shadowColor else failedColor
	  val outline = if shadow then shadowColor else black
	  val width = 7.0*256.0*scale
	  val x1 = (itr myX) - width
	  val y1 = (itr myY) - width
	  val x2 = (itr myX) + width
	  val y2 = (itr myY) + width
      in
	  GnomeCanvas.itemCreate(group,
				 GnomeCanvas.rectGetType(),
				 [("x1", Gtk.REAL x1),
				  ("y1", Gtk.REAL y1),
				  ("x2", Gtk.REAL x2),
				  ("y2", Gtk.REAL y2),
				  ("fill_color_gdk", Gtk.OBJECT color),
				  ("outline_color_gdk", Gtk.OBJECT outline)
				  ])
      end

  fun drawChoiceNode group shadow scale myX myY =
      let
	  val color = if shadow then shadowColor else choiceColor
	  val outline = if shadow then shadowColor else black
	  val scaledCircleWidth = 10.0*256.0*scale

	  val x1 = (itr myX) - scaledCircleWidth
	  val y1 = (itr myY) - scaledCircleWidth
	  val x2 = (itr myX) + scaledCircleWidth
	  val y2 = (itr myY) + scaledCircleWidth
      in
	  GnomeCanvas.itemCreate(group,
				 GnomeCanvas.ellipseGetType(),
				 [("x1", Gtk.REAL x1),
				  ("y1", Gtk.REAL y1),
				  ("x2", Gtk.REAL x2),
				  ("y2", Gtk.REAL y2),
				  ("fill_color_gdk", Gtk.OBJECT color),
				  ("outline_color_gdk", Gtk.OBJECT outline)
				  ])
      end

  fun drawUnknownNode group shadow scale myX myY =
      let
	  val color = if shadow then shadowColor else lightgray
	  val outline = if shadow then shadowColor else black
          val origWidth = 10.0*256.0*scale
	  val scaledCircleWidth = 10.0*256.0*scale*0.7
          val diff = origWidth - scaledCircleWidth

	  val x1 = (itr myX) - scaledCircleWidth
	  val y1 = (itr myY) - scaledCircleWidth - diff
	  val x2 = (itr myX) + scaledCircleWidth
	  val y2 = (itr myY) + scaledCircleWidth - diff
      in
	  GnomeCanvas.itemCreate(group,
				 GnomeCanvas.ellipseGetType(),
				 [("x1", Gtk.REAL x1),
				  ("y1", Gtk.REAL y1),
				  ("x2", Gtk.REAL x2),
				  ("y2", Gtk.REAL y2),
				  ("fill_color_gdk", Gtk.OBJECT color),
				  ("outline_color_gdk", Gtk.OBJECT outline)
				  ])
      end

  fun connect
	  (state as ({canvas={rootGroup=ref rootGroup,...},...} : Types.explorer_state))
	  hidden myStatus parentStatus myX myY momX momY =
      let
	  val scale = TreeNode.defScale
	  val s = 7*256
	  val t = 10*256
	  val (x1,y1) = if hidden then ((itr myX)*scale,(itr (myY-t))*scale)
			else case myStatus of
			    TreeNode.FAILED => ((itr myX)*scale,(itr (myY-s))*scale)
			  | TreeNode.SOLVED => ((itr myX)*scale,(itr (myY-t))*scale)
			  | TreeNode.CHOICE => ((itr myX)*scale,(itr (myY-t))*scale)
			  | TreeNode.UNKNOWN => ((itr myX)*scale,(itr (myY-t))*scale)
	  val (x2, y2) = case parentStatus of
			     TreeNode.FAILED => ((itr momX)*scale,(itr (momY+s))*scale)
			   | TreeNode.SOLVED => ((itr momX)*scale,(itr (momY+t))*scale)
			   | TreeNode.CHOICE => ((itr momX)*scale,(itr (momY+t))*scale)
			   | TreeNode.UNKNOWN => ((itr momX)*scale,(itr (momY+t))*scale)

	  val points = [Real.round x1,Real.round y1,Real.round x2,Real.round y2]
      in
	  (GnomeCanvas.itemCreate(rootGroup,
				  GnomeCanvas.lineGetType(),
				  [("points",
				    Gtk.OBJECT (GnomeCanvas.makePoints points)),
				   ("fill_color_gdk", Gtk.OBJECT black),
				   ("line_style", Gtk.INT 0),
				   ("width_pixels", Gtk.INT 1)
				   ]
				  ))	  
      end

  fun unconnect connection = Gtk.objectDestroy connection

  fun doDraw group shadow scale hidden status x y =
      let
	  val realX = (itr x)*scale
	  val realY = (itr y)*scale
	  val draw = if hidden then drawHidden
		     else case status of
			      TreeNode.FAILED => drawFailedNode
			    | TreeNode.SOLVED => drawSuccNode
			    | TreeNode.CHOICE => drawChoiceNode
			    | TreeNode.UNKNOWN => drawUnknownNode
      in
	  draw group shadow scale (Real.round realX) (Real.round realY)
      end

  fun drawNode 
	  (state as {canvas={canvas=canvas,rootGroup=rootGroup,actionGroup=actionGroup,...},
                     scale=scale,...}
	   : Types.explorer_state)
	  momX momY
	  (TreeNode.N({offset=offset,status=ref status,hidden=ref hidden,dirty=dirty,
		       vNode=vNode,connection=connection,...},
		      ref parent, ref children)) =
	  let
	      val myX = momX+(!offset)
	      val myY = momY+TreeNode.verSpaceI
	  in
	      dirty := false;
	      connection :=
	      (Option.map(fn p =>
			     (connect state hidden status
				      (TreeNode.getStatus p)
				      myX myY momX momY))
			 parent);
	      vNode := SOME (doDraw (!actionGroup) false
				    TreeNode.defScale hidden status myX myY);
	      if hidden then ()
	      else Vector.app (drawNode state myX myY) children
	  end

  fun markNode (state as {canvas={canvas=canvas,rootGroup=rootGroup,actionGroup=actionGroup,...},
                          scale=scale,...}
	        : Types.explorer_state)
	       (TreeNode.N({offset=offset,status=ref status,hidden=ref hidden,dirty=dirty,
		            vNode=vNode,connection=connection,...},
		           ref parent, ref children)) =
               case !vNode of
                   SOME v =>
                   let
                       val (x1,y1,x2,y2) = GnomeCanvas.itemGetBounds v
                   in
	               GnomeCanvas.itemCreate(GnomeCanvas.root canvas,
				              GnomeCanvas.ellipseGetType(),
				              [("x1", Gtk.REAL x1),
				               ("y1", Gtk.REAL y1),
				               ("x2", Gtk.REAL x2),
				               ("y2", Gtk.REAL y2),
				               ("fill_color_gdk", Gtk.OBJECT black),
				               ("outline_color_gdk", Gtk.OBJECT black)
				               ]);
                       ()
                   end
                 | NONE => ()

  fun drawShadow
	  (state as {canvas={canvas=canvas,rootGroup=rootGroup,shadowGroup=shadowGroup,...},
                     scale=scale,...}
	   : Types.explorer_state)
	  myX myY
	  (TreeNode.N({offset=offset,status=ref status,hidden=ref hidden,dirty=dirty,
		       vNode=vNode,connection=connection,...},
		      ref parent, ref children)) =
	  let
	      val myX = myX+3*256
	      val myY = myY+3*256
	  in
	      Gtk.objectDestroy (!shadowGroup);
	      shadowGroup := makeGroup (!rootGroup);
	      doDraw (!shadowGroup) true TreeNode.defScale hidden status myX myY;
	      GnomeCanvas.itemLowerToBottom (!shadowGroup)
	  end

  fun undrawSubtree (Types.N({vNode=vNode,connection=connection,...},_,children)) =
      case (!vNode) of
	  NONE => ()
	| SOME v =>
	  (vNode := NONE;
	   Gtk.objectDestroy v;
	   (case (!connection) of NONE => ()
				| SOME c => (Gtk.objectDestroy c;
					     connection:=NONE));
	   Vector.app undrawSubtree (!children))

  fun moveNode ({scale=ref scale,...}: Types.explorer_state)
	       (v, myByX) =
	       GnomeCanvas.itemMove(v, (Real.fromInt myByX)*TreeNode.defScale, 0.0)

  fun moveTree (state: Types.explorer_state)
	       (Types.N({connection=connection,vNode=vNode,...},_,ref children),
		myByX) =
	       ((case (!vNode) of NONE => ()
				| SOME v => moveNode state (v, myByX));
		(case (!connection) of NONE => ()
				     | SOME c => moveNode state (c, myByX));
		Vector.app (fn k => moveTree state (k, myByX)) children)

  fun findByXY(canvas, scale, x, y) =
      let
	  val (cXI, cYI) = GnomeCanvas.w2c(canvas, x, y)
	  val (sox1, _, _, _) = GnomeCanvas.getScrollRegion canvas

	  val cX = (Real.fromInt cXI)/scale
	  val cY = (Real.fromInt cYI)
	  val myX = cX + (sox1*256.0)
	  val findX = Real.round(myX-11.0*256.0)
	  val depth = Real.round(cY/(scale*38.0*256.0))-1
      in
	  (findX, depth)
      end

end