import structure AliceIdeGUI from "AliceIdeGUI"
import structure Gtk from "x-alice:/lib/gtk/Gtk"
import structure Gdk from "x-alice:/lib/gtk/Gdk"
import structure Key from "x-alice:/lib/gtk/Key"
import structure Inspector from "x-alice:/lib/tools/Inspector"

structure AliceIde =
    struct
        val progoutP = ref (Promise.promise())
        val compileroutP = ref (Promise.promise())

        val progOut : string list = Promise.future (!progoutP)
        val compilerOut : string list = Promise.future (!compileroutP)

        val curtextview = ref AliceIdeGUI.scratchpad
        val clipboard = Gtk.clipboardGet(Gdk.atomIntern("CLIPBOARD", false))

        val numberOfPages = ref 1
        val currentPage = ref 0

        val feedParagraphHiddenMenu = Gtk.menuItemNewWithMnemonic("Special Paragraph")

        fun write stream text =
            let
                val p = Promise.promise()
            in
                Promise.fulfill(!stream, text::Promise.future p);
                stream := p
            end

        fun feedFile() =
            let
                val buf = Gtk.textViewGetBuffer (!curtextview)
                val startiter = Gtk.textIterNew()
                val _ = Gtk.textBufferGetStartIter(buf,startiter)
                val enditer = Gtk.textIterNew()
                val _ = Gtk.textBufferGetEndIter(buf,enditer)
                val str = Gtk.textBufferGetText(buf, startiter, enditer, false)
            in
                Gtk.textIterFree startiter;
                Gtk.textIterFree enditer;
                write compileroutP str
            end

        fun feedSelection() =
            let
                val buf = Gtk.textViewGetBuffer (!curtextview)
                val startiter = Gtk.textIterNew()
                val enditer = Gtk.textIterNew()
                val sel = Gtk.textBufferGetSelectionBounds(buf,
                                                           startiter,enditer)
            in
                if sel then
                    write compileroutP
                          (Gtk.textBufferGetText(buf, startiter, enditer, false))
                else ();
                Gtk.textIterFree startiter;
                Gtk.textIterFree enditer
            end
                
        fun feedLine() =
            let
                val buf = Gtk.textViewGetBuffer (!curtextview)
                val cursor = Gtk.textBufferGetInsert(buf)
                val startiter = Gtk.textIterNew()
                val _ = Gtk.textBufferGetIterAtMark(buf,startiter,cursor)
                val enditer = Gtk.textIterCopy(startiter)
                val _ = Gtk.textIterSetLineOffset(startiter, 0)
                val _ = Gtk.textIterForwardToLineEnd(enditer)
                val str = Gtk.textBufferGetText(buf, startiter, enditer, false)
            in
                Gtk.textIterFree startiter;
                Gtk.textIterFree enditer;
                write compileroutP str
            end


        fun findNextEOL iter next =
            if next iter then
                let
                    val c = chr (Gtk.textIterGetChar iter)
                in
                    if c = #"\n" then ()
                    else if Char.isSpace c then findNextEOL iter next
                    else findEOP iter next
                end
            else ()
        and findEOP iter next =
            let
                val c = Gtk.textIterGetChar iter
            in
                if c=0 then ()
                else
                    if c=ord #"\n" then
                        findNextEOL iter next
                    else if next iter then
                        findEOP iter next
                    else ()
            end

        fun paragraphIters(buf) =
            let
                val cursor = Gtk.textBufferGetInsert(buf)
                val startiter = Gtk.textIterNew()
                val _ = Gtk.textBufferGetIterAtMark(buf,startiter,cursor)
                val c = Gtk.textIterGetChar startiter
                val _ = if c = ord #"\n" orelse c=0 then
                            Gtk.textIterBackwardChar startiter else false
                val enditer = Gtk.textIterCopy(startiter)
                val _ = findEOP startiter Gtk.textIterBackwardChar
                val _ = findEOP enditer Gtk.textIterForwardChar
            in
                (startiter, enditer)
            end

        fun feedParagraph() =
            let
                val buf = Gtk.textViewGetBuffer (!curtextview)
                val (startiter, enditer) = paragraphIters(buf)
                val str = Gtk.textBufferGetText(buf, startiter, enditer, false)
            in
                Gtk.textIterFree startiter;
                Gtk.textIterFree enditer;
                write compileroutP str
            end
            
        fun copy() =
            let
                val buf = Gtk.textViewGetBuffer (!curtextview)
            in
                Gtk.textBufferCopyClipboard(buf, clipboard)
            end

        fun paste() =
            let
                val buf = Gtk.textViewGetBuffer (!curtextview)
            in
                Gtk.textBufferPasteClipboard(buf, clipboard,
                                             Gtk.NULL, true)
            end

        fun cut() =
            let
                val buf = Gtk.textViewGetBuffer (!curtextview)
            in
                Gtk.textBufferCutClipboard(buf, clipboard, true)
            end

        fun delete() =
            let
                val buf = Gtk.textViewGetBuffer (!curtextview)
            in
                ignore (Gtk.textBufferDeleteSelection(buf, true, true))
            end

        fun new() =
            let
                val scrolledwindow2_xa = Gtk.adjustmentNew(0.0,0.0,0.0,1.0,0.0,0.0)
                val scrolledwindow2_ya = Gtk.adjustmentNew(0.0,0.0,0.0,1.0,0.0,0.0)
                val scrolledwindow2 = Gtk.scrolledWindowNew(scrolledwindow2_xa,scrolledwindow2_ya)
                val _ = Gtk.scrolledWindowSetShadowType(scrolledwindow2,Gtk.SHADOW_NONE)
                val _ = Gtk.widgetShow scrolledwindow2

                val newSource = Gtk.textViewNew()
                val _ = Gtk.widgetShow newSource
                val _ = Gtk.textViewSetEditable(newSource,true)
                val _ = Gtk.textViewSetJustification(newSource,Gtk.JUSTIFY_LEFT)
                val _ = Gtk.textViewSetWrapMode(newSource,Gtk.WRAP_NONE)
                val _ = Gtk.textViewSetCursorVisible(newSource,true)
                val _ = Gtk.textViewSetPixelsAboveLines(newSource,0)
                val _ = Gtk.textViewSetPixelsBelowLines(newSource,0)
                val _ = Gtk.textViewSetPixelsInsideWrap(newSource,0)
                val _ = Gtk.textViewSetLeftMargin(newSource,0)
                val _ = Gtk.textViewSetRightMargin(newSource,0)
                val _ = Gtk.textViewSetIndent(newSource,0)
                val _ = Gtk.textBufferSetText(Gtk.textViewGetBuffer newSource,"",~1)
                val _ = Gtk.containerAdd(scrolledwindow2,newSource)
                val label1 = Gtk.labelNew("New File"^Int.toString (!numberOfPages))
                val _ = Gtk.widgetShow label1
                val _ = Gtk.notebookAppendPage(AliceIdeGUI.notebook1,
                                               scrolledwindow2, label1)
            in
                numberOfPages := (!numberOfPages) + 1
            end

        fun switchPage(cur,view) = (currentPage := cur; curtextview := view)

        fun close () = if !currentPage=0 then ()
                       else (Gtk.notebookRemovePage(AliceIdeGUI.notebook1, !currentPage);
                             currentPage := Gtk.notebookGetCurrentPage AliceIdeGUI.notebook1)
        fun init () =
            let
                val buf = Gtk.textViewGetBuffer AliceIdeGUI.scratchpad
            in
                Gtk.windowAddAccelGroup(AliceIdeGUI.mainwidget,
                                        AliceIdeGUI.Helpers.accelGroup);
                Gtk.widgetAddAccelerator(AliceIdeGUI.feedparagraph, "activate",
                                         AliceIdeGUI.Helpers.accelGroup,
                                         Key.keyvalToInt Key.K_Return,
                                         Gdk.CONTROL_MASK, Gtk.ACCEL_LOCKED)
            end

    end
