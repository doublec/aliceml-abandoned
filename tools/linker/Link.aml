(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2002-2003
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Inf                from "../../lib/rtt/Inf"
import structure TextIO             from "../../lib/system/TextIO"
import structure OS                 from "../../lib/system/OS"
import structure IO                 from "../../lib/system/IO"
import structure Url                from "../../lib/system/Url"
import structure Resolver           from "../../lib/system/Resolver"
import structure FromEqHashable     from "../../lib/data/HASHABLE-sig"
import structure MkHashImpMap       from "../../lib/data/MkHashImpMap"
import structure MkDepthFirstSearch from "../../lib/utility/MkDepthFirstSearch"
import signature LINK               from "LINK-sig"
import structure MyComponent        from "MyComponent"

structure Link :> LINK =
struct
    datatype boundary =
	INCLUDE of string
      | EXCLUDE of string

    exception Empty
    exception Mismatch of Url.t * Url.t
    exception Conflict of Url.t
    exception Rewrite of Url.t * Url.t * Url.t
    exception Io of Url.t * exn

    structure UrlHashKey = FromEqHashable(Url)
    structure UrlMap = MkHashImpMap(UrlHashKey)

    fun infMatches (SOME j1, SOME j2) =
	((Inf.match (j1, j2); true) handle Inf.Mismatch _ => false)
      | infMatches (_, _) = true

    fun infIntersect (inf1, inf2) = SOME inf1   (*--** *)

    fun isExcluded (url, boundary) =
	isExcluded' (Url.toString url, boundary, 0, Vector.length boundary)
    and isExcluded' (s, boundary, i, n) =
	if i = n then true
	else
	    case Vector.sub (boundary, i) of
		INCLUDE s' => if String.isPrefix s' s then false
			      else isExcluded' (s, boundary, i + 1, n)
	      | EXCLUDE s' => if String.isPrefix s' s then true
			      else isExcluded' (s, boundary, i + 1, n)

    fun collect (boundary, typeCheck) root =
	let
	    val componentMap = UrlMap.map ()
	    val includeMap = UrlMap.map ()
	    val excludeMap = UrlMap.map ()

	    fun collect' (url, parent, expectedInf) =
		if UrlMap.member (componentMap, url) then
		    let
			val component =
			    UrlMap.lookupExistent (componentMap, url)
			val actualInf = MyComponent.inf component
		    in
			if typeCheck then
			    if infMatches (actualInf, expectedInf) then ()
			    else raise Mismatch (url, parent)
			else ()
		    end
		else if UrlMap.member (excludeMap, url) then
		    let
			val inf' = UrlMap.lookupExistent (excludeMap, url)
		    in
			case infIntersect (expectedInf, inf') of
			    SOME inf'' =>
				UrlMap.insert (excludeMap, url, inf'')
			  | NONE => raise Conflict url
		    end
		else if isExcluded (url, boundary) then
		    UrlMap.insert (excludeMap, url, expectedInf)
		else
		    (case MyComponent.load url of
			 NONE => (* native; exclude *)
			     UrlMap.insert (excludeMap, url, expectedInf)
		       | SOME component =>
			     include' (component, url, parent, expectedInf))
		    handle exn as IO.Io _ => raise Io (url, exn)
	    and include' (component, url, parent, expectedInf) =
		let
		    val actualInf = MyComponent.inf component
		    val _ = if typeCheck then
				if infMatches (actualInf, expectedInf) then ()
				else raise Mismatch (url, parent)
			    else ()
		    val component' =
			if url = root then component
			else MyComponent.stripImportInfs component
		    val _ = UrlMap.insert (componentMap, url, component')
		    val resolve = Url.resolve url
		    val importUrls =
			Vector.map
			    (fn (s, inf) =>
				let
				    val url' = resolve (Url.fromString s)
				in
				    collect' (url', url, inf); url'
				end) (MyComponent.imports component)
		in
		    UrlMap.insert (includeMap, url, importUrls)
		end
	in
	    collect' (root, Url.empty, NONE);
	    if UrlMap.isEmpty componentMap then raise Empty else ();
	    {componentMap, includeMap, excludeMap}
	end

    structure DepthFirstSearch =
	MkDepthFirstSearch(structure Key = UrlHashKey
			   structure Map = UrlMap)

    fun sort (includeMap, excludeMap) =
	let
	    val graph = UrlMap.map ()
	    val cyclic = ref false
	in
	    UrlMap.appi (fn (url, urls) =>
			    UrlMap.insert (graph, url, Vector.toList urls))
			includeMap;
	    UrlMap.appi (fn (url, _) => UrlMap.insert (graph, url, nil))
			excludeMap;
	    DepthFirstSearch.search graph
	end

    val trace =
	if Option.isSome (OS.Process.getEnv "ALICE_TRACE_REWRITE") then
	    (fn s => TextIO.output (TextIO.stdErr, "[rewrite] " ^ s))
	else ignore

    fun rewrite handlers url =
	(trace ("rewrite request: " ^ Url.toStringRaw url ^ "\n");
	 #1 (Option.valOf (Resolver.Handler.tracingApply trace url handlers)))

    fun build (root, componentMap, includeMap, excludeMap, rewritesMap) =
	let
	    fun getComponent url =
		UrlMap.lookupExistent (componentMap, url)
	    val includes =
		Vector.fromList
		    (UrlMap.foldi (fn (url, _, rest) => url::rest)
				  nil includeMap)
	    val excludes =
		Vector.fromList
		    (UrlMap.foldi (fn (url, _, rest) => url::rest)
				  nil excludeMap)
	    val urlToIndexMap = UrlMap.map ()
	    val _ =
		Vector.appi (fn (i, url) =>
				UrlMap.insert (urlToIndexMap, url, (true, i)))
			    includes
	    val _ =
		Vector.appi (fn (i, url) =>
				UrlMap.insert (urlToIndexMap, url, (false, i)))
			    excludes
	    val imports =
		Vector.map (fn url =>
			       (Url.toString (UrlMap.lookupExistent
						  (rewritesMap, url)),
				UrlMap.lookupExistent (excludeMap, url)))
			   excludes
	    val includeTable =
		Vector.map
		    (fn url =>
			let
			    val component = getComponent url
			    val importUrls =
				UrlMap.lookupExistent (includeMap, url)
			    val imports = MyComponent.imports component
			    val importSpec =
				Vector.map (fn url =>
					       let
						   val (included, index) =
						       UrlMap.lookupExistent
							   (urlToIndexMap, url)
					       in
						   (included, index)
					       end) importUrls
			in
			    (importSpec, MyComponent.body (getComponent url))
			end) includes
	    val (_, rootIndex) = UrlMap.lookupExistent (urlToIndexMap, root)
	    fun body imports =
		let
		    val strs = Vector.tabulate (Vector.length includeTable,
						fn _ => Hole.hole ())
		in
		    Vector.appi
			(fn (i, (importSpec, body)) =>
			    let
				val actuals =
				    Vector.map
				    (fn (included, index) =>
					Vector.sub (if included then strs
						    else imports, index))
				    importSpec
				val str = lazy body actuals
			    in
				Hole.fill (Vector.sub (strs, i), str)
			    end) includeTable;
			Vector.sub (strs, rootIndex)
		end
	    val inf = MyComponent.inf (getComponent root)
	in
	    MyComponent.component {imports, body, inf}
	end

    fun warnCycle urls =
	let
	    val ss = List.map (fn url => "   " ^ Url.toString url ^ "\n") urls
	in
	    TextIO.print ("WARNING: linked components have cyclic \
			  \inter-dependencies:\n" ^ String.concat ss)
	end

    fun link {root, verbose, typeCheck, boundary, rewrite = handlers} =
	let
	    val {componentMap, includeMap, excludeMap} =
		collect (boundary, typeCheck) root
	    val rewrite = rewrite handlers
	    val order = sort (includeMap, excludeMap)
	    val rewritesMap = UrlMap.map ()
	    val invRewritesMap = UrlMap.map ()
	in
	    UrlMap.appi (fn (url, _) =>
			    let
				val url' = rewrite url
			    in
				UrlMap.insert (rewritesMap, url, url');
				case UrlMap.lookup (invRewritesMap, url') of
				    SOME url'' =>
					raise Rewrite (url'', url, url')
				  | NONE => ();
				UrlMap.insert (invRewritesMap, url', url)
			    end) excludeMap;
	    if verbose then
		let
		    val includes =
			root::
			List.filter (fn url =>
					url <> root andalso
					UrlMap.member (includeMap, url))
				    (List.concat order)
		    val imports =
			List.sort String.compare
				  (UrlMap.foldi
				       (fn (url, _, rest) =>
					   Url.toString
					       (UrlMap.lookupExistent
						    (rewritesMap, url))::rest)
				       nil excludeMap)
		in
		    TextIO.print ("Included components:\n");
		    List.appr (fn url =>
				  TextIO.print ("   " ^ Url.toString url ^
						"\n")) includes;
		    if List.null imports then TextIO.print "No imports\n"
		    else
			(TextIO.print ("Imports (after rewrite):\n");
			 List.app (fn s => TextIO.print ("   " ^ s ^ "\n"))
				  imports)
		end
	    else ();
	    List.app (fn urls =>
			 if List.null (List.tl urls) then ()
			 else warnCycle urls) order;
	    build (root, componentMap, includeMap, excludeMap, rewritesMap)
	end
end
