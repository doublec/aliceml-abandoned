(*
 * Authors:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt and Andreas Rossberg, 2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure TextIO      from "../../lib/system/TextIO"
import structure IO          from "../../lib/system/IO"
import structure OS          from "../../lib/system/OS"
import structure CommandLine from "../../lib/system/CommandLine"
import structure Url         from "../../lib/system/Url"
import structure Resolver    from "../../lib/system/Resolver"
import structure PrettyPrint from "../../lib/utility/PrettyPrint"
import structure PPInf       from "../../lib/rtt/PPInf"
import structure Inf         from "../../lib/rtt/Inf"
import structure MyComponent from "MyComponent"
import structure Link        from "Link"

signature MAIN =
    sig
	val main: string list -> OS.Process.status
    end

structure Main :> MAIN =
    struct
	exception Syntax

	val root: string option ref = ref NONE
	val outputFile: string option ref = ref NONE
	val verbose = ref false
	val dumpsig = ref false
	val typeCheck = ref true
	val boundary: Link.boundary list ref = ref nil
	val rewrite: Resolver.Handler.t list ref = ref nil

	fun error s =
	    (TextIO.output (TextIO.stdErr, "alicelink: " ^ s);
	     OS.Process.failure)

	fun usage (SOME s, status) =
	    (TextIO.output (TextIO.stdErr, "alicelink: " ^ s ^ "\n");
	     usage (NONE, status))
	  | usage (NONE, status) =
	    (TextIO.output
	     (TextIO.stdErr,
	      "Usage: alicelink [<option> ...] <root url> [<option> ...]\n\n\
	      \Options:\n\
	      \-?, -h, --help, --usage\n\
	      \    Display this message.\n\
	      \-o FILE, --output FILE\n\
	      \    Specify the output file name (mandatory).\n\
	      \-v, --verbose\n\
	      \    Summarize which components are included/imported.\n\
	      \-d, --dumpsig\n\
	      \    Print component's import and export signatures.\n\
	      \--include PREFIX,...,PREFIX\n\
	      \    Include components at URLs with the given prefixes.\n\
	      \--exclude PREFIX,...,PREFIX\n\
	      \    Exclude components at URLs with the given prefixes.\n\
	      \--rewrite FROM=TO,...,FROM=TO\n\
	      \    Rewrite imports URLs of the output component.\n\
	      \    FROM and TO are patterns; ?{x} denotes a variable.\n");
	     status)

	fun help () = usage (NONE, OS.Process.success)
	fun usageError s = usage (SOME s, OS.Process.failure)

	fun ppInfOpt NONE = PrettyPrint.text "[no signature]"
	  | ppInfOpt (SOME inf) =
	    if Inf.isSig inf then
		PPInf.ppSig (Inf.asSig inf)
	    else
		PPInf.ppInf inf

	fun printComponentSigs (url, component) =
	    let
		val export = MyComponent.inf component
		val imports = MyComponent.imports component
		open PrettyPrint infixr ^^ ^/^
	    in
		Vector.app (fn (url, infOpt) =>
			    let
				val doc = abox(
					      nest 3 (
						  text "import" ^/^
						  ppInfOpt infOpt
					      ) ^/^
					      text ("from \"" ^ url ^ "\"")
					  ) ^^ break
			    in
				PrettyPrint.output (TextIO.stdOut, doc, 80)
			    end)
			   imports;
		PrettyPrint.output (TextIO.stdOut, ppInfOpt export^^break, 80)
	    end

	fun start (root, outputFile) =
	    let
		val component =
		    Link.link {root = Url.fromString root,
			       verbose = !verbose,
			       typeCheck = !typeCheck,
			       boundary = Vector.fromList (!boundary),
			       rewrite = !rewrite @ [Resolver.Handler.default]}
	    in
		MyComponent.save (outputFile, component);
		if !dumpsig then printComponentSigs (outputFile, component)
		else ();
		OS.Process.success
	    end
	    handle Link.Empty =>
		       error "root component has been excluded\n"
		 | Link.Mismatch (url, url') =>
		       error ("signature of component\n\
			      \   " ^ Url.toString url ^ "\n\
			      \does not fulfill requirements of component\n\
			      \   " ^ Url.toString url' ^ "\n")
		 | Link.Conflict url =>
		       error ("excluded component\n\
			      \   " ^ Url.toString url ^ "\n\
			      \imported multiply \
			      \with incompatible signatures\n")
		 | Link.Rewrite (url1, url2, url) =>
		       error ("rewrites ambiguates urls\n\
			      \   " ^ Url.toString url1 ^ "\n\
			      \and\n\
			      \   " ^ Url.toString url2 ^ "\n\
			      \to\n\
			      \   " ^ Url.toString url ^ "\n")
		 | Link.Io (url, _) =>
		       error ("could not load component\n\
			      \   " ^ Url.toString url ^ "\n")

	fun startDumpOnly root =
	    (case MyComponent.load (Url.fromString root) of
		 SOME component => printComponentSigs (root, component)
	       | NONE => TextIO.print "[no signature]\n";
	     OS.Process.success)
	    handle IO.Io _ =>
		       error ("could not load component\n\
			      \   " ^ root ^ "\n")

	(* Parse comma-separated lists *)
	fun csl s = String.tokens (fn c => c = #",") s

	(* Parse from-equals-to *)
	fun fet s =
	    case CharVector.findi (fn (_, c) => c = #"=") s of
		SOME (i, _) =>
		    Resolver.Handler.pattern (String.substring (s, 0, i),
					      String.extract (s, i + 1, NONE))
	      | NONE => raise Syntax

	fun main (("-h"|"-?"|"--help"|"--usage")::_) = help ()
	  | main (("-v"|"--verbose")::rest) = (verbose := true; main rest)
	  | main (("-d"|"--dumpsig")::rest) = (dumpsig := true; main rest)
	  | main ("--no-type-check"::rest) = (typeCheck := false; main rest)
	  | main ("--include"::includes::rest) =
	    (boundary := (!boundary @ List.map Link.INCLUDE (csl includes));
	     main rest)
	  | main ("--exclude"::excludes::rest) =
	    (boundary := (!boundary @ List.map Link.EXCLUDE (csl excludes));
	     main rest)
	  | main ("--rewrite"::rules::rest) =
	    ((rewrite := (!rewrite @ List.map fet (csl rules)); main rest)
	     handle Syntax => usageError "illegal rewrite rule syntax")
	  | main (("-o"|"--output")::name::rest) =
	    (case !outputFile of
		 NONE => (outputFile := SOME name; main rest)
	       | SOME _ => usageError "only one output file name may be given")
	  | main (name::rest) =
	    (case !root of
		 NONE => (root := SOME name; main rest)
	       | SOME _ => usageError "only one root component may be given")
	  | main nil =
	    (case (!dumpsig, !root, !outputFile) of
		 (_, SOME root, SOME outputFile) => start (root, outputFile)
	       | (true, SOME root, NONE) => startDumpOnly root
	       | (_, NONE, _) => usageError "no root component given"
	       | (false, _, NONE) => usageError "no output file name given")
    end

val _ = OS.Process.exit (Main.main (CommandLine.arguments ()))
