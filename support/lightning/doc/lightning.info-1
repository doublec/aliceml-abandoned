This is lightning.info, produced by makeinfo version 4.0 from
lightning.texi.

INFO-DIR-SECTION GNU lightning, a library for dynamic code generation
START-INFO-DIR-ENTRY
* Using and porting GNU lightning: (lightning).
END-INFO-DIR-ENTRY

   This file documents GNU lightning, Version 1.0.  It was last updated
on 2 November 2001.

   Copyright (C) 2000 Free Software Foundation, Inc.  Authored by Paolo
Bonzini.

   This document is released under the terms of the GNU Free
Documentation License as published by the Free Software Foundation;
either version 1.1, or (at your option) any later version.

   You should have received a copy of the GNU Free Documentation
License along with GNU lightning; see the file `COPYING.DOC'.  If not,
write to the Free Software Foundation, 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.

   There are no Secondary Sections, no Cover Texts and no Invariant
Sections (as defined in the license); this text, along with its
equivalent in the printed manual, constitutes the Title Page.


File: lightning.info,  Node: Top,  Up: (dir)

GNU lightning
*************

   This document describes installing, using and porting the GNU
lightning library for dynamic code generation.  Unlike other dynamic
code generation systems, which are usually either inefficient or
non-portable, GNU lightning is both retargetable and very fast.

* Menu:



* Overview::              What GNU lightning is.
* Using GNU lightning::   Using GNU lightning in your programs
* Porting GNU lightning:: Retargeting GNU lightning to a new system
* Future::                Tasks for GNU lightning's subsequent releases
* Acknowledgements::      Acknowledgements for GNU lightning

--- The detailed node listing ---

Using GNU lightning:

* Installation::          Configuring and installing GNU lightning
* The instruction set::   The RISC instruction set used i GNU lightning
* GNU lightning macros::  GNU lightning's macros
* Floating-point::        Doing floating point computations.
* Reentrancy::            Re-entrant usage of GNU lightning
* Autoconf support::      Using `autoconf' with GNU lightning


Porting GNU lightning:

* Structure of a port::   An overview of the porting process
* Adjusting configure::   Automatically recognizing the new platform
* Run-time assemblers::   An internal layer to simplify porting
* Standard macros::       The platform-independent layer used by clients.
* Standard functions::    Doing more complex tasks.
* Floating-point macros:: Implementing macros for floating point.


Standard macros:
* Forward references::    Implementing forward references
* Common features::       Common features supported by `core-common.h'
* Delay slots::           Supporting scheduling of delay slots
* Immediate values::      Supporting arbitrarily sized immediate values
* Implementing the ABI::  Function prologs and epilogs, and argument passing
* Macro list::            Macros composing the platform-independent layer


File: lightning.info,  Node: Overview,  Next: Using GNU lightning,  Prev: Top,  Up: Top

Introduction to GNU lightning
*****************************

   Dynamic code generation is the generation of machine code at
runtime. It is typically used to strip a layer of interpretation by
allowing compilation to occur at runtime.  One of the most well­known
applications of dynamic code generation is perhaps that of interpreters
that compile source code to an intermediate bytecode form, which is
then recompiled to machine code at run-time: this approach effectively
combines the portability of bytecode representations with the speed of
machine code.  Another common application of dynamic code generation is
in the field of hardware simulators and binary emulators, which can use
the same techniques to translate simulated instructions to the
instructions of the underlying machine.

   Yet other applications come to mind: for example, windowing "bitblt"
operations, matrix manipulations, and network packet filters.  Albeit
very powerful and relatively well known within the compiler community,
dynamic code generation techniques are rarely exploited to their full
potential and, with the exception of the two applications described
above, have remained curiosities because of their portability and
functionality barriers: binary instructions are generated, so programs
using dynamic code generation must be retargeted for each machine; in
addition, coding a run-time code generator is a tedious and error­prone
task more than a difficult one.

   This manual describes the GNU lightning dynamic code generation
library.  GNU lightning provides a portable, fast and easily
retargetable dynamic code generation system.

   To be fast, GNU lightning emits machine code without first creating
intermediate data structures such as RTL representations traditionally
used by optimizing compilers (*note RTL representation: (gcc)RTL
representation.).  GNU lightning translates code directly from a
machine independent interface to that of the underlying architecture.
This makes code generation more efficient, since no intermediate data
structures have to be constructed and consumed.  A collateral benefit
it that GNU lightning consumes little space: other than the memory
needed to store generated instructions and data structures such as
parse trees, the only data structure that client will usually need is
an array of pointers to labels and unresolved jumps, which you can
often allocate directly on the system stack.

   To be portable, GNU lightning abstracts over current architectures'
quirks and unorthogonalities.  The interface that it exposes to is that
of a standardized RISC architecture loosely based on the SPARC and MIPS
chips.  There are a few general-purpose registers (six, not including
those used to receive and pass parameters between subroutines), and
arithmetic operations involve three operands--either three registers or
two registers and an arbitrarily sized immediate value.

   On one hand, this architecture is general enough that it is possible
to generate pretty efficient code even on CISC architectures such as the
Intel x86 or the Motorola 68k families.  On the other hand, it matches
real architectures closely enough that, most of the time, the
compiler's constant folding pass ends up generating code which
assembles machine instructions without further tests.

Drawbacks
=========

   GNU lightning has been useful in practice; however, it does have at
least four drawbacks: it has limited registers, no peephole optimizer,
no instruction scheduler and no symbolic debugger. Of these, the last
is the most critical even though it does not affect the quality of
generated code: the only way to debug code generated at run-time  is to
step through it at the level of host specific machine code.  A decent
knowledge of the underlying instruction set is thus needed to make
sense of the debugger's output.

   The low number of available registers (six) is also an important
limitation.  However, let's take the primary application of dynamic
code generation, that is, bytecode translators.  The underlying virtual
machines tend to have very few general purpose registers (usually 0 to
2) and the translators seldom rely on sophisticated graph-coloring
algorithms to allocate registers to temporary variables.  Rather, these
translators usually obtain performance increases because: a) they
remove indirect jumps, which are usually poorly predicted, and thus
often form a bottleneck, b) they parameterize the generated code and go
through the process of decoding the bytecodes just once.  So, their
usage of registers is rather sparse--in fact, in practice, six
registers were found to be enough for most purposes.

   The lack of a peephole optimizer is most important on machines where
a single instruction can map to multiple native instructions.  For
instance, Intel chips' division instruction hard-codes the dividend to
be in EAX and the quotient and remainder to be output, respectively, in
EAX and EDX: on such chips, GNU lightning does lots of pushing and
popping of EAX and EDX to save those registers that are not used.
Unnecessary stack operations could be removed by looking at whether
preserved registers are destroyed soon.  Unfortunately, the current
implementation of GNU lightning is so fast because it only knows about
the single instruction that is being generated; performing these
optimizations would require a flow analysis pass that would probably
hinder GNU lightning's speed.

   The lack of an instruction scheduler is not very important--pretty
good instruction scheduling can actually be obtained by separating
register writes from register reads.  The only architectures on which a
scheduler would be useful are those on which arithmetic instructions
have two operands; an example is, again, the x86, on which the single
instruction
         subr_i  R0, R1, R2       !Compute R0 = R1 - R2

is translated to two instruction, of which the second depends on the
result of the first:
         movl    %ebx, %eax       ! Move R1 into R0
         subl    %edx, %eax       ! Subtract R2 from R0


File: lightning.info,  Node: Using GNU lightning,  Next: Porting GNU lightning,  Prev: Overview,  Up: Top

Using GNU lightning
*******************

   This chapter describes installing and using GNU lightning.

* Menu:


* Installation::          Configuring and installing GNU lightning
* The instruction set::   The RISC instruction set used i GNU lightning
* GNU lightning macros::  GNU lightning's macros
* Floating-point::        Doing floating point computations.
* Reentrancy::            Re-entrant usage of GNU lightning
* Autoconf support::      Using `autoconf' with GNU lightning


File: lightning.info,  Node: Installation,  Next: The instruction set,  Up: Using GNU lightning

Configuring and installing GNU lightning
========================================

   The first thing to do to use GNU lightning is to configure the
program, picking the set of macros to be used on the host architecture;
this configuration is automatically performed by the `configure' shell
script; to run it, merely type:
          ./configure

   GNU lightning supports cross-compiling in that you can choose a
different set of macros from the one needed on the computer that you
are compiling GNU lightning on.  For example,
          ./configure --host=sparc-sun-linux

will select the SPARC set of runtime assemblers.  You can use
configure's ability to make reasonable assumptions obout the vendor and
operating system and simply type
          ./configure --host=i386
          ./configure --host=ppc
          ./configure --host=sparc

   Another option that `configure' accepts is `--enable-assertions',
which enables several consistency checks in the run-time assemblers.
These are not usually needed, so you can decide to simply forget about
it; also remember that these consistency checks tend to slow down your
code generator.

   After you've configured GNU lightning, you don't have to compile it
because it is nothing more than a set of include files.  If you want to
compile the examples, run `make' as usual.  The next important step is:
         make install

   This ends the process of installing GNU lightning.


File: lightning.info,  Node: The instruction set,  Next: GNU lightning macros,  Prev: Installation,  Up: Using GNU lightning

GNU lightning's instruction set
===============================

   GNU lightning's instruction set was designed by deriving instructions
that closely match those of most existing RISC architectures, or that
can be easily syntesized if absent.  Each instruction is composed of:
   * an operation (like `sub' or `mul')

   * sometimes, an register/immediate flag (`r' or `i')

   * a type identifier (occasionally, two)

   The second and third field are separated by an underscore; thus,
examples of legal mnemonics are `addr_i' (integer add, with three
register operands) and `muli_l' (long integer multiply, with two
register operands and an immediate operand).  Each instruction takes
two or three operands; in most cases, one of them can be an immediate
value instead of a register.

   GNU lightning supports a full range of integer types: operands can
be 1, 2 or 4 bytes long (64-bit architectures might support 8 bytes long
operands), either signed or unsigned.  The types are listed in the
following table together with the C types they represent:

          c          signed char
          uc         unsigned char
          s          short
          us         unsigned short
          i          int
          ui         unsigned int
          l          long
          ul         unsigned long
          p          void *

   Some of these types may not be distinct: for example, (e.g., `l' is
equivalent to `i' on 32­bit machines, and `p' is substantially
equivalent to `ul').

   There are seven registers, of which six are general-purpose, while
the last is used to contain the stack pointer (`SP').  The stack
pointer can be used to allocate and access local variables on the stack
(which is supposed to grow downwards in memory on all architectures).

   Of the six general-purpose registers, three are guaranteed to be
preserved across function calls (`V0', `V1' and `V2') and three are not
(`R0', `R1' and `R2').(1)

   In addition, there is a special `RET' register which contains the
return value.  You should always remember, however, that writing this
register could overwrite either a general-purpose register or an
incoming parameter, depending on the architecture.

   The complete instruction set follows; as you can see, most non­memory
operations only take integers, long integers (either signed or
unsigned) and pointers as operands; this was done in order to reduce
the instruction set, and because most architectures only provide word
and long word operations on registers.  There are instructions that
allow operands to be extended to fit a larger data type, both in a
signed and in an unsigned way.

Binary ALU operations
     These accept three operands, of which the last can be an immediate
     value.  `addx' operations must directly follow `addc', and `subx'
     must follow `subc'; otherwise, results are undefined.
          addr/addi    i  ui l  ul p  O1 = O2 + O3
          addxr/addci  i  ui l  ul    O1 = O2 + (O3 + carry)
          addcr/addci  i  ui l  ul    O1 = O2 + O3, set carry
          subr/subi    i  ui l  ul p  O1 = O2 - O3
          subxr/subxi  i  ui l  ul    O1 = O2 - (O3 + carry)
          subcr/subci  i  ui l  ul    O1 = O2 - O3, set carry
          rsbr/rsbi    i  ui l  ul p  O1 = O3 - O2
          mulr/muli    i  ui l  ul    O1 = O2 * O3
          hmulr/hmuli  i  ui l  ul    O1 = high bits of O2 * O3
          divr/divi    i  ui l  ul    O1 = O2 / O
          modr/modi    i  ui l  ul    O1 = O2 % O3
          andr/andi    i  ui l  ul    O1 = O2 & O3
          orr/ori      i  ui l  ul    O1 = O2 | O3
          xorr/xori    i  ui l  ul    O1 = O2 ^ O3
          lshr/lshi    i  ui l  ul    O1 = O2 << O3
          rshr/rshi    i  ui l  ul    O1 = O2 >> O3(2)

Unary ALU operations
     These accept two operands, both of which must be registers.
          negr        i     l         O1 = -O2
          notr        i  ui l  ul     O1 = ~O2

Compare instructions
     These accept three operands, of which the last can be an immediate
     value.  The last two operands are compared, and the first operand
     is set to either 0 or 1, according to whether the given condition
     was met or not.

          ltr/lti     i ui l  ul p     O1 = (O2 <  O3)
          ler/lei     i ui l  ul p     O1 = (O2 <= O3)
          gtr/gti     i ui l  ul p     O1 = (O2 >  O3)
          ger/gei     i ui l  ul p     O1 = (O2 >= O3)
          eqr/eqi     i ui l  ul p     O1 = (O2 == O3)
          ner/nei     i ui l  ul p     O1 = (O2 != O3)

Transfer operations
     These accept two operands; for `ext' both of them must be
     registers, while `mov' accepts an immediate value as the second
     operand. `ext' needs *two* data type specifications, of which the
     first must be smaller in size than the second; for example
     `extr_c_ui' is correct while `extr_ul_us' is not.
          movr/movi               i  ui l  ul p   O1 = O2
          extr        c  uc s  us i  ui l  ul     O1 = O2(3)

Network extensions
     These accept two operands, both of which must be registers; these
     two instructions actually perform the same task, yet they are
     assigned to two mnemonics for the sake of convenience and
     completeness.  As usual, the first operand is the destination and
     the second is the source.
          hton       us ui          Host­to­network (big endian) order
          ntoh       us ui          Network­to­host order

Load operations
     `ld' accepts two operands while `ldx' accepts three; in both
     cases, the last can be either a register or an immediate value.
     Values are extended (with or without sign, according to the data
     type specification) to fit a whole register.
          ldr/ldi     c  uc s  us i  ui l  ul p   O1 = *O2
          ldxr/ldxi   c  uc s  us i  ui l  ul p   O1 = *(O2+O3)

Store operations
     `st' accepts two operands while `stx' accepts three; in both
     cases, the first can be either a register or an immediate value.
     Values are sign-extended to fit a whole register.
          str/sti     c  uc s  us i  ui l  ul p   *O1 = O2
          stxr/stxi   c  uc s  us i  ui l  ul p   *(O1+O2) = O3

Stack management
     These accept a single register parameter.  These operations are not
     guaranteed to be efficient on all architectures.

          pushr                   i  ui l  ul p   push O1 on the stack
          popr                    i  ui l  ul p   pop O1 off the stack

Argument management
     These are:
          prepare     (not specified)
          pusharg     c  uc s  us i  ui l  ul p
          getarg      c  uc s  us i  ui l  ul p
          arg         c  uc s  us i  ui l  ul p

     Of these, the first two are used by the caller, while the last two
     are used by the callee.  A code snippet that wants to call another
     procedure and has to pass registers must, in order: use the
     `prepare' instruction, giving the number of arguments to be passed
     to the procedure; use `pusharg' to push the arguments *in reverse
     order*; and use `calli' or `finish' (explained below) to perform
     the actual call.

     `arg' and `getarg' are used by the callee.  `arg' is different
     from other instruction in that it does not actually generate any
     code: instead, it is a function which returns a value to be passed
     to `getarg'.(4) You should call `arg' as soon as possible, before
     any function call or, more easily, right after the `prolog' or
     `leaf' instructions (which are treated later).

     `getarg' accepts a register argument and a value returned by
     `arg', and will move that argument to the register, extending it
     (with or without sign, according to the data type specification)
     to fit a whole register.  These instructions are more intimately
     related to the usage of the GNU lightning instruction set in code
     that generates other code, so they will be treated more
     specifically in *Note Generating code at run-time: GNU lightning
     macros.

     You should observe a few rules when using these macros.  First of
     all, it is not allowed to call functions with more than six
     arguments; this was done to simplify and speed up the
     implementation on architectures that use registers for parameter
     passing.

     You should not nest calls to `prepare', nor call zero-argument
     functions (which do not need a call to `prepare') inside a
     `prepare/calli' or `prepare/finish' block.  Doing this might
     corrupt already pushed arguments.

     You *cannot* pass parameters between subroutines using the six
     general-purpose registers.  This might work only when targeting
     particular architectures.

     On the other hand, it is possible to assume that callee-saved
     registers (`R0' through `R2') are not clobbered by another
     dynamically generated function which does not use them as operands
     in its code and which does not return a value.

Branch instructions
     Like `arg', these also return a value which, in this case, is to
     be used to compile forward branches as explained in *Note
     Fibonacci numbers: Fibonacci.  They accept a pointer to the
     destination of the branch and two operands to be compared; of
     these, the last can be either a register or an immediate.  They
     are:
          bltr/blti     i ui l  ul p    if O2 <  O3 goto O1
          bler/blei     i ui l  ul p    if O2 <= O3 goto O1
          bgtr/bgti     i ui l  ul p    if O2 >  O3 goto O1
          bger/bgei     i ui l  ul p    if O2 >= O3 goto O1
          beqr/beqi     i ui l  ul p    if O2 == O3 goto O1
          bner/bnei     i ui l  ul p    if O2 != O3 goto O1
          
          bmsr/bmsi     i ui l  ul      if O2 &  O3 goto O1
          bmcr/bmci     i ui l  ul      if !(O2 & O3) goto O1(5)
          
          boaddr/boaddi i ui l  ul      O2 += O3, goto O1 on overflow
          bosubr/bosubi i ui l  ul      O2 -= O3, goto O1 on overflow

Jump and return operations
     These accept one argument except `ret' which has none; the
     difference between `finish' and `calli' is that the latter does
     not clean the stack from pushed parameters (if any) and the former
     must *always* follow a `prepare' instruction.  Results are
     undefined when using function calls in a leaf function.
          calli     (not specified)            function call to O1
          finish    (not specified)            function call to O1
          jmpi/jmpr (not specified)            unconditional jump to O1
          prolog    (not specified)            function prolog for O1 args
          leaf      (not specified)            the same for leaf functions
          ret       (not specified)            return from subroutine
          retval    c  uc s  us i  ui l  ul p  move return value
                                               to register

     Like branch instruction, `jmpi' also returns a value which is to
     be used to compile forward branches. *Note Fibonacci numbers:
     Fibonacci.

   As a small appetizer, here is a small function that adds 1 to the
input parameter (an `int').  I'm using an assembly-like syntax here
which is a bit different from the one used when writing real
subroutines with GNU lightning; the real syntax will be introduced in
*Note Generating code at run-time: GNU lightning macros.

     incr:
          leaf      1
     in = arg_i                   ! We have an integer argument
          getarg_i  R0, in        ! Move it to R0
          addi_i    RET, R0, 1    ! Add 1, put result in return value
          ret                     ! And return the result

   And here is another function which uses the `printf' function from
the standard C library to write a number in hexadecimal notation:

     printhex:
          prolog    1
     in = arg_i                    ! Same as above
          getarg_i  R0, in
          prepare   2              ! Begin call sequence for printf
          pusharg_i R0             ! Push second argument
          pusharg_p "%x"           ! Push format string
          finish    printf         ! Call printf
          ret                      ! Return to caller

   ---------- Footnotes ----------

   (1) Six registers are not very much, but this restriction was forced
by the need to target CISC architectures which, like the x86, are poor
of registers.  Anyway, consider that even on a RISC architecture you
don't have many more registers which are not devoted to function calls:
on the SPARC, you have nine (`%g1' and the eight registers `%l0'
through `%l7').

   (2) The sign bit is propagated for signed types.

   (3) Unlike `movr' and `movi', `extr' is applied between operands of
different sizes.

   (4) "Return a value" means that GNU lightning macros that compile
these instructions return a value when expanded.

   (5) These two mnemonics mean, respectively, "branch if mask set" and
"branch if mask cleared".


File: lightning.info,  Node: GNU lightning macros,  Next: Floating-point,  Prev: The instruction set,  Up: Using GNU lightning

Generating code at run-time
===========================

   To use GNU lightning, you should include the `lightning.h' file that
is put in your include directory by the `make install' command.  That
include files defines about four hundred public macros (plus others
that are private to GNU lightning), one for each opcode listed above.

   Each of the instructions above translates to a macro.  All you have
to do is prepend `jit_' (lowercase) to opcode names and `JIT_'
(uppercase) to register names.  Of course, parameters are to be put
between parentheses, just like with every other CPP macro.

   This small tutorial presents three examples:

* Menu:

* incr::             A function which increments a number by one
* printf::           A simple function call to printf
* RPN calculator::   A more complex example, an RPN calculator
* Fibonacci::        Calculating Fibonacci numbers


File: lightning.info,  Node: incr,  Next: printf,  Up: GNU lightning macros

A function which increments a number by one
-------------------------------------------

   Let's see how to create and use the sample `incr' function created
in *Note GNU lightning's instruction set: The instruction set:

     #include <stdio.h>
     #include "lightning.h"
     
     static jit_insn codeBuffer[1024];
     
     typedef int (*pifi)(int);    /* Pointer to Int Function of Int */
     
     int main()
     {
       pifi  incr = (pifi) (jit_set_ip(codeBuffer).iptr);
       int   in;
     
       jit_leaf(1);                     /*      leaf  1             */
       in = jit_arg_i();                /* in = arg_i               */
       jit_getarg_i(JIT_R0, in);        /*      getarg_i R0         */
       jit_addi_i(JIT_RET, JIT_R0, 1);  /*      addi_i   RET, R0, 1 */
       jit_retr_i(JIT_R0);              /*      reti_i   R0         */
     
       jit_flush_code(codeBuffer, jit_get_ip().ptr);
     
       /* call the generated code, passing 5 as an argument */
       printf("%d + 1 = %d", 5, incr(5));
       return 0;
     }

   Let's examine the code line by line (well, almost...):

#include "lightning.h"
     You already know about this.  It defines all of GNU lightning's
     macros.

static jit_insn codeBuffer[1024];
     You might wonder about what is `jit_insn'.  It is just a type that
     is defined by GNU lightning.  Its exact definition depends on the
     architecture; in general, defining an array of 1024 `jit_insn's
     allows one to write 100 to 400 GNU lightning instructions
     (depending on the architecture and exact instructions).

typedef int (*pifi)(int);
     Just a handy typedef for a pointer to a function that takes an
     `int' and returns another.

pifi incr = (pifi) (jit_set_ip(codeBuffer).iptr);
     This is the first GNU lightning macro we encounter that does not
     map to an instruction.  It is `jit_set_ip', which takes a pointer
     to an area of memory where compiled code will be put and returns
     the same value, cast to a `union' type whose members are pointers
     to functions returning different C types.  This union is called
     `jit_code' and is defined as follows:

              typedef union jit_code {
                char               *ptr;
                void               (*vptr)();
                char               (*cptr)();
                unsigned char      (*ucptr)();
                short              (*sptr)();
                unsigned short     (*usptr)();
                int                (*iptr)();
                unsigned int       (*uiptr)();
                long               (*lptr)();
                unsigned long      (*ulptr)();
                void *             (*pptr)();
                float              (*fptr)();
                double             (*dptr)();
              } jit_code;

     Any of the members could have been used, since the result is soon
     casted to type `pifi' but, for the sake of clarity, the program
     uses `iptr', a pointer to a function with no prototype and
     returning an `int'.

     Analogous to `jit_set_ip' is `jit_get_ip', which does not modify
     the instruction pointer--it is nothing more than a cast of the
     current IP to `jit_code'.

int       in;
     A footnote in *Note GNU lightning's instruction set: The
     instruction set, under the description of `arg', says that macros
     implementing `arg' return a value--we'll be using this variable to
     store the result of `arg'.

jit_leaf(1);
     Ok, so we start generating code for our beloved function... it will
     accept one argument and won't call any other function.

in = jit_arg_i();
jit_getarg_i(JIT_R0, in);
     We retrieve the first (and only) argument, an integer, and store it
     into the general-purpose register `R0'.

jit_addi_i(JIT_RET, JIT_R0, 1);
     We add one to the content of the register and store the result in
     the return value.

jit_ret();
     This instruction generates a standard function epilog that returns
     the contents of the `RET' register.

jit_flush_code(codeBuffer, jit_get_ip().ptr);
     This instruction is very important.  It flushes the generated code
     area out of the processor's instruction cache, avoiding the
     processor executes bogus data that it happens to find there.  The
     `jit_flush_code' function accepts the first and the last address
     to flush; we use `jit_get_ip' to find out the latter.

printf("%d + 1 = %d", 5, incr(5));
     Calling our function is this simple--it is not distinguishable from
     a normal C function call, the only difference being that `incr' is
     a variable.

   GNU lightning abstracts two phases of dynamic code generation:
selecting instructions that map the standard representation, and
emitting binary code for these instructions.  The client program has
the responsibility of describing the code to be generated using the
standard GNU lightning instruction set.

   Let's examine the code generated for `incr' on the SPARC and x86
architectures (on the right is the code that an assembly-language
programmer would write):

SPARC
              save %sp, -96, %sp
              mov  %i0, %l0                   retl
              add  %l0, 1,  %i0               add %o0, 1, %o0
              ret
              restore
     In this case, GNU lightning introduces overhead to create a
     register window (not knowing that the procedure is a leaf
     procedure) and to move the argument to the general purpose
     register `R0' (which maps to `%l0' on the SPARC).  The former
     overhead could be avoided by teaching GNU lightning about leaf
     procedures (*note Future::); the latter could instead be avoided
     by rewriting the getarg instruction as `jit_getarg_i(JIT_RET,
     in)', which was not done in this example.

x86
              pushl %ebx
              pushl %esi
              pushl %edi
              pushl %ebp
              movl  %esp, %ebp
              movl  20(%ebp), %eax       movl 20(%esp), %eax
              addl  $1, %eax             incl %eax
              popl  %ebp
              popl  %edi
              popl  %esi
              popl  %ebx
              ret                        ret
     In this case, the main overhead is due to the function's prolog and
     epilog, which is nine instructions long on the x86; a hand-written
     routine would not save unused callee-preserved registers on the
     stack.  It is to be said, however, that this is not a problem in
     more complicated uses, because more complex procedure would
     probably use the `V0' through `V2' registers (`%ebx', `%esi',
     `%edi'); in this case, a hand-written routine would have included
     the prolog too.  Also, a ten byte prolog would probably be a small
     overhead in a more complex function.

   In such a simple case, the macros that make up the back-end compile
reasonably efficient code, with the notable exception of prolog/epilog
code.


File: lightning.info,  Node: printf,  Next: RPN calculator,  Prev: incr,  Up: GNU lightning macros

A simple function call to `printf'
----------------------------------

   Again, here is the code for the example:

     #include <stdio.h>
     #include "lightning.h"
     
     static jit_insn codeBuffer[1024];
     
     typedef void (*pvfi)(int);      /* Pointer to Void Function of Int */
     
     int main()
     {
       pvfi          myFunction;             /* ptr to generated code */
       char          *start, *end;           /* a couple of labels */
       int           in;                     /* to get the argument */
     
       myFunction = (pvfi) (jit_set_ip(codeBuffer).vptr);
       start = jit_get_ip().ptr;
       jit_prolog(1);
       in = jit_arg_i();
       jit_movi_p(JIT_R0, "generated %d bytes\n");
       jit_getarg_i(JIT_R1, in);
       jit_prepare(2);
         jit_pusharg_i(JIT_R1);              /* push in reverse order */
         jit_pusharg_p(JIT_R0);
       jit_finish(printf);
       jit_ret();
       end = jit_get_ip().ptr;
     
       /* call the generated code, passing its size as argument */
       jit_flush_code(start, end);
       myFunction(end - start);
     }

   The function shows how many bytes were generated.  Most of the code
is not very interesting, as it resembles very closely the program
presented in *Note A function which increments a number by one: incr.

   For this reason, we're going to concentrate on just a few statements.

start = jit_get_ip().ptr;
...
end = jit_get_ip().ptr;
     These two instruction call the `jit_get_ip' macro which was
     mentioned in *Note A function which increments a number by one:
     incr too.  In this case we use the only field of `jit_code' that is
     not a function pointer: `ptr', which is a simple `char *'.

jit_movi_p(JIT_R0, "generated %d bytes\n");
     Note the use of the `p' type specifier, which automatically casts
     the second parameter to an `unsigned long' to make the code more
     clear and less cluttered by typecasts.

jit_prepare(2);
jit_pusharg_i(JIT_R1);
jit_pusharg_p(JIT_R0);
jit_finish(printf);
     Once the arguments to `printf' have been put in general-purpose
     registers, we can start a prepare/pusharg/finish sequence that
     moves the argument to either the stack or registers, then calls
     `printf', then cleans up the stack.  Note how GNU lightning
     abstracts the differences between different architectures and
     ABI's - the client program does not know how parameter passing
     works on the host architecture.


File: lightning.info,  Node: RPN calculator,  Next: Fibonacci,  Prev: printf,  Up: GNU lightning macros

A more complex example, an RPN calculator
-----------------------------------------

   We create a small stack-based RPN calculator which applies a series
of operators to a given parameter and to other numeric operands.
Unlike previous examples, the code generator is fully parameterized and
is able to compile different formulas to different functions.  Here is
the code for the expression compiler; a sample usage will follow.

     #include <stdio.h>
     #include "lightning.h"
     
     typedef int (*pifi)(int);       /* Pointer to Int Function of Int */
     
     pifi compile_rpn(char *expr)
     {
       pifi fn;
       int in;
       fn = (pifi) (jit_get_ip().iptr);
       jit_leaf(1);
       in = jit_arg_i();
       jit_getarg_i(JIT_R0, ofs);
     
       while (*expr) {
         char buf[32];
         int n;
         if (sscanf(expr, "%[0-9]%n", buf, &n)) {
           expr += n - 1;
           jit_push_i(JIT_R0);
           jit_movi_i(JIT_R0, atoi(buf));
         } else if (*expr == '+') {
           jit_pop_i(JIT_R1);
           jit_addr_i(JIT_R0, JIT_R1, JIT_R0);
         } else if (*expr == '-') {
           jit_pop_i(JIT_R1);
           jit_subr_i(JIT_R0, JIT_R1, JIT_R0);
         } else if (*expr == '*') {
           jit_pop_i(JIT_R1);
           jit_mulr_i(JIT_R0, JIT_R1, JIT_R0);
         } else if (*expr == '/') {
           jit_pop_i(JIT_R1);
           jit_divr_i(JIT_R0, JIT_R1, JIT_R0);
         } else {
           fprintf(stderr, "cannot compile: %s\n", expr);
           abort();
         }
         ++expr;
       }
       jit_movr_i(JIT_RET, JIT_R0);
       jit_ret();
       return fn;
     }

   The principle on which the calculator is based is easy: the stack
top is held in R0, while the remaining items of the stack are held on
the hardware stack.  Compiling an operand pushes the old stack top onto
the stack and moves the operand into R0; compiling an operator pops the
second operand off the stack into R1, and compiles the operation so
that the result goes into R0, thus becoming the new stack top.

   Try to locate a call to `jit_set_ip' in the source code.  You will
not find one; this means that the client has to manually set the
instruction pointer.  This technique has one advantage and one
drawback.  The advantage is that the client can simply set the
instruction pointer once and then generate code for multiple functions,
one after another, without caring about passing a different instruction
pointer each time; see *Note Re-entrant usage of GNU lightning:
Reentrancy for the disadvantage.

   Source code for the client (which lies in the same source file)
follows:

     static jit_insn codeBuffer[1024];
     
     int main()
     {
       pifi c2f, f2c;
       int i;
     
       jit_set_ip(codeBuffer);
       c2f = compile_rpn("9*5/32+");
       f2c = compile_rpn("32-5*9/");
       jit_flush_code(codeBuffer, jit_get_ip().ptr);
     
       printf("\nC:");
       for (i = 0; i <= 100; i += 10) printf("%3d ", i);
       printf("\nF:");
       for (i = 0; i <= 100; i += 10) printf("%3d ", c2f(i));
       printf("\n");
     
       printf("\nF:");
       for (i = 32; i <= 212; i += 10) printf("%3d ", i);
       printf("\nC:");
       for (i = 32; i <= 212; i += 10) printf("%3d ", f2c(i));
       printf("\n");
       return 0;
     }

   The client displays a conversion table between Celsius and Fahrenheit
degrees (both Celsius-to-Fahrenheit and Fahrenheit-to-Celsius). The
formulas are, F(c) = c*9/5+32 and C(f) = (f-32)*5/9, respectively.

   Providing the formula as an argument to `compile_rpn' effectively
parameterizes code generation, making it possible to use the same code
to compile different functions; this is what makes dynamic code
generation so powerful.


File: lightning.info,  Node: Fibonacci,  Prev: RPN calculator,  Up: GNU lightning macros

Fibonacci numbers
-----------------

   The code in this section calculates a variant of the Fibonacci
sequence.  While the traditional Fibonacci sequence is modeled by the
recurrence relation:
          f(0) = f(1) = 1
          f(n) = f(n-1) + f(n-2)

the functions in this section calculates the following sequence, which
is more interesting as a benchmark(1):
          nfibs(0) = nfibs(1) = 1
          nfibs(n) = nfibs(n-1) + nfibs(n-2) + 1

   The purpose of this example is to introduce branches.  There are two
kind of branches: backward branches and forward branches.  We'll
present the calculation in a recursive and iterative form; the former
only uses forward branches, while the latter uses both.

     #include <stdio.h>
     #include "lightning.h"
     
     static jit_insn codeBuffer[1024];
     
     typedef int (*pifi)(int);       /* Pointer to Int Function of Int */
     
     int main()
     {
       pifi      nfibs = (pifi) (jit_set_ip(codeBuffer).iptr);
       int       in;                 /* offset of the argument */
       jit_insn  *ref;               /* to patch the forward reference */
     
             jit_prolog   (1);
       in =  jit_arg_ui   ();
             jit_getarg_ui(JIT_V0, in);              /* V0 = n */
       ref = jit_blti_ui  (jit_forward(), JIT_V0, 2);
             jit_subi_ui  (JIT_V1, JIT_V0, 1);       /* V1 = n-1 */
             jit_subi_ui  (JIT_V2, JIT_V0, 2);       /* V2 = n-2 */
             jit_prepare(1);
               jit_pusharg_ui(JIT_V1);
             jit_finish(nfibs);
             jit_retval(JIT_V1);                     /* V1 = nfibs(n-1) */
             jit_prepare(1);
               jit_pusharg_ui(JIT_V2);
             jit_finish(nfibs);
             jit_retval(JIT_V2);                     /* V2 = nfibs(n-2) */
             jit_addi_ui(JIT_V1,  JIT_V1,  1);
             jit_addr_ui(JIT_RET, JIT_V1, JIT_V2);   /* RET = V1 + V2 + 1 */
             jit_ret();
     
       jit_patch(ref);                               /* patch jump */
             jit_movi_i(JIT_RET, 1);                 /* RET = 1 */
             jit_ret();
     
       /* call the generated code, passing 32 as an argument */
       jit_flush_code(codeBuffer, jit_get_ip().ptr);
       printf("nfibs(%d) = %d", 32, nfibs(32));
       return 0;
     }

   As said above, this is the first example of dynamically compiling
branches.  Branch instructions have three operands: two contains the
values to be compared, while the first is a "label"; GNU lightning
label's are represented as `jit_insn *' values.  Unlike other
instructions (apart from `arg', which is actually a directive rather
than an instruction), branch instructions also return a value which, as
we see in the example above, can be used to compile forward references.

   Compiling a forward reference is a two-step operation.  First, a
branch is compiled with a dummy label, since the actual destination of
the jump is not yet known; the dummy label is returned by the
`jit_forward()' macro.  The value returned by the branch instruction is
saved to be used later.

   Then, when the destination of the jump is reached, another macro is
used, `jit_patch()'. This macro must be called once for *every* point
in which the code had a forward branch to the instruction following
`jit_patch' (in this case a `movi_i' instruction).

   Now, here is the iterative version:

     #include <stdio.h>
     #include "lightning.h"
     
     static jit_insn codeBuffer[1024];
     
     typedef int (*pifi)(int);       /* Pointer to Int Function of Int */
     
     int main()
     {
       pifi     nfibs = (pifi) (jit_set_ip(codeBuffer).iptr);
       int      in;                  /* offset of the argument */
       jit_insn *ref;                /* to patch the forward reference */
       jit_insn *loop;               /* start of the loop */
     
             jit_leaf     (1);
       in =  jit_arg_ui   ();
             jit_getarg_ui(JIT_R2, in);              /* V0 = n */
             jit_movi_ui  (JIT_R1, 1);
       ref = jit_blti_ui  (jit_forward(), JIT_R2, 2);
             jit_subi_ui  (JIT_R2, JIT_R2, 1);
             jit_movi_ui  (JIT_R0, 1);
     
       loop= jit_get_label();
             jit_subi_ui  (JIT_R2, JIT_R2, 1);       /* decr. counter */
             jit_addr_ui  (JIT_V0, JIT_R0, JIT_R1);  /* V0 = R0 + R1 */
             jit_movr_ui  (JIT_R0, JIT_R1);          /* R0 = R1 */
             jit_addi_ui  (JIT_R1, JIT_V0, 1);       /* R1 = V0 + 1 */
             jit_bnei_ui  (loop, JIT_R2, 0);         /* if (R2) goto loop; */
     
       jit_patch(ref);                               /* patch forward jump */
             jit_movr_ui  (JIT_RET, JIT_R1);         /* RET = R1 */
             jit_ret      ();
     
       /* call the generated code, passing 36 as an argument */
       jit_flush_code(codeBuffer, jit_get_ip().ptr);
       printf("nfibs(%d) = %d", 36, nfibs(36));
       return 0;
     }

   This code calculates the recurrence relation using iteration (a
`for' loop in high-level languages).  There is still a forward
reference (indicated by the `jit_forward'/`jit_patch' pair); there are
no function calls anymore: instead, there is a backward jump (the
`bnei' at the end of the loop).

   In this case, the destination address should be known, because the
jumps lands on an instruction that has already been compiled.  However
the program must make a provision and remember the address where the
jump will land.  This is achieved with `jit_get_label', yet another
macro that is much similar to `jit_get_ip' but, instead of a `jit_code'
union, it answers an `jit_insn *' that the branch macros accept.

   Now, let's make one more change: let's rewrite the loop like this:

       ...
     
       jit_delay(
             jit_movi_ui  (JIT_R1, 1),
       ref = jit_blti_ui  (jit_forward(), JIT_R2, 2));
             jit_subi_ui  (JIT_R2, JIT_R2, 1);
     
       loop= jit_get_label();
             jit_subi_ui  (JIT_R2, JIT_R2, 1);       /* decr. counter */
             jit_addr_ui  (JIT_V0, JIT_R0, JIT_R1);  /* V0 = R0 + R1 */
             jit_movr_ui  (JIT_R0, JIT_R1);          /* R0 = R1 */
       jit_delay(
             jit_addi_ui  (JIT_R1, JIT_V0, 1),       /* R1 = V0 + 1 */
             jit_bnei_ui  (loop, JIT_R2, 0));        /* if (R2) goto loop; */
     
       ...

   The `jit_delay' macro is used to schedule delay slots in jumps and
branches.  This is optional, but might lead to performance improvements
in tight inner loops (of course not in a loop that is executed 35
times, but this is just an example).

   `jit_delay' takes two GNU lightning instructions, a "delay
instruction" and a "branch instruction".  Note that the two
instructions must be written in execution order (first the delay
instruction, then the branch instruction), *not* with the branch first.
If the current machine has a delay slot, the delay instruction (or
part of it) is placed in the delay slot after the branch instruction;
otherwise, it emits the delay instruction before the branch
instruction.  The delay instruction must not depend on being executed
before or after the branch.

   ---------- Footnotes ----------

   (1) That's because, as is easily seen, the sequence represents the
number of activations of the `nfibs' procedure that are needed to
compute its value through recursion


File: lightning.info,  Node: Floating-point,  Next: Reentrancy,  Prev: GNU lightning macros,  Up: Using GNU lightning

Doing floating point computations
=================================


File: lightning.info,  Node: Reentrancy,  Next: Autoconf support,  Prev: Floating-point,  Up: Using GNU lightning

Re-entrant usage of GNU lightning
=================================

   By default, GNU lightning is able to compile different functions at
the same time as long as it happens in different object files, and on
the other hand constrains code generation tasks to reside in a single
object file.

   The reason for this is not apparent, but is easily explained: the
`lightning.h' header file defines its state as a `static' variable, so
calls to `jit_set_ip' and `jit_get_ip' residing in different files
access different instruction pointers.  This was not done without
reason: it makes the usage of GNU lightning much simpler, as it limits
the initialization tasks to the bare minimum and removes the need to
link the program with a separate library.

   On the other hand, multi-threaded or otherwise concurrent programs
require reentrancy in the code generator, so this approach cannot be
the only one.  In fact, it is possible to define your own copy of GNU
lightning's instruction state by defining a variable of type
`jit_state' and `#define'-ing `_jit' to it:

         struct jit_state lightning;
         #define _jit lightning

   You are free to define the `jit_state' variable as you like:
`extern', `static' to a function, `auto', or global.

   This feature takes advantage of an aspect of macros ("cascaded
macros"), which is documented thus in CPP's reference manual:

     A cascade of macros is when one macro's body contains a reference
     to another macro.  This is very common practice.  For example,
          #define BUFSIZE 1020
          #define TABLESIZE BUFSIZE
     This is not at all the same as defining `TABLESIZE' to be `1020'.
     The `#define' for `TABLESIZE' uses exactly the body you
     specify--in this case, `BUFSIZE'--and does not check to see
     whether it too is the name of a macro; it's only when you use
     `TABLESIZE' that the result of its expansion is checked for more
     macro names.

     This makes a difference if you change the definition of `BUFSIZE'
     at some point in the source file. `TABLESIZE', defined as shown,
     will always expand using the definition of `BUFSIZE' that is
     currently in effect: #define BUFSIZE 1020 #define TABLESIZE BUFSIZE
     #undef BUFSIZE #define BUFSIZE 37

     Now `TABLESIZE' expands (in two stages) to `37'. (The `#undef' is
     to prevent any warning about the nontrivial redefinition of
     `BUFSIZE'.)

In the same way, `jit_get_label' will adopt whatever definition of
`_jit' is in effect:
     #define	jit_get_label()			(_jit.pc)

   Special care must be taken when functions residing in separate files
must access the same state.  This could be the case, for example, if a
special library contained function for strength reduction of
multiplications to adds & shifts, or maybe of divisions to
multiplications and shifts.  The function would be compiled using a
single definition of `_jit' and that definition would be used whenever
the function would be called.

   Since GNU lightning uses a feature of the preprocessor to obtain
re-entrancy, it makes sense to rely on the preprocessor in this case
too.

   The idea is to pass the current `struct jit_state' to the function:

     static void
     _opt_muli_i(jit, dest, source, n)
          register struct jit_state *jit;
          register int		dest, source, n;
     {
     #define _jit          jit
     ...
     #undef _jit
     }

doing this unbeknownst to the client, using a macro in the header file:

     extern void _opt_muli_i(struct jit_state *, int, int, int);
     
     #define opt_muli_i(rd, rs, n)	_opt_muli_i(&_jit, (rd), (rs), (n))

