(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2001-2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Inf               from "../rtt/Inf"
import structure TextIO            from "TextIO"
import structure IO                from "IO"
import structure OS                from "OS"
import structure Reflect           from "Reflect"
import structure Url               from "Url"
import structure Resolver          from "Resolver"
import structure UnsafeComponent   from "UnsafeComponent"
import structure UrlMap            from "UrlMap"
import signature COMPONENT_MANAGER from "COMPONENT_MANAGER-sig"
import signature COMPONENT         from "COMPONENT-sig"

structure Component :> COMPONENT =
struct
    nonfix mod
    type inf = Inf.t option
    type mod = Reflect.module

    datatype component =
	UNEVALUATED of { imports: (string * inf) vector,
			 body:    mod vector -> mod,
			 inf:     inf }
      | EVALUATED of { inf: inf, mod: mod }
    type t = component

    exception Sited    = UnsafeComponent.Sited
    exception Corrupt  = UnsafeComponent.Corrupt
    exception NotFound = UnsafeComponent.NotFound
    exception Mismatch = UnsafeComponent.Mismatch
    exception Eval     = UnsafeComponent.Eval
    exception Failure  = UnsafeComponent.Failure

    val extension = UnsafeComponent.extension

    local
	val b = Option.isSome (OS.Process.getEnv "ALICE_TRACE_COMPONENT")
    in
	fun trace s where b =
	    TextIO.output (TextIO.stdErr, "[component manager] " ^ s ^ "\n")
	  | trace _ = ()
    end

    fun create (inf, mod) = EVALUATED {inf, mod}

    functor Create(signature S structure X: S) =
	let
	    structure Sig = Reflect.ReflectSig(signature S = S)
	    structure Mod = Reflect.Reflect(signature S = S
					    structure X = X)
	in
	    (val component = EVALUATED {inf = SOME Sig.x, mod = Mod.x})
	end

    val defaultResolver =
	let
	    val handlers =
		case OS.Process.getEnv "ALICE_LOAD" of
		    SOME s => Resolver.Handler.parse s
		  | NONE => [Resolver.Handler.default]
	in
	    Resolver.resolver {name = "load", handlers, memoize = true}
	end

    fun load' resolver url =
	case Resolver.localize resolver url of
	    SOME (Resolver.FILE name) =>
		(UnsafeComponent.load name
		 handle Corrupt =>
		     UnsafeComponent.linkNative name
		     handle cause as UnsafeComponent.Native msg =>
			    (trace ("linkNative: " ^ msg);
			     raise IO.Io {name, function = "load", cause})
			  | cause as Corrupt =>
			    (trace ("linkNative: \
				    \could not resolve symbol");
			     raise IO.Io {name, function = "load", cause}))
	  | SOME (Resolver.STRING string) =>
		(UnsafeComponent.unpack_ string
		 handle cause =>
		     raise IO.Io {name = Url.toStringRaw url,
				  function = "load", cause})
	  | NONE => raise IO.Io {name = Url.toStringRaw url,
				 function = "load", cause = NotFound}

    val load = load' defaultResolver

    fun save (name, component) =
	UnsafeComponent.save (name, component)
	handle cause => raise IO.Io {name, function = "save", cause}

    fun inf (UNEVALUATED {inf, ...}) = inf
      | inf (EVALUATED {inf, ...}) = inf

    val initialTable = lazy UnsafeComponent.getInitialTable ()

    functor MkManager(val resolver: Resolver.t) :>
	COMPONENT_MANAGER where type component = component =
    struct
	(*--** should query and fragment be rejected instead of ignored? *)

	exception Conflict

	datatype component = datatype component

	val map: (inf * mod) UrlMap.t =
	    lazy UrlMap.map (Vector.map (fn (s, inf, mod) =>
					 (Url.fromString ("x-alice:/" ^ s),
					  (inf, mod)))
			     initialTable)

	fun strictTypeCheck (SOME inf, SOME importInf, mod) =
	    (Inf.match (inf, importInf); mod) (*--** coercion *)
	  | strictTypeCheck (NONE, SOME _, mod) =
	    (trace ("warning: no export signature, accepted unchecked"); mod)
	  | strictTypeCheck (SOME _, NONE, mod) =
	    (trace ("warning: no import signature, accepted unchecked"); mod)
	  | strictTypeCheck (NONE, NONE, mod) =
	    (trace ("warning: no import/export signatures, accepted unchecked");
	     mod)

	fun lazyTypeCheck (inf, importInf, mod, url, baseUrlOpt) =
	    let
		val message =
		    Url.toString url ^
		    (case baseUrlOpt of
			 SOME baseUrl =>
			 " imported by " ^ Url.toString baseUrl
		       | NONE => "")
	    in
		lazy (trace ("type-checking " ^ message);
		      (strictTypeCheck (inf, importInf, mod)
		       handle Inf.Mismatch m =>
			   raise Failure (url,
					  Mismatch {component = url,
						    request = baseUrlOpt,
						    cause = m}))
		      before trace ("type-checked  " ^ message))
	    end

	fun link' url =
	    case UrlMap.lookupNew (map, url) of
		UrlMap.EXISTING entry => entry
	      | UrlMap.NEW p =>
		    let
			val component =
			    lazy (load' resolver url
				  handle e => raise Failure (url, e))
			val inf = lazy inf component
			val mod = lazy eval' (url, component)
			val entry = (inf, mod)
		    in
			Promise.fulfill (p, entry); entry
		    end
	and typedLink (url, importInf, baseUrlOpt) =
	    let
		val (inf, mod) = link' url
	    in
		lazyTypeCheck (inf, importInf, mod, url, baseUrlOpt)
	    end
	and eval' (baseUrl, UNEVALUATED {imports, body, ...}) =
	    let
		fun resolve s =
		    let
			val url = Url.fromString s
			val url = Url.setQuery (url, NONE)
			val url = Url.setFragment (url, NONE)
		    in
			Url.resolve baseUrl url
		    end
		val imports' =
		    Vector.map (fn (importUrlS, importInf) =>
				   typedLink (resolve importUrlS,
					      importInf, SOME baseUrl))
			       imports
	    in
		trace ("evaluating " ^ Url.toString baseUrl);
		(body imports'
		 handle e as (non (Failure (_, _))) =>
		     (trace ("evaluation failed in " ^ Url.toString baseUrl);
		      raise Failure (baseUrl, Eval e)))
		before
		trace ("evaluated  " ^ Url.toString baseUrl)
	    end
	  | eval' (_, EVALUATED {mod, ...}) = Future.await mod

	fun validate url =
	    let
		val cwd = Url.fromString (OS.FileSys.getDir () ^ "/")
		val cwd = Url.setScheme (cwd, SOME "file")
		val url = Url.resolve cwd url
		val url = Url.setQuery (url, NONE)
		val url = Url.setFragment (url, NONE)
	    in
		url
	    end

	functor Eval(val component: component val url: Url.t signature S): S =
	    let
		structure Sig = Reflect.ReflectSig(signature S = S)
		val url = validate url
		val mod = eval' (url, component)
		val inf = inf component
		val mod' = strictTypeCheck (inf, SOME Sig.x, mod)
			   handle Inf.Mismatch m =>
			       raise Mismatch {component = url,
					       request = NONE,
					       cause = m}
	    in
		Reflect.Unreflect(val x = mod' signature S = S)
	    end

	functor Link(val url: Url.t signature S): S =
	    let
		structure Sig = Reflect.ReflectSig(signature S = S)
		val mod = typedLink (validate url, SOME Sig.x, NONE)
	    in
		Reflect.Unreflect(val x = mod signature S = S)
	    end

	functor Enter(val url: Url.t signature S structure X: S) =
	    let
		structure Sig = Reflect.ReflectSig(signature S = S)
		structure Mod = Reflect.Reflect(signature S = S
						structure X = X)
		val _ =
		    case UrlMap.lookupNew (map, validate url) of
			UrlMap.EXISTING _ => raise Conflict
		      | UrlMap.NEW p =>
			    Promise.fulfill (p, (SOME Sig.x, Mod.x))
	    in
		()
	    end

	fun eval (url, component) = eval' (validate url, component)

	fun link url = create (link' (validate url))

	fun enter (url', component) withval url = validate url' end =
	    case UrlMap.lookupNew (map, url) of
		UrlMap.EXISTING _ => raise Conflict
	      | UrlMap.NEW p =>
		    Promise.fulfill (p, (inf component,
					 lazy eval' (url, component)))

	fun lookup url =
	    case UrlMap.lookup (map, validate url) of
		SOME (inf, mod) => SOME (EVALUATED {inf, mod})
	      | NONE => NONE

	fun start url' withval url = validate url' end =
	    ignore (eval' (url, create (link' url)))
    end
end
