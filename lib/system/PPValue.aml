(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2002-2004
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure UnsafeValue      from "../system/UnsafeValue"
import structure Reflect          from "../system/Reflect"

import structure Name             from "../rtt/Name"
import structure Label            from "../rtt/Label"
import structure Path             from "../rtt/Path"
import structure PathMap          from "../rtt/PathMap"
import structure Type             from "../rtt/Type"
import structure PervasiveType    from "../rtt/PervasiveType"

import structure Inf              from "../rtt/Inf"
import structure Url              from "../system/Url"
import structure Component        from "../system/Component"
import structure ComponentManager from "../system/ComponentManager"

import structure Atom             from "../data/Atom"

import structure PrettyPrint      from "../utility/PrettyPrint"
import structure PPMisc           from "../rtt/PPMisc"
import signature PP_VALUE         from "PP_VALUE-sig"

structure PPValue :> PP_VALUE =
struct
    type doc    = PrettyPrint.doc
    type path   = Path.t
    type typ    = Type.t
    type value  = Reflect.value
    type format = {depth : int, width : int, prec : int}

    open Type
    open PervasiveType
    open PrettyPrint
    open PPMisc
    infixr ^^ ^/^


  (* Type registration *)

    val registry =
	PathMap.map() : (typ -> format -> value -> doc option) list PathMap.t

    fun registerTyp(p,f) =
	PathMap.insertWith op@ (registry, p, [UnsafeValue.cast f])

    fun unregisterTyp p =
	PathMap.remove(registry, p)

    fun tryRegistry(p,t,fm,x) =
	case PathMap.lookup(registry, p)
	 of NONE		=> NONE
	  | SOME fs		=> tryRegistry'(fs,t,fm,x)
    and tryRegistry'(fs,t,fm,x) =
	case fs
	 of []     => NONE
	  | f::fs' =>
	case f t fm (UnsafeValue.cast x)
	  of NONE => tryRegistry'(fs',t,fm,x)
	   | some => some


  (* Type inspection helpers *)

    datatype tag_desc = Nullary | Unary of typ | Nary of Type.row

    fun unapply  t     = unapply'(t,[])
    and unapply'(t,ts) =
	case inspect t
	 of Apply(t1,t2) => unapply'(t1,t2::ts)
	  | _            => (t,ts)
	
    fun unarg t =
	case inspect t
	 of Apply(t1,t2) =>
	    if not(equal(t1, typ_strict)) then Unary t else
	    (case inspect t2
	     of Prod r =>
		if isEmptyRow r
		then Nullary
		else Nary r
	      | _ => raise Type.Type
	    )
	  | _ => Unary t

    fun rowToLabs r = Vector.fromList(rowToLabs' r)
    and rowToLabs' r =
	case inspectRow r
	 of (UnknownRow | EmptyRow) => []
	  | FieldRow(l,_,r')        => l :: rowToLabs' r'

    fun rowToTyps r = Vector.fromList(rowToTyps' r)
    and rowToTyps' r =
	case inspectRow r
	 of (UnknownRow | EmptyRow) => []
	  | FieldRow(_,t,r')        => t :: rowToTyps' r'


  (* Special handling of lists *)

    val typ_list =
	let structure T = Reflect.ReflectType(type t = unit list)
	in #1(Type.asApply T.x) end

    datatype 'a list_desc = Det of 'a list * bool | Indet of 'a list * 'a list

    fun inspectList(n,x) = inspectList'(n,x,[])
    and inspectList'(n,x,xs) =
	if not(Future.isDetermined x) then Indet(List.rev xs, x) else
	if List.null x then Det(List.rev xs, false) else
	if n = 0 then Det(List.rev xs, true) else
	inspectList'(n-1, List.tl x, List.hd x :: xs)


  (* Limits and precedences *)

    val rootPrec	= 0
    val keywordPrec	= 10
    val applyPrec	= 10
    val atomPrec	= 11

    val defaultDepth	= ref 8
    val defaultWidth	= ref 16

    fun default()	= {depth = !defaultDepth, width = !defaultWidth,
			   prec = rootPrec}
    fun inner fm	= {(fm : format) where depth = #depth fm - 1}
    fun prec n fm	= {(fm : format) where prec = n}
    fun atomic fm	= prec atomPrec fm
    fun root fm		= prec rootPrec fm
    fun arg fm		= atomic(inner fm)
    fun elem fm		= root(inner fm)


  (* PP helpers *)

    fun parenPrec p (p',doc) =
	if p > p'
	then paren doc
	else doc

    fun ppApply (fm : format) args =
	parenPrec (#prec fm) (applyPrec, apply args)

    fun ppKeyword (fm : format) doc =
	parenPrec (#prec fm) (keywordPrec, doc)

    fun ppCustom fm (doc, docs) =
	ppKeyword fm (
	    abox(doc ^^
		nest(ebreak ^^
		     List.foldr (op ^/^) empty
			[contain ("{|", "|}") (ppCommaList id docs)]
		)
	    )
	)

  (* Values *)

    val absDoc = text "_val"
    val ellDoc = text "..."

    fun ppLab l = text(Label.toString l)

    fun ppVal  t x = ppVal' t (default()) x
    and ppVal' t fm x =
	if #depth fm <= 0 then text "_" else
	if Hole.isHole x then text "_hole" else
	case Future.status x
	 of Future.FUTURE =>
	    ppKeyword fm (text(if Future.isLazy x then "_lazy" else "_future"))
	  | Future.FAILED =>
	    let
		val e = Future.await x handle e => UnsafeValue.cast e
	    in
		ppCustom fm (text "_failed", [ppVal' typ_exn (elem fm) e])
	    end
	  | Future.DETERMINED =>
	case inspect t
	 of (Unknown _ | Var _) =>
		ppKeyword fm absDoc
	  | Con p =>
		ppCon p t fm x
	  | Arrow _ =>
		ppKeyword fm (text "_fn")
	  | Prod r =>
		ppProd (UnsafeValue.proj,UnsafeValue.projTuple) r fm x
	  | Sum r =>
	    let
		val ls   = rowToLabs r
		val i    = UnsafeValue.tag(x,ls)
		val l    = Vector.sub(ls,i)
		val doc0 = text(Label.toString l)
		val fm'  = arg fm
	    in
		case unarg(lookupRow(r,l))
		 of Nullary  => doc0
		  | Unary t' =>
		    let
			val x' = UnsafeValue.projTaggedTuple(x,1,0)
		    in
			ppApply fm (doc0, [ppVal' t' fm' x'])
		    end
		  | Nary r' =>
		    let
			val doc' = ppProd (UnsafeValue.projTagged,
					   UnsafeValue.projTaggedTuple) r' fm' x
		    in
			ppApply fm (doc0, [doc'])
		    end
	    end
	  | (All(a,t') | Exist(a,t')) =>
		ppVal' t' fm x
	  | Lambda(a,t') =>
		raise Type.Type
	  | Apply _ =>
	    let
		val (t',ts) = unapply t
	    in
		if Type.equal(t', typ_list) then ppList t fm x else
		case inspect t'
		 of Mu _  => ppVal' (unroll t) fm x
		  | Con p => ppCon p t fm x
		  | _     => raise Type.Type
	    end
	  | Mu t' =>
		ppVal' (unroll t) fm x

    and ppCon p t fm x =
	case tryRegistry(p,t,fm,x)
	 of SOME doc => doc
	  | NONE     =>
	if not(isExtKind(kind t)) then ppKeyword fm absDoc else
	let
	    val con  = UnsafeValue.con x
	    val doc0 = text(Name.toString(UnsafeValue.conName con))
	in
	    if UnsafeValue.same(con,x)
	    then doc0
	    else apply(doc0, [ppKeyword (arg fm) absDoc])
	end

    and ppProd (unsafe_proj, unsafe_projTuple) r fm x =
	if isTupleRow r andalso Vector.length(asTupleRow r) <> 1 then
	    let
		val ts      = asTupleRow r
		val n       = Vector.length ts
		val w       = #width fm
		val (n',ds) = if n <= w then (n,[]) else (w,[ellDoc])
		val fm'     = elem fm
		val docs'   = VectorSlice.foldri
				(fn(i,t',docs) =>
				    ppVal' t' fm' (unsafe_projTuple(x,n,i))
				    :: docs
				) ds (VectorSlice.slice(ts,0,SOME n'))
	    in
		paren(
		    ppCommaList id docs'
		)
	    end
	else
	    let
		val ls      = rowToLabs r
		val ts      = rowToTyps r
		val n       = Vector.length ls
		val w       = #width fm
		val (n',ds) = if n <= w then (n,[]) else (w,[ellDoc])
		val fm'     = elem fm
		val docs'   = VectorSlice.foldri
				(fn(i,t',docs) =>
				 let
				    val l    = Vector.sub(ls,i)
				    val doc' =
					ppVal' t' fm' (unsafe_proj(x,ls,i))
				 in
				    abox(nest(
					text(Label.toString l) ^^
					text " =" ^/^
					doc'
				    )) :: docs
				 end) ds (VectorSlice.slice(ts,0,SOME n'))
	    in
		brace(
		    ppCommaList id docs'
		)
	    end

    and ppList t fm x =
	let
	    val (_,t') = Type.asApply t
	in
	    case inspectList(#width fm, UnsafeValue.cast x)
	     of Det(xs,ell) =>
		let
		    val ppElem = ppVal' t' (elem fm)
		in
		    contain ("[", "]") (
			ppCommaList ppElem xs ^^
			(if ell then text "," ^/^ ellDoc else empty)
		    )
		end
	      | Indet(xs,x') =>
		let
		    val fm'    = prec 6 (inner fm)
		    val ppElem = ppVal' t' fm'
		    val doc = List.foldr
				(fn(x,doc) => ppElem x ^^ text " ::" ^/^ doc)
				(ppVal' t fm' (UnsafeValue.cast x')) xs
		in
		    parenPrec (#prec fm) (5, abox doc)
		end
	end
	


  (* Pervasive types *)

    fun ppInt t fm x	= SOME(text(Int.toString x))
    fun ppIntInf t fm x	= SOME(text(IntInf.toString x))
    fun ppWord t fm x	= SOME(text("0wx" ^ Word.toString x))
    fun ppWord8 t fm x	= SOME(text("0wx" ^ Word8.toString x))
    fun ppReal t fm x	= SOME(text(Real.toString x))
    fun ppChar t fm x	= SOME(text("#\"" ^ Char.toString x ^ "\""))
    fun ppString t (fm : format) x =
	if String.size x <= #width fm
	then SOME(text("\"" ^ String.toString x ^ "\""))
	else SOME(text("\"" ^ String.toString(String.substring(x,0,#width fm))
			    ^ "\\...\""))

    fun ppExn t fm x =
	case x
	 of ( Bind | Chr | Div | Domain | Match | Overflow
	    | Size | Span | Subscript | IEEEReal.Unordered
	    | Alt.Alt | Option.Option | Time.Time
	    | Future.Cyclic | Promise.Promise
	    | Thread.Terminate | Thread.Terminated ) =>
	    SOME(
		text(General.exnName x)
	    )
	  | Fail x' =>
	    SOME(
		ppApply fm (text(General.exnName x),
			    [ppVal' typ_string (arg fm) x'])
	    )
	  | Package.Mismatch _ =>
	    SOME(
		ppApply fm (text(General.exnName x),
			    [ppKeyword (arg fm) absDoc])
	    )
	  | _ => NONE

    fun ppRef t fm x =
	let
	    val (_,t') = Type.asApply t
	    val ppElem = ppVal' t' (arg fm)
	in
	    SOME(
		ppApply fm (text "ref", [ppElem(!x)])
	    )
	end

    fun ppVector t fm =
	let
	    val (_,t') = Type.asApply t
	    val ppElem = ppVal' t' (elem fm)
	in
	    fn x =>
	    let
		val (n,doc0) = if Vector.length x <= #width fm
				then (Vector.length x, empty)
				else (#width fm, text "," ^/^ ellDoc)
		val xs = VectorSlice.toList(VectorSlice.slice(x,0,SOME n))
	    in
		SOME(
		    contain ("#[", "]") (
			ppCommaList ppElem xs ^^ doc0
		    )
		)
	    end
	end

    fun ppArray t fm =
	let
	    val (_,t') = Type.asApply t
	    val ppElem = ppVal' t' (elem fm)
	in
	    fn x =>
	    let
		val (n,doc0) = if Array.length x <= #width fm
				then (Array.length x, [])
				else (#width fm, [ellDoc])
		val xs = ArraySlice.toList(ArraySlice.slice(x,0,SOME n))
	    in
		SOME(ppCustom fm (text "array", List.map ppElem xs @ doc0))
		(*SOME(
		    contain ("[|", "|]") (
			ppCommaList ppElem xs ^^ doc0
		    )
		)*)
	    end
	end


  (* Other types in lib/fundamental *)

    fun ppPromise t fm x =
	let
	    val (_,t') = Type.asApply t
	    val ppElem = ppVal' t' (elem fm)
	in
	    SOME(ppCustom fm (text "promise", [ppElem(Promise.future x)]))
	end

    fun ppMonoRow (s,length,sliceList) t' t fm =
	let
	    val ppElem = ppVal' t' (elem fm)
	in
	    fn x =>
	    let
		val (n,doc0) = if length x <= #width fm
				then (length x, [])
				else (#width fm, [ellDoc])
		val xs = sliceList(x,n)
	    in
		SOME(ppCustom fm (text s, List.map ppElem xs @ doc0))
	    end
	end

    val ppWord8Vector' = ppMonoRow("vector", Word8Vector.length,
				  fn(x,n) => Word8VectorSlice.toList
					  (Word8VectorSlice.slice(x,0,SOME n)))
    val ppWord8Array'  = ppMonoRow("array", Word8Array.length,
				  fn(x,n) => Word8ArraySlice.toList
					  (Word8ArraySlice.slice(x,0,SOME n)))
    val ppCharArray'   = ppMonoRow("array", CharArray.length,
				  fn(x,n) => CharArraySlice.toList
					  (CharArraySlice.slice(x,0,SOME n)))

    fun ppMonoSlice base t' t fm x =
	let
	    val (s,i,n) = base x
	    val  docs'  = [ppVal' t' (elem fm) s,
			   text(Int.toString i),
			   text(Int.toString n)]
	in
	    SOME(ppCustom fm (text "slice", docs'))
	end

    val ppWord8VectorSlice' = ppMonoSlice Word8VectorSlice.base
    val ppWord8ArraySlice'  = ppMonoSlice Word8ArraySlice.base
    val ppCharVectorSlice'  = ppMonoSlice CharVectorSlice.base
    val ppCharArraySlice'   = ppMonoSlice CharArraySlice.base

    fun ppVectorSlice t fm x =
	let
	    val  t'     = Type.apply(typ_vec, #2(Type.asApply t))
	    val (v,i,n) = VectorSlice.base x
	    val  docs'  = [ppVal' t' (elem fm) v,
			   text(Int.toString i),
			   text(Int.toString n)]
	in
	    SOME(ppCustom fm (text "slice", docs'))
	end

    fun ppArraySlice t fm x =
	let
	    val  t'     = Type.apply(typ_array, #2(Type.asApply t))
	    val (a,i,n) = ArraySlice.base x
	    val  docs'  = [ppVal' t' (elem fm) a,
			   text(Int.toString i),
			   text(Int.toString n)]
	in
	    SOME(ppCustom fm (text "slice", docs'))
	end

    fun ppAtom t fm x =
	let
	    val doc' = ppVal' typ_string (elem fm) (Atom.toString x)
	in
	    SOME(ppCustom fm (text "atom", [doc']))
	end

    fun ppTime t fm x =
	SOME(ppCustom fm (text "time",
		[text(LargeInt.toString(Time.toMicroseconds x) ^ "us")]))

    fun ppThread t fm x =
	let
	    structure T = Reflect.ReflectType(type t = Thread.state)
	in
	    SOME(ppCustom fm (text "thread", [ppVal T.x (Thread.state x)]))
	end

    fun ppLock t fm x =
	SOME(ppCustom fm (text "lock", []))

    fun ppValPackage t fm x =
	let
	    (* TODO: extract value *)
	in
	    SOME(ppCustom fm (text "val_package", [text "..."]))
	end

    fun ppPackage t fm x =
	let
	    (* TODO: what do we display here? *)
	in
	    SOME(ppCustom fm (text "package", [text "..."]))
	end

  (* Register *)

    val coreSig = Inf.asSig(Option.valOf
			(Component.inf(ComponentManager.link
			  (Url.fromString "x-alice:/lib/fundamental/Core"))))
    val packageSig = Inf.asSig(Option.valOf
			(Component.inf(ComponentManager.link
			  (Url.fromString "x-alice:/lib/fundamental/Package"))))
    val atomSig = Inf.asSig(Option.valOf
			(Component.inf(ComponentManager.link
			  (Url.fromString "x-alice:/lib/data/Atom"))))

    fun lookupTyp(sign, modLab, typLab) =
	let
	    val sign' = Inf.asSig(Inf.lookupMod(sign, Label.fromString modLab))
	    val typ   = Inf.lookupTyp'(sign', Label.fromString typLab)
	in
	    if Type.isApply typ then #1(Type.asApply typ) else typ
	end

    fun lookupPath(sign, modLab, typLab) =
	Type.asCon(lookupTyp(sign, modLab, typLab))

    val path_word8	   = lookupPath(coreSig,"Word8","word")
    val path_intInf	   = lookupPath(coreSig,"IntInf","int")
    val path_promise	   = lookupPath(coreSig,"Promise","promise")
    val path_atom          = lookupPath(atomSig,"Atom","atom")
    val path_time	   = lookupPath(coreSig,"Time","time")
    val path_thread	   = lookupPath(coreSig,"Thread","thread")
    val path_lock	   = lookupPath(coreSig,"Lock","lock")
    val path_package	   = lookupPath(packageSig,"Package","package")
    val path_val_package   = lookupPath(packageSig,"Package","val_package")
    val path_word8_vector  = lookupPath(coreSig,"Word8Vector","vector")
    val path_word8_array   = lookupPath(coreSig,"Word8Array","array")
    val path_char_array    = lookupPath(coreSig,"CharArray","array")
    val path_vector_slice  = lookupPath(coreSig,"VectorSlice","slice")
    val path_array_slice   = lookupPath(coreSig,"ArraySlice","slice")
    val path_word8_vector_slice = lookupPath(coreSig,"Word8VectorSlice","slice")
    val path_word8_array_slice  = lookupPath(coreSig,"Word8ArraySlice","slice")
    val path_char_vector_slice  = lookupPath(coreSig,"CharVectorSlice","slice")
    val path_char_array_slice   = lookupPath(coreSig,"CharArraySlice","slice")

    val typ_word8         = lookupTyp(coreSig,"Word8","word")
    val typ_word8_vector  = lookupTyp(coreSig,"Word8Vector","vector")
    val typ_word8_array   = lookupTyp(coreSig,"Word8Array","array")
    val typ_char_array    = lookupTyp(coreSig,"CharArray","array")

    val _ = registerTyp(path_int,           ppInt)
    val _ = registerTyp(path_intInf,        ppIntInf)
    val _ = registerTyp(path_word,          ppWord)
    val _ = registerTyp(path_word8,         ppWord8)
    val _ = registerTyp(path_real,          ppReal)
    val _ = registerTyp(path_char,          ppChar)
    val _ = registerTyp(path_string,        ppString)
    val _ = registerTyp(path_exn,           ppExn)
    val _ = registerTyp(path_ref,           ppRef)
    val _ = registerTyp(path_promise,       ppPromise)
    val _ = registerTyp(path_vec,           ppVector)
    val _ = registerTyp(path_array,         ppArray)
    val _ = registerTyp(path_vector_slice,  ppVectorSlice)
    val _ = registerTyp(path_array_slice,   ppArraySlice)
    val _ = registerTyp(path_atom,          ppAtom)
    val _ = registerTyp(path_time,          ppTime)
    val _ = registerTyp(path_thread,        ppThread)
    val _ = registerTyp(path_lock,          ppLock)
    val _ = registerTyp(path_package,       ppPackage)
    val _ = registerTyp(path_val_package,   ppValPackage)
    val _ = registerTyp(path_word8_vector,  ppWord8Vector' typ_word8)
    val _ = registerTyp(path_word8_array,   ppWord8Array' typ_word8)
    val _ = registerTyp(path_char_array,    ppCharArray' typ_char)
    val _ = registerTyp(path_word8_vector_slice,
			ppWord8VectorSlice' typ_word8_vector)
    val _ = registerTyp(path_word8_array_slice,
			ppWord8ArraySlice' typ_word8_array)
    val _ = registerTyp(path_char_vector_slice,
			ppCharVectorSlice' typ_string)
    val _ = registerTyp(path_char_array_slice,
			ppCharArraySlice' typ_char_array)
end
