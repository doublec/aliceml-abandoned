(*
 * Authors:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt and Andreas Rossberg, 2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure OS      from "OS"
import structure IO      from "IO"
import signature PRIM_IO from "PRIM_IO-sig"

functor PrimIO(structure V: MONO_VECTOR
	       structure A: MONO_ARRAY
		   where type vector = V.vector
		     and type elem = V.elem
	       val someElem: A.elem
	       eqtype pos
	       val compare: pos * pos -> order) :>
    PRIM_IO
	where type elem = A.elem
	  and type vector = A.vector
	  and type array = A.array
	  and type pos = pos =
    struct
	type elem = A.elem
	type vector = A.vector
	type array = A.array

	type pos = pos
	val compare = compare

	datatype reader = RD of
	    {name: string,
	     chunkSize: int,
	     readVec: (int -> vector) option,
	     readArr: ({buf: array, i: int, sz: int option} -> int) option,
	     readVecNB: (int -> vector option) option,
	     readArrNB:
		 ({buf: array, i: int, sz: int option} -> int option) option,
	     block: (unit -> unit) option,
	     canInput: (unit -> bool) option,
	     avail: unit -> int option,
	     getPos: (unit -> pos) option,
	     setPos: (pos -> unit) option,
	     endPos: (unit -> pos) option,
	     verifyPos: (unit -> pos) option,
	     close: unit -> unit,
	     ioDesc: OS.IO.iodesc option}

	datatype writer = WR of
	    {name: string,
	     chunkSize: int,
	     writeVec: ({buf: vector, i: int, sz: int option} -> int) option,
	     writeArr: ({buf: array, i: int, sz: int option} -> int) option,
	     writeVecNB:
		 ({buf: vector, i: int, sz: int option} -> int option) option,
	     writeArrNB:
		 ({buf: array, i: int, sz: int option} -> int option) option,
	     block: (unit -> unit) option,
	     canOutput: (unit -> bool) option,
	     getPos: (unit -> pos) option,
	     setPos: (pos -> unit) option,
	     endPos: (unit -> pos) option,
	     verifyPos: (unit -> pos) option,
	     close: unit -> unit,
	     ioDesc: OS.IO.iodesc option}

	fun v_extract (v, i, n) = V.tabulate (n, fn j => V.sub (v, i + j))
	fun a_extract (a, i, n) = V.tabulate (n, fn j => A.sub (a, i + j))
	fun a_extract' (a, i, SOME n) = a_extract (a, i, n)
	  | a_extract' (a, i, NONE) = a_extract (a, i, A.length a - i)

	fun a_copyVecSlice' (src, si, dst, di, 0) = ()
	  | a_copyVecSlice' (src, si, dst, di, len) =
	    (A.update (dst, di, V.sub (src, si));
	     a_copyVecSlice' (src, si + 1, dst, di + 1, len - 1))
	fun a_copyVecSlice {src, si, dst, di, len} =
	    if si < 0 orelse di < 0 orelse si + len > V.length src
				    orelse di + len > A.length dst
	    then raise General.Subscript
	    else a_copyVecSlice' (src, si, dst, di, len)

	fun openVector v =
	    let
		val pos = ref 0
		val closed = ref false
		fun check f x =
		    let
			val p = Promise.promise ()
		    in
			if Ref.exchange (closed, Promise.future p) then
			    (Promise.fulfill (p, true);
			     raise IO.ClosedStream)
			else (f x before Promise.fulfill (p, false))
		    end

		fun readVec sz =
		    let
			val p = !pos
			val n = Int.min (V.length v - p, sz)
		    in
			case Int.compare (n, 0) of
			    LESS => raise General.Size
			  | EQUAL => raise General.Domain
			  | GREATER => (pos := p + n; v_extract (v, p, n))
		    end

		fun readArr {buf, i, sz} =
		    let
			val p = !pos
			val sz = Option.getOpt (sz, A.length buf - i)
			val n = Int.min (V.length v - p, sz)
		    in
			case Int.compare (n, 0) of
			    LESS => raise General.Size
			  | EQUAL => raise General.Domain
			  | GREATER => (pos := p + n;
					a_copyVecSlice {src = v, si = p,
							len = n,
							dst = buf, di = i};
					n)
		    end
	    in
		RD {name = "vector",
		    chunkSize = V.length v,
		    readVec = SOME (check readVec),
		    readArr = SOME (check readArr),
		    readVecNB = SOME (check (fn x => if Future.isFuture v
						     then NONE
						     else SOME (readVec x))),
		    readArrNB = SOME (check (fn x => if Future.isFuture v
						     then NONE
						     else SOME (readArr x))),
		    block = SOME (check (fn () => ignore (Future.await v))),
		    canInput = SOME (check (fn () => not (Future.isFuture v))),
		    avail = check (fn () => NONE),
		    getPos = NONE,
		    setPos = NONE,
		    endPos = NONE,
		    verifyPos = NONE,
		    close = fn () => closed := true,
		    ioDesc = NONE}
	    end

	fun len (len, i, sz) =
	    (if i < 0 orelse i > len then raise General.Subscript else ();
	     case sz of
		 SOME sz =>
		     if sz > len - i then raise General.Size else sz
	       | NONE => len - i)

	fun nullRd (): reader =
	    let
		val closed = ref false
		fun check x _ =
		    let
			val p = Promise.promise ()
		    in
			if Ref.exchange (closed, Promise.future p) then
			    (Promise.fulfill (p, true);
			     raise IO.ClosedStream)
			else (Promise.fulfill (p, false); x)
		    end
	    in
		RD {name = "null",
		    chunkSize = 1,
		    readVec = SOME (check (V.fromList nil)),
		    readArr = SOME (check 0),
		    readVecNB = SOME (check (SOME (V.fromList nil))),
		    readArrNB = SOME (check (SOME 0)),
		    block = SOME (check ()),
		    canInput = SOME (check true),
		    avail = check (SOME 0),
		    getPos = NONE,
		    setPos = NONE,
		    endPos = NONE,
		    verifyPos = NONE,
		    close = fn () => closed := true,
		    ioDesc = NONE}
	    end

	fun nullWr (): writer =
	    let
		val closed = ref false
		fun check f x =
		    let
			val p = Promise.promise ()
		    in
			if Ref.exchange (closed, Promise.future p) then
			    (Promise.fulfill (p, true);
			     raise IO.ClosedStream)
			else (Promise.fulfill (p, false); f x)
		    end
	    in
		WR {name = "null",
		    chunkSize = 1,
		    writeVec = SOME (fn {buf, i, sz} =>
					check len (V.length buf, i, sz)),
		    writeArr = SOME (fn {buf, i, sz} =>
					check len (A.length buf, i, sz)),
		    writeVecNB =
			SOME (fn {buf, i, sz} =>
				 check (SOME o len) (V.length buf, i, sz)),
		    writeArrNB =
			SOME (fn {buf, i, sz} =>
				 check (SOME o len) (A.length buf, i, sz)),
		    block = SOME (check (fn () => ())),
		    canOutput = SOME (check (fn () => true)),
		    getPos = NONE,
		    setPos = NONE,
		    endPos = NONE,
		    verifyPos = NONE,
		    close = fn () => closed := true,
		    ioDesc = NONE}
	    end

	fun augmentReader (RD {name, chunkSize, readVec, readArr, readVecNB,
			       readArrNB, block, canInput, avail, getPos,
			       setPos, endPos, verifyPos, close, ioDesc}) =
	    let
		val readVec' =
		    if isSome readVec then readVec
		    else if isSome readArr then
			SOME (fn sz =>
			      let
				  val buf = A.array (sz, someElem)
				  val i = valOf readArr {buf, i = 0, sz = NONE}
			      in
				  a_extract (buf, 0, i)
			      end)
		    else if isSome block then (*--** first read, then block *)
			if isSome readVecNB then
			    SOME (fn sz => (valOf block ();
					    valOf (valOf readVecNB sz)))
			else if isSome readArrNB then
			    SOME (fn sz =>
				  let
				      val _ = valOf block ()
				      val buf = A.array (sz, someElem)
				      val i = valOf (valOf readArrNB
						  {buf, i = 0, sz = NONE})
				  in
				      a_extract (buf, 0, i)
				  end)
			else NONE
		    else NONE
		val readArr' =
		    if isSome readArr then readArr
		    else if isSome readVec then
			SOME (fn {buf, i, sz} =>
			      let
				  val k = case sz of
					     SOME k => k
					   | NONE => A.length buf - i
				  val v = valOf readVec k
			      in
				  A.copyVec {src = v, dst = buf, di = i};
				  V.length v
			      end)
		    else if isSome block then (*--** first read, then block *)
			if isSome readArrNB then
			    SOME (fn {buf, i, sz} =>
				  (valOf block ();
				   valOf (valOf readArrNB {buf, i, sz})))
			else if isSome readVecNB then
			    SOME (fn {buf, i, sz} =>
				  let
				      val _ = valOf block ()
				      val k = case sz of
						  SOME k => k
						| NONE => A.length buf - i
				      val v = valOf (valOf readVecNB k)
				  in
				      A.copyVec {src = v, dst = buf, di = i};
				      V.length v
				  end)
			else NONE
		    else NONE
		val readVecNB' =
		    if isSome readVecNB then readVecNB
		    else if isSome readArrNB then
			SOME (fn sz =>
			      let
				  val buf = A.array (sz, someElem)
			      in
				  case valOf readArrNB {buf,i=0,sz=NONE} of
				      SOME i =>
					  SOME (a_extract (buf, 0, i))
				    | NONE => NONE
			      end)
		    else if Option.isSome canInput then
			if Option.isSome readVec then
			    SOME (fn sz =>
				  if valOf canInput () then
				      SOME (valOf readVec sz)
				  else NONE)
			else if Option.isSome readArr then
			    SOME (fn sz =>
				  if valOf canInput () then
				      let
					  val buf = A.array (sz, someElem)
					  val i =
					      valOf readArr {buf, i=0, sz=NONE}
				      in
					  SOME (a_extract (buf, 0, i))
				      end
				  else NONE)
			else NONE
		    else NONE
		val readArrNB' =
		    if Option.isSome readArrNB then readArrNB
		    else if Option.isSome readVecNB then
			SOME (fn {buf, i, sz} =>
			      if valOf canInput () then
				  let
				      val k = case sz of
						  SOME k => k
						| NONE => A.length buf - i
				      val v = valOf readVec k
				  in
				      A.copyVec {src = v, dst = buf, di = i};
				      SOME (V.length v)
				  end
			      else NONE)
		    else if Option.isSome canInput then
			if Option.isSome readArr then
			    SOME (fn {buf, i, sz} =>
				  if valOf canInput () then
				      SOME (valOf readArr {buf, i, sz})
				  else NONE)
			else if Option.isSome readVec then
			    SOME (fn {buf, i, sz} =>
				  if valOf canInput () then
				      let
					  val k = case sz of
						      SOME k => k
						    | NONE => A.length buf - i
					  val v = valOf readVec k
				      in
					  A.copyVec {src = v, dst = buf,
						     di = i};
					  SOME (V.length v)
				      end
				  else NONE)
			else NONE
		    else NONE
	    in
		RD {name, chunkSize, readVec = readVec', readArr = readArr',
		    readVecNB = readVecNB', readArrNB = readArrNB', block,
		    canInput, avail, getPos, setPos, endPos, verifyPos,
		    close, ioDesc}
	    end

	fun augmentWriter (WR {name, chunkSize, writeVec, writeArr, writeVecNB,
			       writeArrNB, block, canOutput, getPos, setPos,
			       endPos, verifyPos, close, ioDesc}) =
	    let
		val writeVec' =
		    if isSome writeVec then writeVec
		    else if isSome writeArr then
			SOME (fn {buf, i, sz} =>
			      let
				  val n = len (V.length buf, i, sz)
				  val a = A.array (n, someElem)
			      in
				  a_copyVecSlice {src = buf, si = i, len = n,
						  dst = a, di = 0};
				  valOf writeArr {buf = a, i = 0, sz = NONE}
			      end)
		    else if isSome block then (*--** first write, then block *)
			if isSome writeVecNB then
			    SOME (fn {buf, i, sz} =>
				  (valOf block ();
				   valOf (valOf writeVecNB {buf, i, sz})))
			else if isSome writeArrNB then
			    SOME (fn {buf, i, sz} =>
				  let
				      val _ = valOf block ()
				      val n = len (V.length buf, i, sz)
				      val a = A.array (n, someElem)
				  in
				      a_copyVecSlice {src = buf, si = i,
						      len = n, dst = a,
						      di = 0};
				      valOf (valOf writeArrNB
					  {buf = a, i = 0, sz = SOME n})
				  end)
			else NONE
		    else NONE
		val writeArr' =
		    if isSome writeArr then writeArr
		    else if isSome writeVec then
			SOME (fn {buf, i, sz} =>
			      valOf writeVec
				  {buf = a_extract' (buf, i, sz),
				   i = 0, sz = NONE})
		    else if isSome block then (*--** first write, then block *)
			if isSome writeArrNB then
			    SOME (fn {buf, i, sz} =>
				  (valOf block ();
				   valOf (valOf writeArrNB {buf, i, sz})))
			else if isSome writeVecNB then
			    SOME (fn {buf, i, sz} =>
				  (valOf block ();
				   valOf (valOf writeVecNB
				       {buf = a_extract' (buf, i, sz),
					i = 0, sz = NONE})))
			else NONE
		    else NONE
		val writeVecNB' =
		    if isSome writeVecNB then writeVecNB
		    else if isSome writeArrNB then
			SOME (fn {buf, i, sz} =>
			      let
				  val n = len (V.length buf, i, sz)
				  val a = A.array (n, someElem)
			      in
				  a_copyVecSlice {src = buf, si = i, len = n,
						  dst = a, di = 0};
				  valOf writeArrNB
				      {buf = a, i = 0, sz = SOME n}
			      end)
		    else if isSome canOutput then
			if isSome writeVec then
			    SOME (fn {buf, i, sz} =>
				  if valOf canOutput () then
				      SOME (valOf writeVec {buf, i, sz})
				  else NONE)
			else if isSome writeArr then
			    SOME (fn {buf, i, sz} =>
				  if valOf canOutput () then
				      let
					  val n = len (V.length buf, i, sz)
					  val a = A.array (n, someElem)
				      in
					  a_copyVecSlice {src = buf, si = i,
							  len = n, dst = a,
							  di = 0};
					  SOME (valOf writeArr
						{buf = a, i = 0, sz = NONE})
				      end
				  else NONE)
			else NONE
		    else NONE
		val writeArrNB' =
		    if isSome writeArrNB then writeArrNB
		    else if isSome writeVecNB then
			SOME (fn {buf, i, sz} =>
			      valOf writeVecNB
				  {buf = a_extract' (buf, i, sz), i = 0,
				   sz = NONE})
		    else if isSome canOutput then
			if isSome writeArr then
			    SOME (fn {buf, i, sz} =>
				  if valOf canOutput () then
				      SOME (valOf writeArr {buf, i, sz})
				  else NONE)
			else if isSome writeVec then
			    SOME (fn {buf, i, sz} =>
				  if valOf canOutput () then
				      SOME (valOf (valOf writeVecNB
					  {buf = a_extract' (buf, i, sz),
					   i = 0, sz = NONE}))
				  else NONE)
			else NONE
		    else NONE
	    in
		WR {name, chunkSize, writeVec = writeVec',
		    writeArr = writeArr', writeVecNB = writeVecNB',
		    writeArrNB = writeArrNB', block, canOutput, getPos,
		    setPos, endPos, verifyPos, close, ioDesc}
	    end

    end
