\documentclass{article}
\usepackage{german}

\setlength{\textwidth}{14cm}
\setlength{\oddsidemargin}{1cm}

\begin{document}

\begin{center}
\begin{huge}Fopra: GTK f"ur Alice\end{huge}

Abschlussbericht

Robert Grabowski

\end{center}

\section{Einleitung}

In diesem Bericht werden Entwurf und Implementierung der 
GTK+-Schnittstelle f"ur Alice beschrieben. Mit GTK+ lassen sich relativ einfach
grafische Benutzeroberfl"achen in C erstellen. Durch die Schnittstelle soll
dies auch dem Alice-Programmierer m"oglich sein.

\subsection{Vorgeschichte des Bindings}

Als Grundlage f"ur diese Arbeit dienen zwei bereits existierende
Schnittstellen f"ur GTK+ 1.2 von Thorsten Brunklaus:
eine Anbindung an Mozart, und eine an Alice auf der Mozart-VM.
Die hier besprochene Schnittstelle bindet GTK+ 2.x an Alice auf der SEAM-VM.
Alle erw"ahnten Schnittstellen sind sowohl unter Windows als auch unter
Linux lauff"ahig.

Benutzt werden die GTK-Schnittstellen unter anderem von den Inspector-Tools.

\section{GTK+}

\subsection{Einleitung}

GTK+ ist ein Bibliothekspaket zum komfortablen Erstellen von grafischen
Benutzeroberfl"achen. Urspr"unglich im Jahr 1996 nur zur Verwendung im
Grafikprogramm GIMP geschrieben (Fussnote: GTK=GIMP Toolkit), bildet es
inzwischen die Grundlage sehr vieler Anwendungen, insbesondere des 
GNOME-Desktops. GTK+ ist komplett
in C geschrieben, doch bei der Entwicklung wurde von Anfang an darauf geachtet,
m"oglichst gute Voraussetzungen f"ur die Anbindung an andere
Programmiersprachen zu schaffen.

\subsection{Konzept-"Uberblick}

\subsection{Aufbau}

GTK+ in der Version 2.0 besteht aus folgenden Bibliotheken: (Bild???)

\begin{itemize}
\item GLib -- grundlegende Funktionen wie das Klassensystem und
      das automatische Speichermanagement
\item GDK -- plattformunabh"angige Abstraktion der grafischen
      Zeichenfunktionen des Betriebssystems
\item Pango -- abstrahiert Schriftartenfunktionen des Betriebssystems
\item ATK -- stellt Funktionen f"ur Eingabehilfen zur Verf"ugung
\item GTK -- enth"alt die eigentliche Sammlung von Widgets
\end{itemize}

In diesem Alice-GTK+-Binding werden nur Schnittstellen f"ur die Bibliotheken
GTK und GDK generiert, denn auf die anderen Bibliotheken muss in der Regel beim
Programmieren von GTK-Anwendungen nicht direkt zugegriffen werden.

\subsection{GnomeCanvas}

Dar"uberhinaus enth"alt das Binding eine Schnittstelle f"ur die GnomeCanvas-
Bibliothek. Diese enth"alt das GnomeCanvas-Widget, welches eine abstrakte
grafische Zeichenfl"ache darstellt, auf die man Texte, Bilder und primitive
Objekte zeichnen kann. Das GnomeCanvas ist nicht Teil von GTK+, sondern
geh"ort bereits zum Gnome-Projekt.

Die Schnittstelle f"ur das GnomeCanvas ist erforderlich, da diverse Alice-Tools
wie der Inspector dieses Widget zentral zum Anzeigen von Informationen
nutzen.

\section{Alice-Schnittstellen f"ur C-Bibliotheken}

Dieser Abschnitt enth"alt allgemeine Betrachtungen zur Entwicklung von
Alice-Schnittstellen f"ur C-Bibliotheken. Gleichzeitig wird angedeutet,
wie gewisse Probleme in der GTK-Schnittstelle gel"ost sind.

\subsection{Funktions-Abbildung}

Eine Alice-Schnittstelle soll die Funktionalit"at einer C-Bibliothek
in Alice verf"ugbar machen. Die C-Schnittstelle einer solchen Bibliothek
besteht dabei im Wesentlichen aus Deklarationen von Funktionen und von
komplexen Datentypen.

Es spricht wenig dagegen, Wrapper um die Bibliotheksfunktion zu schreiben,
so dass diese als Alice-Funktionen verf"ugbar sind. 

Diese Bibliotheksfunktionen nehmen jedoch C-Werte entgegen und liefern sie
zur"uck, und daher es stellt sich die Frage, wie diese C-Werte in Alice
dargestellt werden sollen, d.h. wie primitive und komplexe C-Datentypen
auf Alice-Typen abgebildet werden.
Hierf"ur gibt es verschiedene M"oglichkeiten.

\subsection{Datentyp-Abbildung}

Eine L"osung besteht darin, alle C-Werte in Alice als Werte von abstrakten
Datentypen darzustellen. In diesem Fall muss die Schnittstelle aber Operatoren
f"ur diese abstrakten Typen zur Verf"ugung stellen, wie z.B. Zuweisungs- und
Vergleichsoperatoren f"ur C-Integers.
Zwar erh"alt dieser Weg die gesamten M"oglichkeiten einer C-Bibliothek,
jedoch wird durch den indirekten Zugriff auf C-Werte die Programmierung
unter Alice deutlich erschwert.

Als Alternative kann man versuchen, f"ur alle C-Typen ein m"oglichst
"ahnliches Alice-Pendant zu finden. Das erleichtert den Umgang mit der
Schnittstelle, jedoch entsteht im Binding ein zus"atzlicher, ineffizienter
Overhead f"ur die st"andige Datenkonversion, und nicht immer gibt es
ein passendes Typ-"Aquivalent in Alice. Oft ist es ohne Meta-Daten auch nicht
ersichtlich, anhand der C-Schnittstelle einer Bibliothek die Semantik eines
Typs zu erschlie"sen. (Fussnote Erklaerung)

Das GTK-Binding geht einen Mittelweg zwischen beiden genannten ``Extremen'',
welcher im Abschnitt ??? erkl"art wird.
Da es keine Annotation der Schnittstelle mit Meta-Daten gibt, werden an einigen
Stellen einfach Annahmen gemacht, die zumindest auf die GTK+-Bibliotheken
zutreffen.

\subsection{Automatische Generierung und manuelle Behandlung}

Sobald man sich auf eine bestimmte Abbildung festgelegt hat, k"onnen diese
Aspekte der Schnittstelle weitestgehend automatisch anhand der Bibliotheks-
Deklarationen generiert werden. Der Aufbau des Generators f"ur das GTK-Binding
wird in Abschnitt ??? erkl"art.

Die so generierte Alice-Schnittstelle ist im Wesentlichen eine 1:1-Abbildung
der C-Bibliothek. Weil die Bibliothek unter Alice also genauso benutzt wird
wie unter C, sind die entstehenden Alice-Programme reichlich imperativ und auf
Seiteneffekten beruhend. W"unschenswert w"are hier eine Abstraktion der
einzelnen Funktionsaufrufe in einer h"oheren, funktionalen Schicht.
Dies ist jedoch nicht Teil dieses Fopras.

Es kann jedoch passieren, dass gewisse Teile der Schnittstelle auf jeden Fall
von Hand geschrieben werden m"ussen, weil eine naive Benutzung der Bibliothek
fundamentale Alice-Konzepte wie Nebenl"aufigkeit aushebelt. Die
GTK-Schnittstelle fasst diese Spezialbehandlungen im sogenannten ``Core''
zusammen, welcher in Abschnitt ??? erkl"art wird.

\section{GTK-Schnittstelle}

(Uebersicht; relativ grob; wie auf Folie)

\section{Abbildung der Datentypen}

Allgemein werden C-Objekte nach dem Schema in Tabelle ??? abgebildet.
Die folgenden Unterabschnitte beschreiben besondere Details. 

\textbf{Primitive Datentypen} werden auf m"oglichst "ahnliche primitive
Alice-Typen abgebildet. Ein "Uberblick gibt Tabelle ???.
(object, object list erklaeren)

\textbf{Enumerationstypen} werden auf Alice-Datatypes mit nullstelligen
Konstruktoren abgebildet. Dadurch wird eine Typsicherheit erreicht, die
unter C nicht vorhanden war. Allerdings leidet die Geschwindigkeit ein
wenig darunter, weil vor jedem Bibliotheks-Funktionsaufruf der Konstruktor
in die entsprechende Enumerationskonstante konvertiert werden muss
(und zur"uck). (Fussnote: nicht allzusehr, da nicht so haeufig)
Eine andere M"oglichkeit w"are, die Enumerationskonstanten,
die nichts anderes als ganzzahlige Werte darstellen, direkt als
Integerkonstanten unter Alice verf"ugbar zu machen. Dann ist aber z.B.
der folgende Code nicht mehr m"oglich:

(case-Beispiel)

\textbf{Verbundtypen} (Fussnote: structs und unions), oder besser,
Zeiger auf Verbundtypen sind von entscheidender
Bedeutung in GTK und werden daher aus Performanzgr"unden nicht auf die
naheliegenden Alice-Records abgebildet.
Stattdessen gibt es f"ur jeden Verbundtyp Zugriffsfunktionen,
die einen Zugriff auf die einzelnen Felder eines Verbunds erlauben.
Konstruktor- und Destruktorfunktionen sind dabei nicht n"otig, da GTK alle
seine Verbunde selbst erzeugt und entfernt.

\textbf{Typaliasnamen und externe Variablendeklarationen} werden nicht weiter
behandelt. Unter C k"onnen nur primitive Typen an Funktionen "ubergeben werden,
und diese werden immer entsprechend Tabelle ??? konvertiert. 
(Fussnote Wenn man statt eines nicht n"aher spezifizierten Typs object 
einen Typ 'a pointer benutzen w"urde, w"urde der Abbildung auf 
Alice-type-Deklarationen Sinn machen.)
Zugriff auf externe Variablen ist bei der GTK-Programmierung in aller Regel
nicht n"otig.

\subsection{Funktionen}

(Funktionswrapper; Namenskonvention; Ein-/Ausgabe; variable Argumentlisten?)

\section{Generator}

(Aufbau wie auf Folien; Phasen)

\section{Core}

\subsection{Hauptschleife und Event-Handling}

\subsubsection{Ereignisbehandlung in C}

Der Kontrollfluss eines in C geschriebenen GTK-Programms sieht normalerweise
wie folgt aus: (Bild)

\begin{enumerate}
\item Es werden sogenannte ``Callback-Funktionen'' bei GTK registriert, die
      bei bestimmten Ereignissen reagieren sollen.
\item Das Hauptprogramm "ubergibt die Kontrolle an die GTK-Hauptschleife,
      welche erst zum Ende des Programms zur"uckkehrt.
\item Die Hauptscheife "uberpr"uft regelm"a"sig, ob Ereignisse vorliegen.
\item Wenn ein Ereignis eintritt (z.B. der Benutzer eine Schaltfl"ache 
      dr"uckt), werden die f"ur dieses Ereignis registrierten
      ``Callback-Funktionen'' aufgerufen.
\end{enumerate}

Zu beachten ist dabei, dass die Ereignisse synchron abgearbeitet werden,
d.h. erst wenn die Callback-Funktion zur"uckgekehrt ist, kann die Hauptschleife
wieder neue Ereignisse abarbeiten.


\subsubsection{Naiver Ansatz / Probleme}

Eine naive Umsetzung dieses Prozesses muss aus folgenden Gr"unden scheitern:

\begin{itemize}
\item Aufrufe von C-Funktionen sind f"ur die Alice-VM atomar. Die virtuelle
      Maschine ist daher blockiert, solange die Hauptschleife l"auft, 
      was fast immer der Fall ist. Dadurch kann die VM keine weiteren Alice-
      Threads mehr abgearbeiten, und die Nebenl"aufigkeit ist nicht mehr
      sichergestellt. (Fussnote: GC auch nicht)
\item Alice-Callback-Funktionen k"onnen nicht bei GTK registriert werden,
      geschweige denn von C aus aufgerufen werden.

\end{itemize}

\subsubsection{L"osung}

Die Probleme werden wie folgt gel"ost:

\begin{itemize}
\item Teile der Hauptschleife werden nach Alice ``hochgezogen''.
\item Alice-Callbacks werden indirekt "uber ein Ereignisstrom-Modell
      aufgerufen.
\end{itemize}

Eine schematische "Ubersicht liefert Abbildung ???.
Die genaue Implementierung sieht wie folgt aus:

Die Hauptschleife wird aufgeteilt in einen C- und einen Alice-Teil.
(Fussnote: kein Hack) In einem eigenen Alice-Thread wird dabei das Verhalten
der GTK-Hauptschleife ``simuliert'': Der Thread ruft periodisch
GTK-Funktionen auf, die "uberpr"ufen, ob Ereignisse vorliegen bzw. diese
abarbeiten. Durch diese Konstruktion kehrt der Programmfluss immer wieder
zu Alice zur"uck, wodurch die VM nicht blockiert wird.

Bei der Bindung einer Alice-Funktion f an ein Objekt o f"ur ein Ereignis e
laufen die folgenden Dinge ab:

\begin{enumerate}
\item Bei GTK wird ein in C geschriebener ``generischer Marshaller''
      f"ur Objekt o und Ereignis e registriert. (Fussnote: GTK bietet diese
      M"oglichkeit) GTK liefert daraufhin eine Verbindungsnummer ID zur"uck.
\item Die Alice-Funktion f wird in einer Hash-Tabelle eingetragen;
      der Schl"ussel zur Funktion ist die ID.
\end{enumerate}

Bei der Ausl"osung von Ereignis e bei Objekt o passiert folgendes:

\begin{enumerate}
\item Die Hauptschleife ruft den ``generischen Marshaller'' auf. Als Argumente
      bekommt dieser die ID, das Objekt o, sowie eine variable Liste von
      Argumenten args f"ur das Ereignis e.
\item Der Marshaller schreibt ID, o und args auf den Ereignisstrom.
\item Auf Alice-Seite wartet ein ``listener-Thread'' auf Daten vom Strom.
      Der Thread liest ID, o und args, und findet mit der Hash-Tabelle anhand
      der ID die Callback-Funktion f heraus.
\item Der Thread ruft f mit o und args als Argumenten auf. Sobald f beendet
      ist, wird wieder auf neue Daten vom Strom gewartet.
\end{enumerate}

Durch den Strom werden die Ereignisse nacheinander in der richtigen
Reihenfolge abgearbeitet. Es gibt jedoch einen wichtigen Unterschied
zur Ereignisbehandlung bei einem C-Programm: Die Ereignisse werden asynchron
abgearbeitet, d.h. die Hauptschleife kann bereits ein Ereignis bearbeiten,
w"ahrend ein anderes noch in einer Alice-Callback-Funktion abgearbeitet wird.
(Grund??? Probleme???)

\subsection{Garbage-Collection}

GTK+ besitzt eine eigene interne Speicherverwaltung, die daf"ur sorgt,
das GTK-Objekte entfernt werden, sobald sie nicht mehr ben"otigt werden.
Dies wird "uber einen Z"ahler realisiert, der festh"alt, wieviele
Referenzen auf das Objekt bestehen. Sobald der Z"ahler auf 0 sinkt,
entfernt GTK das Objekt aus dem Speicher.

Das Problem dabei ist, das der Z"ahler zun"achst nur bibliotheksintern
verwaltet wird. Nachdem eine GTK-Funktion eine Referenz
auf ein Objekt geliefert hat und diese Referenz in Alice sichtbar ist,
kann es passieren, dass GTK das Objekt intern nicht mehr ben"otigt und
daher entfernt, weil die Bibliothek keine Kenntnis von der Alice-Referenz
besitzt. Wird die Alice-Referenz dann weiterhin benutzt, kann das fatale
Folgen haben.

Die L"osung des Problems besteht darin, den Referenzz"ahler eines Objekts
solange um eins erh"oht zu halten, wie eine Referenz auf das Objekt in
Alice sichtbar ist:

\begin{itemize}
\item Sobald eine GTK-Funktion eine Objekt-Referenz liefert und es noch keine
      Referenz von Alice auf das Objekt gibt, wird der GTK-Referenzz"ahler
      um eins erh"oht.
\item Sobald unter Alice letzte Referenz auf das Objekt verschwindet, wird
      dessen Z"ahler wieder um eins verringert (Fussnote: ueber AliceFinalis)
\end{itemize}

Solange eine Referenz auf ein Objekt in Alice also besteht, muss der
GTK-Referenzz"ahler mindestens 1 sein, was GTK am Entfernen des Objekts
hindert.

\subsection{Weitere Funktionen}

(init, NULL, TRUE, FALSE ?)

\section{Ausblick}

Weiterf"uhrende Arbeiten k"onnten sowohl ``in die Tiefe'' gehen und die
GTK-Schnittstelle ausbauen, als auch ``in die Breite'' und die automatische
Generierung verallgemeinern.

\subsection{GTK-Schnittstelle}

Die hier vorgestellte Schnitstelle bietet eine Anbindung auf niedriger Ebene.
Durch die 1:1-Abbildung sieht die GTK-Programmierung unter Alice "ahnlich
aus wie unter C. Diese unter Alice unelegante Programmierweise kann
nur mit einer eine funktionale, abstrahierende Schicht "uber der
eigentlichen GTK-Schnittstelle umgangen werden.

Einen Anfang daf"ur bildet die GtkBuilder-Struktur von Thorsten Brunklaus.
Das Layout ganzer Fensterinhalte kann als Wert mittels Konstruktoren
repr"asentiert werden. Darauf hingen"ugt der Aufruf einer einzigen Funktion,
welche diesen Wert anschlie"ssend in eine Reihe von GTK-Befehlen "ubersetzt.

W"unschenswert w"are es, spezielle Features der Programmiersprache Alice
gleich zu nutzen. So k"onnten eine Reihe "ahnlicher Mitteilungsfenster
in einem Funktor zusammengefasst werden, und dieser k"onnte wiederum als
Package im Netz allen Anwendungen zur Verf"ugung stehen. Desweiteren k"onnte
der Lazy-Evaluation-Mechanismus vielleicht dazu genutzt werden, Widgets erst
dann zu zeichnen, wenn sie tats"achlich sichtbar werden.

In jedem Fall ist eine solche funktionale UI-Schnittstelle wahrscheinlich
nicht mehr automatisch generierbar. (Forschungsstand???)

\subsection{Allgemeines Genererierungstool}

Auch wenn der Generator in der jetzigen Form bereits m"oglichst unabh"angig
von GTK+ arbeitet, macht er dennoch einige GTK-spezifische Annahmen, die
eine Anwendung f"ur andere Bibliotheken erschweren.

Daher w"are es n"utzlich, diese Annahmen zu parametrisieren, um einen
allgemeinen Generator zu erhalten, der f"ur beliebige C-Bibliotheken
eine Anbindung an Alice generieren kann. (Sven???)

\section{Quellenangaben}

www.gtk.org

\end{document}
