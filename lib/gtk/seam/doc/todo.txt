
*** Allgemein/Ideen ***

1. zwei seg faults in AliceTour: a) Fehler im GC(!) b) unmittelbar nach condget

4. Quellcode aufraeumen
5. Dokumentation

- Enum-LargeInt-Ueberpruefung sollte in TypeManager.sml erfolgen

* aktuelles Problem: Finalisierung an falscher Stelle und nur bei GdkPixbuf?
* Transient from finalStream funktioniert nicht -> finalStream abgeschafft

* install -C ?
* Record bauen - wie? (Zugriff auf Event-Records stuerzt ab)
* Kernroutinen aus NativeGtkSpecial in eigene DLL tun
X Komponenten auf hinreichende Modularisierung ueberpruefen


Garbage Collection:
fuer alle Objekte gilt:
* beim Erstellen im WeakDictionary abspeichern (falls nicht schon da?) + ref()
* falls auf Alice-Seite keine Referenz mehr besteht, wird C-Funktion
  aufgerufen, die Objekt aus Dictionary entfernt und unref()

fuer GtkObjects gilt:
* beim Erstellen eigenen destroy-event-handler registrieren (nicht delete)
  Event-Handler-Funktion enthaelt Pointer, Referenz ist also immer vorhanden
* soll das Objekt zerstoert werden, wird destroy-event emitted
* destroy-event-handler loescht daraufhin sich selbst aus der Signaltabelle
  (keine Referenz mehr), ruft alle user-defined destroy-handler auf und
  loescht alle Handler, die an das Objekt gebunden sind

* get/set-Methoden fuer GdkEvent-Structs, wie Typsicherheit herstellen?
* Classes -> haben bereits set/get-Methoden
* bestimmte Structs (z.B. GdkPoint) bekommen welche

* Enums
* GC (Weak Dictionary)
* datatypes/Signals bauen
* Dateien komplett umbenennen
* libgnomecanvas statt GtkCanvas installieren
* GnomeCanvas-Bindings
- get/set-Funktionen - auch fuer Gtk!
- Windows
- Namespace-Aufteilung: Gtk.Button.new ...
X eigene Native-Hilfsfunktionen besser benennen

* stockwerk-gtk-binding in den CVS main trunk
* stockhausen neu bauen -> Problem!!
* datatype arg auch in GtkUnsafe verfuegbar machen
* Makefile hat noch ein Problem (Aenderungen an .cc fuehren nicht zum Rebuild)

* Test-Programm besser
* Makefile besser: Gtk.aml haengt von GtkCore.aml ab usw.

* Problem: beim Benutzen der UnsafeGtk-Komponente gibt es einen segfault
* casting-Mist in UnsafeGtk.cc ueberpruefen
* #include liefert unterminated string constant Fehler (wegen ')
* sind alle Out-Parameter reine Out-Parameter? ist es nicht sicherer,
  alle outs als ins UND outs zu deklarieren (dafuer mehr Arbeit beim User)
  -> zwei Varianten der Funktion: eine mit out-only, eine mit in-out

* GtkTrue und gtkFalse liefern int's (fuer bools true und false benutzen)

Ideen fuer GtkTreeTypes:

CLASSES... enthaelt *alle* Klassen
  nur fuer STRUCTUREs, die auch in CLASSES sind, gibt es get/set-Funktionen 


setenv ALICE_TRACE_COMPONENT 1
setenv ALICE_TRACE_RESOLVER 1

unsetenv ALICE_TRACE_COMPONENT
unsetenv ALICE_TRACE_RESOLVER


*** Projekt ***

* Bericht (2,3 Seiten) bis Freitag
* alles ordentlich bei CVS commiten
* CUA-mode
* website anpassen
* gtk 2.0 holen und lokal installieren
* genauen plan machen, welche funktionen uebersetzt werden sollen

X GTKCanvas? -> geht nicht, braucht GTK 1.2
X ckit fuer alice



*** Generator ***

* GDK-Zeugs testen; Exception- und Type-Sharing
* Problem: Alice kann Enums ab 2^30 nicht akzeptieren (nur bis 2^30-1)
* gdk_pixbuf_new_from_xpm....
* gtkclean.c mit -DGTK_DEPRECATED erzeugen?
* besseren include- und user-defined-Mechanismus ausdenken
* Parser/TypeManager aufraeumen
* MkUnsafe.sml/MkSafe.sml besser strukturieren
* gchar* wird nicht als STRING erkannt
* leere inarglist moeglich
* bool als BOOL erkennen
* vorhandene Darstellung nutzen
* isValueArg? was genau sind Werteparameter?
* CLASS -> Baum generieren
* POINTER(TYPEREF(POINTER(STRUCTREF))) ist auch ein valuearg!
* bitfield size declared -> muss uns das aergern?
* gtkraw.c erstellen
* MkIntermediate in Vorhandes integrieren
* dabei alle Datentypen und ty-Operationen von parse separieren
* Idee: ty-Operationen kommen in den TypeManager
* native interface generieren und uebersetzen



*** UnsafeGtk ***

* GList/GSList immer als object list, ausser wenn in MkSpecial anders definiert
* Event-Dispatcher: Stream bauen, registrierte callback-Funktion aufrufen
* Stream: Marshaller wandelt GValues in eigenen Alice-Datentyp um und
    schreibt dies auf den Stream
    (stream = Liste mit Future als letztes Element)
    Callback-Funktion muss selbst die Argumentwerte wieder rausmoebeln
X Marshaller-Rueckgabewert?

* UnsafeGtk als DLL

* was tun mit valists?
* object-Typueberpruefung: in UnsafeGtk.cc! ueber GType-Funktionen
    bei Fehlschlag: exception liefern

* Listen: GList immer als 'object list
    deklarieren: mit DECLARE_LIST_ELEMS und glist_append
    zurueckgeben: eigene Funktion basteln
* Listen: nicht immer nur als object list behandeln? -> doch
* Funktion bauen, die NULL-Pointer zurueckliefert
* Arrays testen
* Problem beim Uebersetzen mit CSTRING-Arrays

Fehler die beim Uebersetzen von UnsafeGtk.cc auftraten:
* Rueckgabewert von Gtk-Funktion war const char *, wurde zugewiesen
  an char * (ret)
* "changes signedness"-Fehler
* verlangte Arrays koennen nicht als void-Pointer deklariert werden

X gtk_init: evtl. in der C-Funktion Kommandozeilenparameter uebergeben
X ...und veraenderte Parameterliste als neue gueltige hinbekommen? -> nein.

* zurueckgegebene Bools werden nicht richtig erkannt? -> nee, ist so
* was tun mit ARRAYs in arglist?
* was tun mit Listen-Typen? -> DECLARE_LIST
* was tun mit FUNCTIONS in arglist? als POINTER(FUNCTION _) oder als FUNCTION _?


*** SafeGtk ***

* GC: Weak dictionary: Zugriff auf C-dictionary wird moeglich sein
* immer, wenn eine Funktion ein object rausschmeisst (bzw. object auf stream
  geschrieben wird) nachsehen, ob object in dictionary. wenn nein:
  hinzufuegen + gtk-ref aufrufen
X finalizer thread ruft fuer ankommende objects auf eigenem Strom gtk-unref auf


* warum wird callback function erst beim zweiten Event aufgerufen?
* callback-Funktionen in Hashtable abspeichern
* sleep-Funktion ist zu provisorisch?



*** Test ***

* Mini-Interface schreiben und testen
* Mini-Interface mit Futures testen
* Beispiel-Komponente schreiben

Fehler:
- ckit2.sml in stockwerk-vm testen; ggf. in alice bugzilla eintragen
* Int.toString(2^32) haengt sich auf
- mehrfaches spawn (fib 40) stuerzt ab
* val ~1 = 1; stuerzt ab
