(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure PrettyPrint from "x-alice:/lib/utility/PrettyPrint"
import structure PPType from "x-alice:/lib/rtt/PPType"
import structure PPInf from "x-alice:/lib/rtt/PPInf"
import structure UnsafeValue from "x-alice:/lib/system/UnsafeValue"
import structure Reflect from "x-alice:/lib/system/Reflect"

import structure Doc from "Doc"
import structure Node from "Node"
import structure GtkSupport from "GtkSupport"

import structure Color from "Color"
import structure MkDrawingArea from "MkDrawingArea"
import signature DRAWING_AREA from "DRAWING_AREA-sig"
import structure Settings from "Settings"

import structure Dictionaries from "Dictionaries"

import structure CreateTree from "CreateTree"
import structure Layout from "Layout"
import structure Draw from "Draw"
import structure Update from "Update"
import structure Server from "Server"

import signature WIDGET from "WIDGET-sig"

local 
open Doc Node GtkSupport Color

(***           Node Search              ***)

    exception NodeFound of node
    exception unknown

    (* checks if a point lies in the bounding box of a node tree *)
    fun inBoundingBox (node,x,y) = 
	let
	    val xdim = get_xdim(node)
	    val ydim = get_ydim(node)
	in  
	    x >= 0 
	    andalso y >= 0
	    andalso x < xdim
	    andalso y < ydim
	end

    (* auxiliary functions for node search *)
    fun isInterpunct node = case getDesc(node) 
	of INTERPUNCT => true
      | _ => false

    fun interpunctMayBeSelected (Limit _ | RelNode _ | RelRefNode _ ) = 
	true
      | interpunctMayBeSelected  _ = false

    fun justifyFound (node,SOME(n) as found) =
	if isInterpunct(node)
	    then if node = n 
		     then SOME(getParent(node))
		 else found
	else found
      | justifyFound (node,NONE) = NONE
	    

    (* searches node tree for deepest node that corresponds to the 
       search coordinates *)
    fun treeSearch ((Simple _ as node | Limit _ as node),x,y)  = 
	if inBoundingBox(node,x,y) then 
	    if not(isInterpunct node) 
		orelse (interpunctMayBeSelected node)
		orelse (getParent(node) = Empty) 
		then SOME(node)
		    else SOME(getParent(node))
	else NONE
      | treeSearch (RelRefNode _ as node,x,y) = if inBoundingBox(node,x,y) 
						then SOME(node)
						    else NONE
      | treeSearch (RelNode(r) as node,x,y) =  (case !(#counter(r)) of
			  1  =>  treeSearch(!(#content(r)),x,y)
			| _  =>  let
				     val labellength = 
						    String.size(getRep(node))
				     val label_in_bb = x>=0
					 andalso x < labellength
					 andalso y = 0
				 in
				     if label_in_bb then SOME(node) 
					 else treeSearch(getContent(node),
							 x - labellength,
							 y)
				 end)
      | treeSearch (Concat(r) as node,x,y) =
	  if inBoundingBox(node,x,y) 
	      then 
		  let
		      val hor_funct =
			  (fn (a,(curx,cury)) =>
			   (case treeSearch(a,curx,cury) of
				SOME(n) => raise NodeFound(n)
			      | NONE    => 
				    let
					val c = curx -  get_xdim(a)
				    in
			    (case a of
				 Container(r) => 
				     if setsVertical(a) 
					 then
					     (curx - get_l_xdim(a)
					      , cury - get_ydim(a) +1)
				     else 
					 (curx -  get_l_xdim(a) 
					  ,cury)
			       | Empty => (curx,cury)
			       | _ => 
					 (curx - get_l_xdim(a)  
					  ,cury- get_ydim(a) +1 ))
				    end))
		      val found = (Array.foldl hor_funct (x,y)	
				   (getKids(node)); NONE)
			  handle NodeFound(n) => SOME(n)
			      
		  in
		      justifyFound(node,found)
		  end
	  else NONE
	      
      | treeSearch (Container(r) as node,x,y) = 
	      if inBoundingBox(node,x,y) 
		  then 
		      let
			  val hor_funct =
			      (fn (a,curx) =>
			       (case treeSearch(a,curx,y) of
				    SOME(n) => raise NodeFound(n)
				  | NONE    => 
					(curx -  get_xdim(a))))
			  val ver_funct =
			      (fn (a,cury) =>
			       (case treeSearch(a,x,cury) of
				    SOME(n) => raise NodeFound(n)
				  | NONE    => 
					(cury -  get_ydim(a))))
			  val found = (if setsVertical(node)
					   then (Array.foldl ver_funct y 
						 (getKids(node));NONE)
				       else (Array.foldl hor_funct x 
					     (getKids(node));NONE))
			      handle NodeFound(n) => SOME(n)
		      in
			  justifyFound(node,found)
		      end
	      else NONE
      | treeSearch _ = NONE


    (* iterates through the dictinary until it 
       finds a node tree at the search position *)
    fun iterate (dict,x,y,i,highest_i) = 
	if i > highest_i 
	    then NONE
	else
	    case Dictionaries.Main.lookup(Dictionaries.maindict,i) of
		NONE => iterate(dict,x,y,i+1,highest_i)
	      | SOME (node,line) =>( case treeSearch(node,x,y) 
		    of
			NONE => iterate (dict,
					 x,
					 y-get_ydim(node)-1,
					 i+1,
					 highest_i)
		      | SOME n => ( case getParent(n) of
				    RelNode(r) 
				    => if !(#counter(r)) = 1
					   then SOME n
				       else SOME (getParent(n))
                                  | _ => SOME n))
	      |_ => NONE
				   
					
    (* Searches the node that is at a specified position on the canvas *)
    fun search (real_x, real_y) = 
	let
	    val int_x = (Real.trunc(real_x))
	    val font_width = !Settings.fontWidth
	    val x = int_x div font_width
	    val int_y = (Real.trunc(real_y))
	    val font_height = !Settings.fontHeight
	    val y = int_y div font_height
	    val highest_i = Dictionaries.Main.getHighestIndexAssigned
		(Dictionaries.maindict)
	in
	   iterate (Dictionaries.maindict,x,y,0,highest_i)
	end

(***       Separation Line Resize Mechanism     ***)

(* iterates through main dictionary and sets sep line sizes *)
    fun  resizeSepLinesIterate(dict,x,i,highest_i) =
	if i > highest_i 
	    then ()
	else 
	    (case Dictionaries.Main.lookup(dict,i) of
		 NONE =>
		     resizeSepLinesIterate(dict,x,i+1,highest_i)
	       | SOME (_,line) => 
		     if line = uglyNULL 
			 then  resizeSepLinesIterate(dict,x,i+1,highest_i)
		     else
			 (resizeSepLine(line,x)
			  ;resizeSepLinesIterate(dict,x,i+1,highest_i)))

    (* sets all separation lines to a specified length *)
    fun resizeSepLines (dict,rx) = 
	let 
	    val x = Real.trunc rx
	    val highest_i = Dictionaries.Main.getHighestIndexAssigned(dict)
	in
	    resizeSepLinesIterate(dict,x,0,highest_i)
	end

in


structure Widget :> WIDGET =
struct

    (***    Window and Window Attributes    ***)
    
    val window = toplevelWindowNew()
    val canvas = ref uglyNULL
    val canvasroot = ref uglyNULL
    val resize = ref (fn () => ())
    val alive = ref false
    val act_line = ref 0

    fun incr_act_line dy = act_line := !act_line + dy

    val (status,postType,postMode) = createStatusbar() 

	
    (* determines the vertical length of the canvas *) 

    fun getScreenMaxY() = Real.fromInt(Settings.getFontHeight() * 
			     !act_line)	


    (* determines the horizontal length of the canvas *)

    fun getScreenMaxX() =  Real.fromInt(Settings.getFontWidth() * 
			     !Update.screen_max_x) 

    fun setScreenX x = if x > (!(Update.screen_max_x))
			   then  Update.screen_max_x := x
		       else ()

    (* scrollbar *)
    val (scrolled,hadj,vadj) =  
	createScrollWindowDefaults(20.0,50.0,getScreenMaxX(), getScreenMaxY())

			   
    (* contains the node and the markings of the currently selected node *)
    val selection = ref NONE
    
    fun destroySelectionMarkings () = case !selection of 
	NONE => ()
      | SOME(_,rect,rect') =>( objectDestroy(rect)
			  ; objectDestroy(rect'))

    fun getSelectionNode() = case !selection of 
	NONE => Node.Empty
      | SOME(n,_,_) => n  

    fun deselect (bar) = (setSelectionMenuSensitive(bar,false)
		       ; destroySelectionMarkings()
		       ; selection := NONE)  

    (* cleans out all dictionaries *)
    fun emptyAllDictionaries() = 
	(Dictionaries.Main.dumpAll(Dictionaries.maindict)
	 ;Dictionaries.RelMan.dumpAll(Dictionaries.reldict)
	 ;Dictionaries.Transient.dumpAll(Dictionaries.transdict))

    (* handles the user's request to shut the window *)
    fun DeleteWindow _ = Server.serve (fn () =>
	(widgetHideAll(window)
	 ;Update.screen_max_x := 0
	 ;emptyAllDictionaries()
	 ;act_line := 0
	 ;alive:= false))
	
    (* handles user request to clear everything *)
    fun handleClear _ = Server.serve (fn () =>
	let
	    val li = Dictionaries.Main.dict2list(Dictionaries.maindict)
	in 
	    (List.app (fn (n,sep) => 
		       (objectDestroy(getGroup(n))
			; if not(sep = uglyNULL) 
			      then objectDestroy(sep)
			  else () )) li
	     ;emptyAllDictionaries()
	     ;Update.screen_max_x := 0
	     ;act_line := 0
	     ;(!resize)())
	end)
    
    (* needed to keep Gtk going when using MS Windows *)
    fun freezeThaw(x) = (layoutFreeze(x)
		       ; layoutThaw(x))

    (* makes the Window visible *)
    fun show() = if !alive then widgetShowAll(window) else ()

    
(***         Canvas Resize Mechanism        ****)


    (* computes horizontal portion of canvas *)
     fun canvaswidth (hadj) = 
	 let
	     val page_sh = adjustmentGetFieldPageSize(hadj)
	     val h = if (Real.< (page_sh,(getScreenMaxX()))) 
			 then getScreenMaxX() else page_sh
	 in
	     h
	 end

     (* canvas resize *)	
     fun handleResize (scrolled,hadj,vadj,resize) = 
	 (fn _ =>  
	  Server.serve (fn () => 
			let
			    val upperh = adjustmentGetFieldUpper(hadj)
			    val valueh = adjustmentGetFieldValue(hadj)
			    val upperv = adjustmentGetFieldUpper(vadj)
			    val valuev = adjustmentGetFieldValue(vadj) 
			    val page_sv = adjustmentGetFieldPageSize(vadj)
			    val h = canvaswidth(hadj)
			    val v = if (Real.< (page_sv,(getScreenMaxY()))) 
					then getScreenMaxY() else page_sv
			in
			    (resize(h,v,scrolled,valueh,valuev,
						     getScreenMaxX(),
						     getScreenMaxY())
			     ; resizeSepLines(Dictionaries.maindict,
					      h)
			     ; ())
			end))
	 

     (***       Stop Button Mechnism         ****)

     val stopflag = Update.stopflag
	 
     (* handles user request to stop *)
     val _ = signalConnect(stopButton,
			   "activate",
			   fn _ => (stopButtonSetActive(false)
				    ; Settings.set_width 0
				    ; Settings.set_depth 0
				    ; stopflag := true)) 
	 

     (***             Update Handler            ***)
		
     fun update_reinspect n = 
	 Server.serve (fn()
		       =>  Update.reinspect(n,
					    CreateTree.createTree,
					    CreateTree.createTreeInf,
					    !canvas))
	
	 
     (* handles reinspect request *)
     fun handleReinspect node = 
	 fn _ => (update_reinspect node)
     
     (* handles reinspect request *)
     fun handleReinspectSelection _ = update_reinspect (getSelectionNode())
  
     (* handles shrink request *)	 
     fun handleShrinkSelection _  = 
	 Server.serve
	 ( fn () 
	   => let
		  val updateShrink = fn n  
		      => let 
			     val diff = getDepth(n) - 
				 Update.findHighestDepth n
			 in 
			     if diff >= 0 
				 then ()
			     else Update.foldDepth(n,diff-1,
						   CreateTree.createTree,
						   CreateTree.createTreeInf,
						   !canvas)
			 end
		  val selection_node = getSelectionNode()
	      in
		   (if selection_node = Node.Empty 
			then () 
		    else updateShrink selection_node
			; destroySelectionMarkings()
			; selection:=NONE)
	      end)

     (* handles expand request *)
     fun handleExpandSelection _  = 
	 Server.serve (fn () 
		       =>let
			     val updateExpand =  fn n 
				 => Update.foldDepth(n,!Settings.max_depth,
						     CreateTree.createTree,
						     CreateTree.createTreeInf,
						     !canvas)
			     val selection_node = getSelectionNode()
			 in
			     (if selection_node = Node.Empty 
				  then () 
			      else updateExpand (getSelectionNode())
				  ; destroySelectionMarkings()
				  ; selection :=NONE)
			 end)

     (* folds width *)
     fun handleWidth node =  
	 let
	     val update_width = 
		 fn (n,i) => Update.foldWidth(n,i,
					       CreateTree.createTree,
					       CreateTree.createTreeInf,
					       !canvas)
	 in
	     fn i => fn _ => update_width(node,i)
	 end
     
     (* folds depth *)
     fun handleDepth node =
	 let
	     val update_depth = 
		 fn (n,i) => Update.foldDepth(n,i,
					       CreateTree.createTree,
					       CreateTree.createTreeInf,
					       !canvas)
	 in
	     fn i => fn _ => update_depth(node,i)
	 end

     (* handles force evaluation request *)
     fun forceTree ((Container _ | Concat _ ) as n) = 
	 Array.app forceTree (getKids(n))
       | forceTree (RelNode _  as n ) = forceTree(getContent(n))
       | forceTree n = 
	 if ((Node.isByneed n) handle _ => false)
	     then
		 let 
		     val b_future = 
			 case getDesc n of  
			     VALUE(r) => UnsafeValue.cast (#value(r)) 
			   | I_VALUE(r) => UnsafeValue.cast (#value(r)) 
			   | _ => raise Match 
		 in Future.await(b_future) 
		 end
	 else ()
	
     (***       Node Tree Deletion Mechanism     ***)

     
     (* prepares deletion of one node *)

     fun deleteNode Empty = ()
       | deleteNode (Simple(r) as node)  =   
	 ( objectDestroy(getGroup(node))
	  ; (if not(Future.isDetermined
		    (UnsafeValue.cast (getValue(getDesc(node)))))	
		 then case Dictionaries.Transient.iterLookup
		     (Dictionaries.transdict,fn (v,_,n) => 
		      UnsafeValue.same(v,getValue(getDesc(node))))
		     of
			 SOME ((v,thr,l),i) 
			 => let val new_l =  
			 #2(List.partition (fn n => 
					    getParent(n) = getParent(node)
					    andalso getIndex(n) = 
					    getIndex(node)) l)
			    in if null new_l 
				   then ( Thread.terminate(thr) 
					 ; Dictionaries.Transient.delete
					 (Dictionaries.transdict,i) )
			       else Dictionaries.Transient.update
				   (Dictionaries.transdict,(i,(v,thr,new_l)))
			    end 
		       | NONE => ()
	     else ()) handle _ => ())
       | deleteNode (RelNode(r) as node) = (deleteNode (getContent(node))
					    ; objectDestroy(getGroup(node))) 
       | deleteNode (RelRefNode(r)as node) = (objectDestroy(getGroup(node))) 
       | deleteNode (Limit(r) as node) = objectDestroy(getGroup(node))
       | deleteNode node =  ( Array.app deleteNode (getKids(node))
			     ; objectDestroy(getGroup(node)))
	
	 
     (* deletes one node tree *)

     fun deleteNodeTree node = 
	 let 
	     val root_node = case getParent(node) of 
		 Empty => node
	       | RelNode(r) => getParent(node)
	       | _ => Empty
	     val dy = ~1 - get_ydim(root_node)
	 in
	     ( deleteNode root_node
	      ;case Dictionaries.Main.lookup(Dictionaries.maindict,
					     getIndex(root_node))  
	      of 
		  SOME (n,sep) => if not(sep = GtkSupport.uglyNULL) 
				      then objectDestroy(sep) 
				  else ()
		| NONE => ()
	      ;if not(root_node = Empty) 
		   then (Dictionaries.Main.delete(Dictionaries.maindict,
						  getIndex(root_node))
			 ;Dictionaries.RelMan.delete(Dictionaries.reldict,
						     getIndex(root_node)))
	       else ()
	      ;incr_act_line(dy)
	      ;Update.iterMove(dy,getIndex(root_node)+1)
	      ;Update.setVisible 0
	      ;(!(resize)) ()) 
	 end

    (* mechanism for "re"-inspecting all datastructures - needed for 
       font resize*)

     val inspectFct = ref (fn _ => ())
     val inspectModFct = ref (fn _ => ())

     (* folds all datastuctures into a list and deletes representations *)
     fun uninspect() = 
	 let
	     val li = Dictionaries.Main.dict2list(Dictionaries.maindict)
	     val desc_li = rev(List.foldl 
			       (fn ((n,sep),li) => (getDesc(n))::li ) nil li)
	 in
	     (List.app (fn (n,sep) => deleteNodeTree n) li
	      ; desc_li)
	 end
     
     (* inspects everything anew *)
     fun re_inspect() = Server.serve( fn () =>  
	 let 
	     val li = uninspect()
	 in
	     List.app (fn d => case d of 
		       VALUE(r) => (!inspectFct) (#value(r),#typ(r))
		     | I_VALUE(r) => (!inspectModFct)  (#value(r),#typ(r))
		     | _ => ()) li
	 end)

     (* Handles ok Button in Preferences Window *)
     fun okHandler(w,
	      width_s,
	      depth_s,
	      font_s, 
	      treemode_button,
	      relmode_button, 
	      tokenmode_button) = 
	 (fn _ => 
	  (  Settings.max_width := 
	   spinButtonGetValueAsInt(width_s) 
	   ;Settings.max_depth := 
	   spinButtonGetValueAsInt(depth_s)
	   (* font size *) 
	   ;  let
		  val new_size = 
		      spinButtonGetValueAsInt(font_s)
	      in
		  if !Settings.fontSize = new_size then ()
		  else ( Settings.setFontSize(new_size)
			; re_inspect())
	      end
	   (* relmode settings *)
	   ;Settings.relmode := 
	      (toggleButtonGetActive(relmode_button) = true
	       orelse 
	       toggleButtonGetActive(tokenmode_button) = true)
	   ;Settings.tokenmode :=  
	      toggleButtonGetActive(tokenmode_button) = true
	   ;widgetDestroy(w)
	   ;if 
	      toggleButtonGetActive(treemode_button) = true 
		   then (Dictionaries.RelMan.dumpAll
			 (Dictionaries.reldict)
			 ; relnumber := 0)
	       else ()))

    
     (* Preferences Window Handler *)
     fun Preferences _ = 
	 Server.serve 
	 (fn () =>
	  let	
	      (* Width & Depth Settings *)
	      val width_lab = labelNew("Set Width Limit to...")	       
	      val width_s = createSpinButton{init =(!Settings.max_width) , 
					     lower = 0, 
					     upper = 1000, 
					     inc = 1, 
					     dec = 0}
	      val depth_s = createSpinButton{init =(!Settings.max_depth) , 
					   lower = 0, 
					     upper = 100, 
					     inc = 1, 
					     dec = 0}
	      val depth_lab = labelNew("Set Depth Limit to...")
	      val table = createTable{rows = 2, cols = 4, 
				      entries = [(width_lab,0,2,0,1),
						 (width_s,2,3,0,1),
						 (depth_lab,0,2,1,2),
						 (depth_s,2,3,1,2)]}
	      val frame = createFrame("",table)
	      (* Mode Settings *)
	      val treemode_button =radioButtonNewWithLabel(uglyNULL, 
							   "Tree Mode")
	      val group = radioButtonGroup(treemode_button)
	      val tokenmode_button = 
		  radioButtonNewWithLabel(group, 
				      "Relational Mode - Token Equality")
	      val group = radioButtonGroup(tokenmode_button)
	      val relmode_button = 
		  radioButtonNewWithLabel(group, 
				"Relational Mode - Structural Equality")
	      val _ = if !Settings.tokenmode 
			  then toggleButtonSetActive(tokenmode_button,true )
		    else if !Settings.relmode then 
			toggleButtonSetActive(relmode_button,true )
			else
			toggleButtonSetActive(treemode_button,true )

	      val radiobox = createVBoxDefaults[treemode_button,
						relmode_button,
						tokenmode_button]
		  
	      val font_lab = labelNew("Set Font Size to...")	
	      val font_s = createSpinButton{init =(!Settings.fontSize) , 
					    lower = 8, 
					    upper = 50, 
					    inc = 1, 
					    dec = 0}
	      val app_table = createTable{rows = 2, cols = 4, 
					  entries = [(font_lab,0,2,0,1),
						     (font_s,2,3,0,1)]}
	      (* Buttonbox *)
	      val w = toplevelWindowNew()
	      val bbox = 
		  createButtonBox{buttons = 
		      [BObj("ok",[Handler("clicked",
					  (okHandler(w,
						     width_s,
						     depth_s,
						     font_s, 
						     treemode_button,
						     relmode_button,
						     tokenmode_button)   ))]),
		       BObj("cancel",
			    [Handler("clicked",fn _ => 
				     widgetDestroy(w))])],
				       borderwidth = 20}

	    val n = createNotebook[("Width & Depth Limit Settings",frame),
				   ("Mode Settings",radiobox)  ,
				    ("Appearance",app_table)   ] 

	    val vbox = createVBox[(n,false,false,0),(bbox,true,true,1)]
		in
		    (windowSetTitle (w, "Preferences")
		    ;windowSetPolicy(w,0,0,1)
	            ;containerAdd(w,vbox)
	            ;signalConnect (w, "delete-event", 
					fn _ => widgetDestroy(w) )
		     ;widgetShowAll(w))
	end)

	
	 (* Menu-Bar *)
     val rec bar = GtkSupport.createMenu
	 (BarObj[MenuObj
		 {title = "Inspector",
		  items = [EntryObj
			   (LABEL "About...",
			    [Handler("activate",
				   fn _ => Server.serve (aboutWindow) )],true),
			   EntryObj
			   (LABEL "Clear",
			    [Handler("activate",
				   fn _ => Server.serve (handleClear) )],true),
			   EntryObj(SEP,[],true),
			   EntryObj(LABEL "Close",
				    [Handler("activate",
					     DeleteWindow)],true)],
		  sensitive = true},
		 MenuObj
		 {title = "Selection",
		  items = [EntryObj(LABEL "Expand",
				    [Handler("activate",
					     handleExpandSelection)]
				    ,true),
			   EntryObj(LABEL "Shrink",
				   [Handler("activate",
					    handleShrinkSelection)]
				    ,true),
			   EntryObj(SEP, [],true),
			   EntryObj(LABEL "Reinspect",
				   [Handler("activate",
					    handleReinspectSelection)]
				    ,true)],
		  sensitive = true}   ,
		 MenuObj
		 {title = "Options",
		  items = [EntryObj(LABEL "Preferences...",
				    [Handler("activate",
					     Preferences)],true)],
		  sensitive = true}]) 

     	
	val postToWindow = createTextWindow()

 
	(* function sends type informations to statusbar *)
	fun postT n = 
	 let  
	     val desc = Node.getDesc(n)
	     val positions_displayed = Real.trunc(canvaswidth(hadj)) div 6 
	 in
	     (case desc of
		 INTERPUNCT => 0
	       | VALUE(r) => 
		     let
			 val text = PrettyPrint.toString
			     (PPType.ppTyp(#typ(r)),1000)
		     in
			 if
			     (String.size(text)) > positions_displayed 
			     then
				 postType("  " 
			      ^String.extract(text, 
					      0,
					      SOME( positions_displayed)) 
					  ^ " ... ")
			 else
			     postType("  " ^ text)
		     end
	       | I_VALUE(r) => 
			 (postToWindow 
			  (PrettyPrint.toString(PPInf.ppInf(#typ(r)),
			       10000)) ;0))
	 end
   
	(* creates popup when a node is clicked on *)
	fun makePopup n = 
	    let 
		val w = (deselect(bar)
			 ;handleWidth(n))
		val d = ( deselect(bar)
			 ; handleDepth(n))
		val r = ( deselect(bar)
			 ;handleReinspect(n))
		fun f _ = ( forceTree(n)
		            ;deselect(bar))
		val width_active =not(case n of 
				  Limit(r) => 
					  getSort(n) = DEPTH_LIMIT
				|  _ => false )
		val depth_active =not(case n of 
					  Limit(r) => 
					      getSort(n) = WIDTH_LIMIT
					|  _ => false )	
		val reinspect_active = not(Node.getDesc(n) = INTERPUNCT) 
		val force_active = (*  (Node.isByneed n) handle _ => false *)
		    true
		val delete_active = getParent(n) = Empty orelse 
		    (isRelNode(getParent(n)) 
		     andalso getParent(getParent(n)) = Empty)
		val width_item_list = [EntryObj(LABEL("-10"),
						[Handler("activate",w(~10))],
						true),
				       EntryObj(SEP,[],true),
				       EntryObj(LABEL("-5"),
						[Handler("activate",w(~5))],
						true),
				       EntryObj(LABEL("-4"),
						[Handler("activate",w(~4))],
						true),
				       EntryObj(LABEL("-3"),
						[Handler("activate",w(~3))],
						true),
				       EntryObj(LABEL("-2"),
						[Handler("activate",w(~2))],
						true),
				       EntryObj(LABEL("-1"),
						[Handler("activate",w(~1))],
						true),
				       EntryObj(SEP,[],true),
				       EntryObj(LABEL("+1"),
						[Handler("activate",w(1))],
						true),
				       EntryObj(LABEL("+2"),
						[Handler("activate",w(2))],
						true),
				       EntryObj(LABEL("+3"),
						[Handler("activate",w(3))],
						true),
				       EntryObj(LABEL("+4"),
						[Handler("activate",w(4))],
						true),
				       EntryObj(LABEL("+5"),
						[Handler("activate",w(5))]
						,true),
				       EntryObj(SEP,[],true),
				       EntryObj(LABEL("+10"),
						[Handler("activate",w(10))],
						true), 
				       EntryObj(LABEL("+50"),
						[Handler("activate",w(50))],
						true)
				       ]
		val depth_item_list = [EntryObj(LABEL("-5"),
						[Handler("activate",d(~5))],
						true),
				       EntryObj(LABEL("-4"),
						[Handler("activate",d(~4))],
						true),
				       EntryObj(LABEL("-3"),
						[Handler("activate",d(~3))],
						true),
				       EntryObj(LABEL("-2"),
						[Handler("activate",d(~2))],
						true),
				       EntryObj(LABEL("-1"),
						[Handler("activate",d(~1))],
						true),
				       EntryObj(SEP,[],true),
				       EntryObj(LABEL("+1"),
						[Handler("activate",d(1))],
						true),
				       EntryObj(LABEL("+2"),
						[Handler("activate",d(2))],
						true),
				       EntryObj(LABEL("+3"),
						[Handler("activate",d(3))],
						true),
				       EntryObj(LABEL("+4"),
						[Handler("activate",d(4))],
						true),
				       EntryObj(LABEL("+5"),
						[Handler("activate",d(5))]
						,true),
				       EntryObj(SEP,[],true),
				       EntryObj(LABEL("+10"),
						[Handler("activate",d(10))],
						true) 
				       ]
	    in
		case n of
		    RelRefNode _ => ()
		  | _ =>
		   Server.serve 
		   (fn () => 
		    (createMenu
		     (PopupObj
		      [MenuObj{title = "Explore Tree",
			       items = [MenuObj
					{title = "width",
					 items = width_item_list,
					 sensitive = width_active},
					MenuObj
					{title = "depth",
					 items = depth_item_list,
					 sensitive = depth_active}],
			       sensitive = true},
		       MenuObj{title = "Actions",
			       items = [EntryObj(LABEL("reinspect"),
						 [Handler("activate",r)],
						 reinspect_active),
					EntryObj(LABEL("force evaluation"),
						 [Handler("activate",f)],
						 force_active),
					EntryObj(LABEL("delete tree"),
						 [Handler("activate",
					        fn _ => deleteNodeTree n)],
						 delete_active)],
			       sensitive = true}])
		     ;()))
	    end
	
	(* Handles Mouseclick *)
	fun handleEvent event = 
	    Server.serve 
	    (fn () =>
	     let
		 val font_width = !Settings.fontWidth
		 val font_height = !Settings.fontHeight  
		 val position = getMouseClickEventInfo(event,hadj,vadj) 
	     (* uses Gdk datatype -> GtkSupport *)
	     in
		 case position of 
		     SOME ((x,y),b)=> 
			 let 
			     val node = (busyButtonSetActive(true)
					 ;search(x,y))      
			 in 
			     (case node of 
				  SOME(n) => 
				      let 
				    val ydim =get_ydim(n) 
				    val group = getGroup(n)
				    val x2 = Real.fromInt(font_width 
					    	* get_xdim(n))
				    val y2 = Real.fromInt(font_height 
						  * ydim)
				    val y2' = Real.fromInt(font_height 
						  * (ydim-1))
				    val lx =Real.fromInt(font_width 
				     *  get_l_xdim(n))
				    val re =createRectangle(group,
							    0.0,
							    0.0,
							    lx,
							    y2)
				    val re' = createRectangle(group,
							    0.0,
							    0.0,
							    x2,
							    y2')
				in                                             
				    (  postT n   
				    ; canvasItemLowerToBottom(re) 
				    ; canvasItemLowerToBottom(re') 
				    ; destroySelectionMarkings()
				    ; selection := SOME (n,re,re') 
				    ; setSelectionMenuSensitive(bar,true)
				    ; busyButtonSetActive(false)
				    ; case n of
				     Limit(_)  => 
					 setExpandSensitive(bar,true)
				       | _ => setExpandSensitive(bar,false)
				    ;if getDesc(n) = INTERPUNCT 
					 orelse isSimple(n) 
					 orelse isRelRefNode(n) 
					 orelse isLimit(n)
					 then setShrinkSensitive(bar,false)
				     else setShrinkSensitive(bar,true)
				    ; case b of
				       1 => ()
				    |  3 =>( makePopup n; ())
				    | _   => () ) 
				end
			  | NONE => (  postType("")
				     ; setSelectionMenuSensitive(bar,false)
				     ; destroySelectionMarkings()
					 ; selection := NONE))
			 end
		   | NONE => ()
	     end)

	(* Handles Key Press *)
	fun handleWindowEvent event = 
	    Server.serve (fn () => 
			  handleGdkKeyPress(event,
					    scrolled,
					    hadj,
					    vadj,
					    getScreenMaxX(),
					    getScreenMaxY()))


	(* Creation / Reopening of the Window (a new canvas gets attached) *)
	    
	fun new _ = 
	    Server.serve 
	    (fn _ => if !alive then()
		     else
			 let
			     val _ = if !canvas =GtkSupport.uglyNULL
					then ()
				     else objectDestroy(!canvas)
			     structure DA  =  
				 MkDrawingArea(val xsize = getScreenMaxX() 
					       val ysize = getScreenMaxY()) 
				 : DRAWING_AREA
			in
			    (canvas := DA.canvas
			     ;canvasroot := DA.root
			     ;resize :=  (handleResize(scrolled,
						       hadj,
						       vadj,
						       DA.resize))
			     ;Update.resize := !resize
			     ;containerAdd(scrolled,DA.canvas)
			     ;signalConnect(scrolled,"size_allocate",
					    fn _ => !resize())
			     ;signalConnect(hadj,"value_changed",fn _ => 
					    freezeThaw(DA.canvas))
			     ;signalConnect(vadj,"value_changed",fn _ => 
					    freezeThaw(DA.canvas)) 
			     ;signalConnect(DA.canvas,"event",handleEvent)
			     ;widgetShowAll(window)
			     ; alive :=true) 
			end)
		 
	val _ = new() (* creates initial window *)

	(* window initialisation *)
	val _ = (windowSetTitle (window, "Alice Browser")
		 ; widgetSetUsize (window, 200, 100) 
		 ; windowSetDefaultSize(window, 600,500)
		 ;signalConnect (window, "delete-event", DeleteWindow)
		 ;setSelectionMenuSensitive (bar,false)  
		 ;menuBarAppend(bar,busyButton)
		 ;menuBarAppend(bar,stopButton)
		 ;menuItemRightJustify(stopButton) 
		 ;containerAdd(window,createVBox[(bar,
						  false 
						  ,false,
						  0),
						 (scrolled,
						 (* Gtk.EXPAND *) true,
						 (* Gtk.FILL *) true,0),
						 (status, 
						  false ,
						  false  ,0)])
		 ;signalConnect(window,"event",handleWindowEvent))


	(**** Browser Initialisation ****)
    
	fun initGtk () = 
	    ( registerColor(INT_COLOR,  allocColor(0,45000,0))
	     ; registerColor(REAL_COLOR, allocColor(0,45000,0))
	     ; registerColor(CHAR_COLOR, allocColor(45000,0,50000))     
	     ; registerColor(STR_COLOR, allocColor(45000,0,50000)) 
	     ; registerColor(WORD_COLOR, allocColor(0,43000,0))
	     ; registerColor(EXN_COLOR,  allocColor (60000,40000,0))
	     ; registerColor(REF_COLOR, allocColor(0,0,0))
	     ; registerColor(LABEL_COLOR, allocColor (0,10000,65535))
	     ; registerColor(SEP_COLOR, allocColor(0,0,0))
	     ; registerColor(EQU_COLOR, allocColor(0,0,0))
	     ; registerColor(LIMIT_COLOR, allocColor (10000,60000,10000))
	     ; registerColor(BRACK_COLOR, allocColor (0,5000,47000))
	     ; registerColor(REL_COLOR, allocColor (60000,20000,0))
	     ; registerColor(DEFAULT, allocColor(0,0,0)) 
	    
	    ; Update.incrActLine := (fn dy => incr_act_line dy) )
	    

	(*******         Inspection            *******)

	fun inspect(v,t) = 
	    ( new()
	    ; Server.serve 
	     (fn _ => 
	      let
		  val va = (busyButtonSetActive(true)
			    ;UnsafeValue.cast v: Reflect.value)
		  val i = Dictionaries.Main.
		      getHighestIndexAssigned(Dictionaries.maindict) +1
		  val save_settings = (!Settings.max_width,!Settings.max_depth)
		  val n = (stopButtonSetActive(true) 
                          ; relnumber := 0
			  ; CreateTree.createTree(NONE,va,t,Empty,i,0,!canvas))
		 val line = (stopButtonSetActive(false)
			     ; if !stopflag 
				   then ( Settings.set_width(#1(save_settings))
					; Settings.set_depth(#2(save_settings))
					; stopflag := false )
			       else ()
				   ;Layout.layout(n)
				   ;setScreenX(get_xdim(n))
				   ;createSepLine(!canvasroot,
						  !act_line,canvaswidth(hadj),
						  Settings.getFontHeight()))
	     in
		 (GtkSupport.layoutFreeze(!canvas) 
		  ; Draw.draw(n,0,!act_line,false)
		  ; GtkSupport.layoutThaw(!canvas) 
		  ; incr_act_line(get_ydim(n) + 1)
		  ; (!resize)()
		  ; show()
		  ; Dictionaries.Main.insertI(Dictionaries.maindict,(n,line)) 
		  ;busyButtonSetActive(false))
	     end) )
	
    fun inspectMod(v,t) = 
        ( new ()
	; Server.serve 
	 (fn _ => 
	  let
	      val va = (busyButtonSetActive(true)
			;UnsafeValue.cast v: Reflect.module)
	      val i = Dictionaries.Main.
		  getHighestIndexAssigned(Dictionaries.maindict) +1
	     val save_settings = (!Settings.max_width,!Settings.max_depth)
	     val n = (stopButtonSetActive(true)
		      ; relnumber := 0
		      ; CreateTree.createTreeInf(va,t,Empty,i,0,!canvas))
	     val line =(stopButtonSetActive(false) 
			; if !stopflag 
			      then ( Settings.set_width(#1(save_settings))
				    ; Settings.set_depth(#2(save_settings))
				    ; stopflag := false )
			  else ()
			      ;Layout.layout(n)
			      ;setScreenX(get_xdim(n))
			      ;createSepLine(!canvasroot,
					     !act_line,canvaswidth(hadj),
					     Settings.getFontHeight() ))
	  in
	      (GtkSupport.layoutFreeze(!canvas) 
	       ; Draw.draw(n,0,!act_line,false)
	       ; GtkSupport.layoutThaw(!canvas) 
	       ; incr_act_line(get_ydim(n) + 1)
	       ; (!resize)()
	       ; show()
	       ; stopButtonSetActive(false)
	       ; Dictionaries.Main.insertI(Dictionaries.maindict,(n,line))
	       ; busyButtonSetActive(false) 
	       )
	  end) )
	 
    val _ = ( inspectFct := inspect
	     ; inspectModFct := inspectMod
	     ; initGtk () )
	
	
end (* structure Widget end *)

end (* local end *)
