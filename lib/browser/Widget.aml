(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure TextIO from "x-alice:/lib/system/TextIO"
import structure PrettyPrint from "x-alice:/lib/utility/PrettyPrint"
import structure PPType from "x-alice:/lib/rtt/PPType"
import structure PervasiveType from "x-alice:/lib/rtt/PervasiveType"
import structure PPInf from "x-alice:/lib/rtt/PPInf"
import structure UnsafeValue from "x-alice:/lib/system/UnsafeValue"
import structure Reflect from "x-alice:/lib/system/Reflect"

import structure Node from "Node"
import structure Doc from "Doc"
import structure Color from "Color"
import structure MkDrawingArea from "MkDrawingArea"
import signature DRAWING_AREA from "DRAWING_AREA-sig"
import structure GtkSupport from "GtkSupport"
import structure Settings from "Settings"

import structure Dictionaries from "Dictionaries"

import structure CreateTree from "CreateTree"
import structure Layout from "Layout"
import structure Draw from "Draw"
import structure Update from "Update"
import structure Server from "Server"

import signature WIDGET from "WIDGET-sig"

local 
open GtkSupport Node Doc Color PervasiveType

(*********** Knotensuche ***************)

    exception NodeFound of node
    exception unknown

    fun inBoundingBox (node,x,y) = 
	let
	    val xdim = get_xdim(node)
	    val ydim = get_ydim(node)
	in  
	    x >= 0 
	    andalso y >= 0
	    andalso x < xdim
	    andalso y < ydim
	end

    fun isInterpunct node = case getDesc(node) 
	of INTERPUNCT => true
      | _ => false

    fun interpunctMayBeSelected (Limit _ | RelNode _ | RelRefNode _ ) = true
      | interpunctMayBeSelected  _ = false

    fun justifyFound (node,SOME(n) as found) =if isInterpunct(node)
					     then if node = n 
					     	 then SOME(getParent(node))
						     else found
					    else found
      | justifyFound (node,NONE)     = NONE


    (* durchsucht einen Baum aus nodes, bis der tiefste Knoten 
     gefunden wird, der an der Suchposition liegt *)
    fun treeSearch ((Simple _ as node | Limit _ as node),x,y)  = 
	if inBoundingBox(node,x,y) then 
	    if not(isInterpunct node) 
		orelse (interpunctMayBeSelected node)
		orelse (getParent(node) = Empty) 
		then SOME(node)
		    else SOME(getParent(node))
	else NONE
      | treeSearch (RelRefNode _ as node,x,y) = if inBoundingBox(node,x,y) 
						then SOME(node)
						    else NONE
      | treeSearch (RelNode(r) as node,x,y) =  (case !(#counter(r)) of
			  1  =>  treeSearch(!(#content(r)),x,y)
			| _  =>  let
				     val labellength =  String.size(#rep(r))
				     val label_in_bb = x>=0
					 andalso x < labellength
					 andalso y = 0
				 in
				     if label_in_bb then SOME(node) 
					 else treeSearch(!(#content(r)),
							 x - labellength,
							 y)
				 end)
      | treeSearch (Concat(r) as node,x,y) =
	  if inBoundingBox(node,x,y) 
	      then 
		  let
		      val hor_funct =
			  (fn (a,(curx,cury)) =>
			   (case treeSearch(a,curx,cury) of
				SOME(n) => raise NodeFound(n)
			      | NONE    => 
				    let
					val c = curx -  get_xdim(a)
				    in
			    (case a of
				 Container(r) => 
				     if setsVertical(a) 
					 then
					     (curx - get_l_xdim(a)
					      , cury - get_ydim(a) +1)
				     else 
					 (curx -  get_l_xdim(a) 
					  ,cury)
			       | Empty => (curx,cury)
			       | _ => 
					 (curx - get_l_xdim(a)  
					  ,cury- get_ydim(a) +1 ))
				    end))
		      val found = (Array.foldl hor_funct (x,y)	
				   (getKids(node)); NONE)
			  handle NodeFound(n) => SOME(n)
			      
		  in
		      justifyFound(node,found)
		  end
	  else NONE
	      
      | treeSearch (Container(r) as node,x,y) = 
	      if inBoundingBox(node,x,y) 
		  then 
		      let
			  val hor_funct =
			      (fn (a,curx) =>
			       (case treeSearch(a,curx,y) of
				    SOME(n) => raise NodeFound(n)
				  | NONE    => 
					(curx -  get_xdim(a))))
			  val ver_funct =
			      (fn (a,cury) =>
			       (case treeSearch(a,x,cury) of
				    SOME(n) => raise NodeFound(n)
				  | NONE    => 
					(cury -  get_ydim(a))))
			  val found = (if setsVertical(node)
					   then (Array.foldl ver_funct y 
						 (getKids(node));NONE)
				       else (Array.foldl hor_funct x 
					     (getKids(node));NONE))
			      handle NodeFound(n) => SOME(n)
		      in
			  justifyFound(node,found)
		      end
	      else NONE
      | treeSearch _ = NONE


    (* Iterator fuer die Knotensuche - durchlaeuft das Dictionary 
     und sucht mit treeSearch *)
    fun iterate (dict,x,y,i,highest_i) = 
	if i > highest_i 
	    then NONE
	else
	    case Dictionaries.Main.lookup(Dictionaries.maindict,i) of
		NONE => iterate(dict,x,y,i+1,highest_i)
	      | SOME (node,line) =>( case treeSearch(node,x,y) 
		    of
			NONE => iterate (dict,
					 x,
					 y-get_ydim(node)-1,
					 i+1,
					 highest_i)
		      | SOME n => ( case getParent(n) of
				    RelNode(r) 
				    => if !(#counter(r)) = 1
					   then SOME n
				       else SOME (getParent(n))
                                  | _ => SOME n))
	      |_ => NONE
				   
					
    (* Suchprozedur fuer den Knoten, der sich an einer 
     besitmmten Postition auf der Canvas befindet *)
    fun search (real_x, real_y) = 
	let
	    val int_x = (Real.trunc(real_x))
	    val font_width = !Settings.fontWidth
	    val x = int_x div font_width
	    val int_y = (Real.trunc(real_y))
	    val font_height = !Settings.fontHeight
	    val y = int_y div font_height
	    val highest_i = Dictionaries.Main.getHighestIndexAssigned
		(Dictionaries.maindict)
	in
	   iterate (Dictionaries.maindict,x,y,0,highest_i)
	end

(*********** Ende Knotensuche ***************)

(*********** Beginn Separationslinien-Grossenanpassungsmechnismus 
               /  Separation Line Resize Mechanism  ***************)

fun  resizeSepLinesIterate(dict,x,i,highest_i) =
     if i > highest_i 
	 then ()
     else 
	 (case Dictionaries.Main.lookup(dict,i) of
	      NONE =>
		  resizeSepLinesIterate(dict,x,i+1,highest_i)
	    | SOME (_,line) => 
		  if line = uglyNULL 
		      then  resizeSepLinesIterate(dict,x,i+1,highest_i)
		  else
		      (resizeSepLine(line,x)
		       ;resizeSepLinesIterate(dict,x,i+1,highest_i)))

fun resizeSepLines (dict,rx) = 
     let 
	 val x = Real.trunc rx
	 val highest_i = Dictionaries.Main.getHighestIndexAssigned(dict)
     in
	 resizeSepLinesIterate(dict,x,0,highest_i)
     end

(*********** End  Separation Line Resize Mechanism  ***************)

in

structure Widget :> WIDGET =
struct

    val window = toplevelWindowNew()
    val canvas = ref uglyNULL
    val canvasroot = ref uglyNULL
    val resize = ref (fn () => ())
    val alive = ref false
    val act_line = ref 0

    fun incr_act_line dy = act_line := !act_line + dy
			
	
    (* soll den Knoten und die Markierungen enthalten, die momentan 
     ausgewaehlt sind *)
    val selection = ref NONE
    
    fun destroySelectionMarkings () = case !selection of 
	NONE => ()
      | SOME(_,rect,rect') =>( objectDestroy(rect)
			  ; objectDestroy(rect'))

    fun getSelectionNode() = case !selection of 
	NONE => Node.Empty
      | SOME(n,_,_) => n  

    fun DeleteWindow _ = (widgetHideAll(window)
		    ;Settings.max_x :=0.0
		    ;Settings.max_y :=0.0
		    ;Dictionaries.Main.dumpAll(Dictionaries.maindict)
		    ;Dictionaries.RelMan.dumpAll(Dictionaries.reldict)
		    ;act_line := 0
		    ;alive:= false)

    val (status,postType,postMode) = createStatusbar() 
	 
    val (scrolled,hadj,vadj) =  
	createScrollWindowDefaults(20.0,50.0,!Settings.max_x, !Settings.max_y)

    fun freezeThaw(x) = (layoutFreeze(x)
		       ; layoutThaw(x))

     fun show() = if !alive then widgetShowAll(window) else ()
    
(************************ Fenstergrossen-Anpassungsmechnismus 
                          / Resize Mechanism *******************************)


     fun canvaswidth (hadj) = 
	 let
	     val page_sh = adjustmentGetFieldPageSize(hadj)
	     val h = if (Real.< (page_sh,(!(Settings.max_x)))) 
			 then !(Settings.max_x) else page_sh
	 in
	     h
	 end

     (* canvas resize *)	
     fun handleResize (scrolled,hadj,vadj,resize) = 
	 (fn _ =>  
	  Server.serve (fn () => 
			let
			    val upperh = adjustmentGetFieldUpper(hadj)
			    val valueh = adjustmentGetFieldValue(hadj)
			    val upperv = adjustmentGetFieldUpper(vadj)
			    val valuev = adjustmentGetFieldValue(vadj) 
			    val page_sv = adjustmentGetFieldPageSize(vadj)
			    val h = canvaswidth(hadj)
			    val v = if (Real.< (page_sv,(!(Settings.max_y)))) 
					then !(Settings.max_y) else page_sv
			in
			    (resize(h,v,scrolled,valueh,valuev,
						     !Settings.max_x,
						     !Settings.max_y)
			     ; resizeSepLines(Dictionaries.maindict,
					      h)
			     ; ())
			end))
	 
(*****************************************************************************)

(**************************** Stop Button Mechnism****************************)

        val stopflag = Update.stopflag

	val _ = signalConnect(stopButton,
		  "activate",
		  fn _ => (stopButtonSetActive(false)
			   ; Settings.set_width 0
			   ; Settings.set_depth 0
                           ; stopflag := true)) 
	    
    
    

     fun setStopButtonOnOff(f,n) = 
	 (Server.serve(fn() => stopButtonSetActive(true))
	  ;f n
	  ; TextIO.print("STOP_BUTTON: f n done\n")
	  ; Server.serve(fn() => stopButtonSetActive(false)))
	 

(**************************** Handler ****************************)
		    
     fun update_reinspect n = 
	 Update.reinspect(n,
			  CreateTree.createGraph,
			  CreateTree.createGraphInf,!canvasroot)
	 
     fun handleReinspect node = 
	 fn _ => ( setStopButtonOnOff(update_reinspect,node ))
     
     fun handleReinspectSelection _ = 
	 setStopButtonOnOff(update_reinspect, getSelectionNode())
  
     fun handleShrinkSelection _  = 
	 let
	 val update_shrink 
	     = fn n  => 
	     let 
		 val diff = getDepth(n) - 
		     Update.findHighestDepth n
	     in 
		 if diff >= 0 
		     then ()
		 else Update.foldDepth(n,diff-1,
				       CreateTree.createGraph,
				       CreateTree.createGraphInf,
				       !canvasroot)
			    end
	 in
	     setStopButtonOnOff(update_shrink, getSelectionNode())
	 end

     fun handleExpandSelection _  = 
	 let
	     val update_expand =  fn n 
			     => Update.foldDepth(n,1,
						 CreateTree.createGraph,
						 CreateTree.createGraphInf,
						 !canvasroot)
	 in
	 setStopButtonOnOff(update_expand, getSelectionNode())
	 end

     fun handleWidth node =  
	 let
	     val update_width = 
		 fn (n,i) => Update.foldWidth(n,i,
					       CreateTree.createGraph,
					       CreateTree.createGraphInf,
					       !canvasroot)
	 in
	     fn i => fn _ => setStopButtonOnOff(update_width,(node,i))
	 end
     
     fun handleDepth node =
	 let
	     val update_depth = 
		 fn (n,i) => Update.foldDepth(n,i,
					       CreateTree.createGraph,
					       CreateTree.createGraphInf,
					       !canvasroot)
	 in
	     fn i => fn _ => setStopButtonOnOff(update_depth,(node,i))
	 end

     fun handleForce node _ = 
	 let
	     val update_force =  fn n 
			     => let val b_future = case getDesc n of  
				    VALUE(r) => UnsafeValue.cast (#value(r)) 
				  | I_VALUE(r) => UnsafeValue.cast (#value(r)) 
                                  | _ => raise Match 
				in Future.await(b_future) 
				end
	 in
	     setStopButtonOnOff
	     (update_force, getSelectionNode())
	 end


     (* Node-Baeume loeschen *)

     fun deleteNode Empty = ()
       | deleteNode (Simple(r) as node)  =   
	 ( objectDestroy(getGroup(node))
	  ; (if not(Future.isDetermined
		    (UnsafeValue.cast (getValue(getDesc(node)))))	
		 then case Dictionaries.Transient.iterLookup
		     (Dictionaries.transdict,fn (v,_,n) => 
		      UnsafeValue.same(v,getValue(getDesc(node))))
		     of
			 SOME ((v,thr,l),i) 
			 => let val new_l =  
			 #2(List.partition (fn n => 
					    getParent(n) = getParent(node)
					    andalso getIndex(n) = getIndex(node))
			    l)
			    in if null new_l 
				   then ( Thread.terminate(thr) 
					 ; Dictionaries.Transient.delete
					 (Dictionaries.transdict,i) )
			       else Dictionaries.Transient.update
				   (Dictionaries.transdict,(i,(v,thr,new_l)))
			    end 
			
		       | NONE => ()
			    
	     else ()) handle _ => ())
       | deleteNode (RelNode(r) as node) = (deleteNode (getContent(node))
					    ; objectDestroy(getGroup(node))) 
       | deleteNode (RelRefNode(r)as node) = (objectDestroy(getGroup(node))) 
       | deleteNode (Limit(r) as node) = objectDestroy(getGroup(node))
       | deleteNode node =  ( Array.app deleteNode (getKids(node))
			     ; objectDestroy(getGroup(node)))
	 
	 
     fun deleteNodeTree node = 
	 let 
	     val root_node = case getParent(node) of 
		 Empty => node
	       | RelNode(r) => getParent(node)
	       | _ => Empty
	     val dy = ~1 - get_ydim(root_node)
	 in
	( deleteNode root_node
	  ;case Dictionaries.Main.lookup(Dictionaries.maindict,
					 getIndex(root_node))  
	 of 
	     SOME (n,sep) => if not(sep = GtkSupport.uglyNULL) 
				 then objectDestroy(sep) 
				     else ()
	       | NONE => ()
	 ;if not(root_node = Empty) 
	      then (Dictionaries.Main.delete(Dictionaries.maindict,
					    getIndex(root_node))
		    ;Dictionaries.RelMan.delete(Dictionaries.reldict,
					    getIndex(root_node)))
	  else ()
	 ;incr_act_line(dy)
	 ;Update.iterMove(dy,getIndex(root_node)+1)
	 ;Update.setVisible(0,dy)) (* Update.setVisible ist wichtig - 
				    <> zu Widget.setVisible ! *)
	end

    (* Mechanismus zum "Neu-Inspizieren" (wird fuer font-Groesse-
     Aenderungen benutzt) *)

    val inspectFct = ref (fn _ => ())
    val inspectInfFct = ref (fn _ => ())

    fun uninspect() = 
	let
	    val li = Dictionaries.Main.dict2list(Dictionaries.maindict)
	    val desc_li = rev(List.foldl 
			      (fn ((n,sep),li) => (getDesc(n))::li ) nil li)
	in
	    (List.app (fn (n,sep) => deleteNodeTree n) li
	     ; desc_li)
	end

    fun re_inspect() = 
	let 
	    val li = uninspect()
	in
	    List.app (fn d => case d of 
		      VALUE(r) => (!inspectFct) (#value(r),#typ(r))
		    | I_VALUE(r) => (!inspectInfFct)  (#value(r),#typ(r))
		    | _ => ()) li
	end

 (* Handles ok Button in Preferences Window *)
     fun okHandler(w,
	      width_s,
	      depth_s,
	      font_s, 
	      treemode_button,
	      relmode_button, 
	      tokenmode_button) = (fn _ => 
	       		   (  Settings.max_width := 
			    spinButtonGetValueAsInt(width_s) 
			    ;Settings.max_depth := 
			    spinButtonGetValueAsInt(depth_s)
			    (* Fontgroesse *) 
			    ;  let
				  val new_size = 
				      spinButtonGetValueAsInt(font_s)
			      in
				  if !Settings.fontSize = new_size then ()
				  else ( Settings.setFontSize(new_size)
				       ; re_inspect())
			      end 
			    ;Settings.relmode := (
			    toggleButtonGetActive(relmode_button) = true
						  orelse 
			   toggleButtonGetActive(tokenmode_button) = true)
			    ;Settings.tokenmode :=  
			    toggleButtonGetActive(tokenmode_button) = true
			    ;widgetDestroy(w)
			    ;if 
			    toggleButtonGetActive(treemode_button) = true 
				 then (Dictionaries.RelMan.dumpAll
				       (Dictionaries.reldict)
				       ; relnumber := 0)
			     else ()))

    
     (* Preferences Window Handler *)
     fun Preferences _ = Server.serve (fn () =>
       	   let	
           (* Width & Depth Settings *)
	   val width_lab = labelNew("Set Width Limit to...")	       
	   val width_s = createSpinButton{init =(!Settings.max_width) , 
					   lower = 0, 
					   upper = 100, 
					   inc = 1, 
					   dec = 0}
	    val depth_s = createSpinButton{init =(!Settings.max_depth) , 
					   lower = 0, 
					   upper = 100, 
					   inc = 1, 
					   dec = 0}
	    val depth_lab = labelNew("Set Depth Limit to...")
	    val table = createTable{rows = 2, cols = 4, 
				    entries = [(width_lab,0,2,0,1),
				     (width_s,2,3,0,1),
				     (depth_lab,0,2,1,2),
				     (depth_s,2,3,1,2)]}
	    val frame = createFrame("",table)
	    (* Mode Settings *)
	    val treemode_button =radioButtonNewWithLabel(uglyNULL, 
       			      "Tree Mode")
	    val group = radioButtonGroup(treemode_button)
	    val tokenmode_button = radioButtonNewWithLabel(group, 
				"Relational Mode - Token Equality")
	    val group = radioButtonGroup(tokenmode_button)
	    val relmode_button = radioButtonNewWithLabel(group, 
				"Relational Mode - Structural Equality")
	    val _ = if !Settings.tokenmode 
			then toggleButtonSetActive(tokenmode_button,true )
		    else if !Settings.relmode then 
			toggleButtonSetActive(relmode_button,true )
			else
			toggleButtonSetActive(treemode_button,true )

	    val radiobox = createVBoxDefaults[treemode_button,
					      relmode_button,
					      tokenmode_button]

	    val font_lab = labelNew("Set Font Size to...")	
	    val font_s = createSpinButton{init =(!Settings.fontSize) , 
					  lower = 8, 
					   upper = 50, 
					   inc = 1, 
					   dec = 0}
	    val app_table = createTable{rows = 2, cols = 4, 
				    entries = [(font_lab,0,2,0,1),
					       (font_s,2,3,0,1)]}

	    (* Buttonbox *)

	    val w = toplevelWindowNew()
	    val bbox = createButtonBox{buttons = 
		      [BObj("ok",[Handler("clicked",
					  (okHandler(w,
						     width_s,
						     depth_s,
						     font_s, 
						     treemode_button,
						     relmode_button,
						     tokenmode_button)   ))]),
		       BObj("apply",[]),
		       BObj("cancel",
			    [Handler("clicked",fn _ => 
				     widgetDestroy(w))])],
				       borderwidth = 20}

	    val n = createNotebook[("Width & Depth Limit Settings",frame),
				   ("Mode Settings",radiobox)  ,
				    ("Appearance",app_table)   ] 

	    val vbox = createVBoxDefaults[n,bbox]
		in
		    (windowSetTitle (w, "Preferences")
		    ;windowSetPolicy(w,0,0,1)
	            ;containerAdd(w,vbox)
	            ;signalConnect (w, "delete-event", 
					fn _ => widgetDestroy(w) )
		     ;widgetShowAll(w))
	end)

	
	 (* Menu-Bar *)
     val bar = GtkSupport.createMenu
	 (BarObj[MenuObj
		 {title = "Inspector",
		  items = [EntryObj
			   (LABEL "About...",
			    [Handler("activate",
				   fn _ => Server.serve (aboutWindow) )],true),
			   EntryObj(SEP,[],true),
			   EntryObj(LABEL "Close",
				    [Handler("activate",
					     DeleteWindow)],true)],
		  sensitive = true},
		 MenuObj
		 {title = "Selection",
		  items = [EntryObj(LABEL "Expand",
				    [Handler("activate",
					     handleExpandSelection)]
				    ,true),
			   EntryObj(LABEL "Shrink",
				   [Handler("activate",
					    handleShrinkSelection)]
				    ,true),
			   EntryObj(SEP, [],true),
			   EntryObj(LABEL "Reinspect",
				    [Handler("activate",handleReinspectSelection)]
				    ,true)],
		  sensitive = true}   ,
		 MenuObj
		 {title = "Options",
		  items = [EntryObj(LABEL "Preferences...",
				    [Handler("activate",
					     Preferences)],true)],
		  sensitive = true}]) 

     
		  
	val _ = menuBarAppend(bar,stopButton)
	val _ = menuItemRightJustify(stopButton)

 
(* Sendet Typinformation eines Knotens an den Statusbar *)
	fun postT n = 
	 let  
	     val desc = Node.getDesc(n)
	     val positions_displayed = Real.trunc(canvaswidth(hadj)) div 6 
	 in
	     (case desc of
		 Node.INTERPUNCT => 0
	       |  Node.VALUE(r) => 
		     let
			 val text = PrettyPrint.toString
			     (PPType.ppTyp(#typ(r)),1000)
		     in
			 if
			     (String.size(text)) > positions_displayed 
			     then
				 postType("  " 
			      ^String.extract(text, 0,SOME( positions_displayed)) 
					  ^ " ... ")
			 else
			     postType("  " ^ text)
		     end
	       | Node.I_VALUE(r) =>
		     postType("  " 
			      ^ String.extract(PrettyPrint.toString
					       (PPInf.ppInf(#typ(r)),
						positions_displayed	),
					       0,
					       SOME( positions_displayed)) 
			      ^ " ... ")
		     ;()) handle _ => ()
	 end
   


fun makePopup n = 
	let 
	    val w = handleWidth(n)
	    val d = handleDepth(n)
	    val r = handleReinspect(n)
	    val f = handleForce(n)
	    val reinspect_active = not(Node.getDesc(n) = Node.INTERPUNCT)
	    val force_active = (Node.isByneed n) handle _ => false
	    val delete_active = getParent(n) = Empty orelse 
		                (isRelNode(getParent(n)) 
				 andalso getParent(getParent(n)) = Empty)
	    val width_item_list = [EntryObj(LABEL("-5"),
					      [Handler("activate",w(~5))],
						       true),
				   EntryObj(LABEL("-4"),
					    [Handler("activate",w(~4))],
					    true),
				   EntryObj(LABEL("-3"),
					      [Handler("activate",w(~3))],
					         true),
				     EntryObj(LABEL("-2"),
					      [Handler("activate",w(~2))],
					      true),
				     EntryObj(LABEL("-1"),
					      [Handler("activate",w(~1))],
					      true),
				     EntryObj(SEP,[],true),
				     EntryObj(LABEL("+1"),
					      [Handler("activate",w(1))],
					      true),
				     EntryObj(LABEL("+2"),
					      [Handler("activate",w(2))],
					      true),
				     EntryObj(LABEL("+3"),
					      [Handler("activate",w(3))],
					      true),
				     EntryObj(LABEL("+4"),
					      [Handler("activate",w(4))],
						       true),
				     EntryObj(LABEL("+5"),
					      [Handler("activate",w(5))]
					      ,true),
				     EntryObj(SEP,[],true),
				     EntryObj(LABEL("+10"),
					      [Handler("activate",w(10))],
					      true) 
				     ]
		val depth_item_list = [EntryObj(LABEL("-5"),
					      [Handler("activate",d(~5))],
						       true),
				   EntryObj(LABEL("-4"),
					    [Handler("activate",d(~4))],
					    true),
				   EntryObj(LABEL("-3"),
					      [Handler("activate",d(~3))],
					         true),
				     EntryObj(LABEL("-2"),
					      [Handler("activate",d(~2))],
					      true),
				     EntryObj(LABEL("-1"),
					      [Handler("activate",d(~1))],
					      true),
				     EntryObj(SEP,[],true),
				     EntryObj(LABEL("+1"),
					      [Handler("activate",d(1))],
					      true),
				     EntryObj(LABEL("+2"),
					      [Handler("activate",d(2))],
					      true),
				     EntryObj(LABEL("+3"),
					      [Handler("activate",d(3))],
					      true),
				     EntryObj(LABEL("+4"),
					      [Handler("activate",d(4))],
						       true),
				     EntryObj(LABEL("+5"),
					      [Handler("activate",d(5))]
					      ,true),
				     EntryObj(SEP,[],true),
				     EntryObj(LABEL("+10"),
					      [Handler("activate",d(10))],
					      true) 
				     ]
	in
	case n of
	Node.RelNode _ => ()
      | Node.RelRefNode _ => ()
      | _ =>
	Server.serve (fn () => 
	       (createMenu
		(PopupObj
		 [MenuObj{title = "Explore Tree",
			  items = [MenuObj
				   {title = "width",
				    items = width_item_list,
				    sensitive = true},
				   MenuObj
				   {title = "depth",
				    items = depth_item_list,
			  sensitive = true}],
			  sensitive = true},
		  MenuObj{title = "Filter",
			  items = [],
			  sensitive = true},
		  MenuObj{title = "Actions",
			  items = [EntryObj(LABEL("reinspect"),
					    [Handler("activate",r)],
					    reinspect_active),
				  EntryObj(LABEL("force evaluation"),
					   [Handler("activate",f)],
					   force_active),
				   EntryObj(LABEL("delete tree"),
					    [Handler("activate",
					   fn _ => deleteNodeTree n)],
					    delete_active)],
			  sensitive = true}])
		;()))
	end

(* Handelt Mouseclick *)
     fun handleEvent event = Server.serve (fn () =>
     let
	 val font_width = !Settings.fontWidth
	 val font_height = !Settings.fontHeight  
	 val position = getMouseClickEventInfo(event,hadj,vadj) 
     (* uses Gdk datatype -> GtkSupport *)
     in
	case position of 
	  SOME ((x,y),b)=> 
		let 
		    val node = search(x,y)      
		in 
		    (case node of 
			    SOME(n) => 
				let 
				    val ydim =Node.get_ydim(n) 
				    val group = Node.getGroup(n)
				    val x2 = Real.fromInt(font_width 
					    	* Node.get_xdim(n))
				    val y2 = Real.fromInt(font_height 
						  * ydim)
				    val y2' = Real.fromInt(font_height 
						  * (ydim-1))
				    val lx =Real.fromInt(font_width 
				     *  Node.get_l_xdim(n))
				    val re =createRectangle(group,
							    0.0,
							    0.0,
							    lx,
							    y2)
				    val re' = createRectangle(group,
							    0.0,
							    0.0,
							    x2,
							    y2')
				in                                             
				    (  postT n   
				    ; canvasItemLowerToBottom(re) 
				    ; canvasItemLowerToBottom(re') 
				    ; destroySelectionMarkings()
				    ; selection := SOME (n,re,re') 
				    ; setSelectionMenuSensitive(bar,true)
				    ; case n of
				     Node.Limit(_) => 
					 setExpandSensitive(bar,true)
				       | _ => setExpandSensitive(bar,false)
				    ; case b of
				       1 => ()
				    |  3 =>( makePopup n; ())
				    | _   => () ) 
				end
			  | NONE => ( setSelectionMenuSensitive(bar,false)
				     ; destroySelectionMarkings()
					 ; selection := NONE))
		    end
        | NONE => ()
     end)

(* Handlet Tastendruck *)
     fun handleWindowEvent event = 
	 Server.serve (fn () => 
		       handleGdkKeyPress(event,
					 scrolled,
					 hadj,
					 vadj,
					 !Settings.max_x,
					 !Settings.max_y))

(**************************************************************************)

(* Neuanlegen / Wiedereroeffnen des Fensters (eine neue Canvas wird eingefuegt) *)
     fun new _ = if !alive then()
		 else
		     let
			 val _ = if !canvas =GtkSupport.uglyNULL
				     then ()
				 else objectDestroy(!canvas)
			 structure DA  =  
			     MkDrawingArea(val xsize = !Settings.max_x 
					   val ysize = !Settings.max_y) 
			     : DRAWING_AREA
		     in
			 (canvas := DA.canvas
			  ;canvasroot := DA.root
			  ;resize :=  (handleResize(scrolled,hadj,vadj,DA.resize))
			  ;Update.resize := !resize
			  ;containerAdd(scrolled,DA.canvas)
			  ;signalConnect(scrolled,"size_allocate",
					 fn _ => !resize())
			  ;signalConnect(hadj,"value_changed",fn _ => 
					 freezeThaw(DA.canvas))
			  ;signalConnect(vadj,"value_changed",fn _ => 
					 freezeThaw(DA.canvas)) 
			  ;signalConnect(DA.canvas,"event",handleEvent)
			  ;widgetShowAll(window)
			  ; alive :=true) 
		     end
		 
     val _ = new() (* erzeugt initiales Fenster *)

	 (* Fensterinitialisierung *)
     val _ = (windowSetTitle (window, "Alice Browser V 0.9")
	      ; widgetSetUsize (window, 200, 100) 
	      ; windowSetDefaultSize(window, 600,500)
	      ;signalConnect (window, "delete-event", DeleteWindow)
	      ;setSelectionMenuSensitive (bar,false)  
	      ;containerAdd(window,createVBox[(bar,
						    false 
						   ,false,
						    0),
						  (scrolled,
						   (* Gtk.EXPAND *) true,
						   (* Gtk.FILL *) true,0),
						  (status, 
						   false ,
						  false  ,0)])
	      ;signalConnect(window,"event",handleWindowEvent))

(**** Initialisierung ****)

     

     val path_promise = CreateTree.lookupPath(CreateTree.coreSign,
					   "Promise","promise")   
	 
     val path_package = CreateTree.lookupPath(CreateTree.packageSign,
					   "Package","package") 
	 
     val path_val_package = CreateTree.lookupPath(CreateTree.packageSign,
					       "Package","val_package") 

     fun init () = ( registerType(path_int, createInt)
		   ; registerType(path_string, createString)
		   ; registerType(path_char, createChar)
		   ; registerType(path_word, createWord)
		   ; registerType(path_real, createReal)
		   ; registerType(path_exn, createExn)
		   ; registerType(path_ref, createRef)
		   ; registerType(path_vec, createVector)
		   ; registerType(path_array, createArray)
                   ; registerType(path_promise, createPromise)
                   ; registerType(path_package, createPackage)  
		   ; registerType(path_val_package, createValPackage) 
 
		   ; registerColor(INT_COLOR,  allocColor(0,45000,0))
		   ; registerColor(REAL_COLOR, allocColor(0,45000,0))
		   ; registerColor(CHAR_COLOR, allocColor(45000,0,50000))     
		   ; registerColor(STR_COLOR, allocColor(45000,0,50000)) 
		   ; registerColor(WORD_COLOR, allocColor(0,43000,0))
		   ; registerColor(EXN_COLOR,  allocColor (60000,40000,0))
		   ; registerColor(REF_COLOR, allocColor(0,0,0))
		   ; registerColor(LABEL_COLOR, allocColor (0,10000,65535))
		   ; registerColor(SEP_COLOR, allocColor(0,0,0))
	           ; registerColor(EQU_COLOR, allocColor(0,0,0))
	           ; registerColor(LIMIT_COLOR, allocColor (10000,60000,10000))
	           ; registerColor(BRACK_COLOR, allocColor (0,5000,47000))
	           ; registerColor(REL_COLOR, allocColor (60000,20000,0))
	           ; registerColor(DEFAULT, allocColor(0,0,0)) 
	           
	           ; Update.incrActLine := (fn dy => incr_act_line dy) )

(**** Ende Initialisierung ****)

fun setVisible (x,y) = let
			   val w = !Settings.fontWidth
			   val h = !Settings.fontHeight
			   val rx =  Real.fromInt(w * x)
			   val ry =  Real.fromInt(h * y)
		       in
			   (if Real.> (rx,!(Settings.max_x)) 
				then Settings.max_x := rx 
			    else ()
			    ;Settings.max_y := 
				Real.+(!Settings.max_y,ry))
		       end



(********** Inspizieren **********)

    fun inspect(v,t) = 
	let
	    val va = UnsafeValue.cast v: Reflect.value
	    val i = Dictionaries.Main.
		        getHighestIndexAssigned(Dictionaries.maindict) +1
	    val root = (new()
		       ; relnumber := 0
		       ;!canvasroot)
	    val save_settings = (!Settings.max_width,!Settings.max_depth)
	    val n = (stopButtonSetActive(true)
		     ;CreateTree.newTree(va,t,i,root))		
            val line = (stopButtonSetActive(false)
			; if !stopflag 
			      then ( Settings.set_width(#1(save_settings))
				    ; Settings.set_depth(#2(save_settings))
				    ; stopflag := false )
				  else ()
			;Layout.layout(n)
			;setVisible(get_xdim(n),get_ydim(n)+1)
			;createSepLine(root,!act_line,canvaswidth(hadj),
				       Settings.getFontHeight()))
	in
	    ( Draw.draw(n,0,!act_line,false)
	    ; incr_act_line(get_ydim(n) + 1)
	    ; TextIO.print ("Widget: changing actline by " 
			    ^ Int.toString (get_ydim(n)+1)
			    ^ "\n")
	    ; (!resize)()
	    ; show()
	    ; Dictionaries.Main.insertI(Dictionaries.maindict,(n,line)); ())
	end 
			   
    fun inspectInf(v,t) = 
	let
	    val va = UnsafeValue.cast v: Reflect.module
	    val i = Dictionaries.Main.
		        getHighestIndexAssigned(Dictionaries.maindict) +1
	    val root = (new()
			;stopButtonSetActive(true)
			; relnumber := 0
			;!canvasroot)
	    val save_settings = (!Settings.max_width,!Settings.max_depth)
	    val n = (stopButtonSetActive(true)
		     ;CreateTree.newTreeInf(va,t,i,root))
            val line =(stopButtonSetActive(false) 
		       ; if !stopflag 
			      then ( Settings.set_width(#1(save_settings))
				    ; Settings.set_depth(#2(save_settings))
				    ; stopflag := false )
				  else ()
		       ;Layout.layout(n)
		       ;setVisible(get_xdim(n),get_ydim(n)+1)
		       ;createSepLine(root,!act_line,canvaswidth(hadj),
				      Settings.getFontHeight() ))
	in
	    ( Draw.draw(n,0,!act_line,false)
	    ; incr_act_line(get_ydim(n) + 1)
	    ; setVisible(get_xdim(n),get_ydim(n)+1)
	    ; (!resize)()
            ; show()
	    ; stopButtonSetActive(false)
	    ; Dictionaries.Main.insertI(Dictionaries.maindict,(n,line)); ())
	end 
   
val _ = (inspectFct := inspect
	 ;inspectInfFct := inspectInf)
	 

end (* structure Widget end *)

end (* local end *)
