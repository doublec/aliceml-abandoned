(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)


import structure Type          from "x-alice:/lib/rtt/Type"
import structure Label         from "x-alice:/lib/rtt/Label"
import structure UnsafeValue   from "x-alice:/lib/system/UnsafeValue"
import structure Reflect       from "x-alice:/lib/system/Reflect"
import structure Types         from "Types"
import signature HELPER        from "HELPER-sig"

local 

open Types

in

structure Helper :> HELPER = 
struct

(* Bestimmung und Zerlegung von "Apply"-Typen *)   

    fun isApply t = case t of Type.Apply(_,_) => true
                           | _ => false 

(* old version *)

  (*  fun unApply(Type.Apply(t1,t2))
       = let val t = ref (Type.inspect(t1)) 
             val l = ref [t2]
         in (while isApply (!t) do
             ( case !t of 
               Type.Apply(t11,t12) => (t := (Type.inspect(t11)) 
				       ; l:= [t12]@(!l))
             | _ => () ) ; (!t,!l))
	 end *)
     
(* new version from 5. March *)

    fun unApply'(Type.Apply(t1,t2),li) = unApply'(Type.inspect(t1), t2::li)
      | unApply'(sth,li) = (sth, rev li)

    fun unApply sth = unApply' (sth,nil)
	


(* Rows *)

    fun row2list row = case Type.inspectRow(row) of 
	Type.EmptyRow => nil
      | Type.UnknownRow => nil
      | Type.FieldRow(lab,t,row2) => 
	    (lab,t)::row2list(row2)

    fun labelvector (ll:(Label.lab * Type.typ) list) = 
	Vector.tabulate ((List.length(ll)), 
			 (fn i =>(#1( List.nth(ll,i))) ) )  

(* Arrays *)

    fun array_map (funct,a) = array_map' (funct,a,0)

    and array_map' (funct,a,i) = 
	if i < Array.length(a) 
	    then (funct(Array.sub(a,i));array_map' (funct,a,i+1)) 
	else ()

    fun copyArray' (a, b, i) = if i = Array.length(a) 
				   then ()
				       else
	                       (Array.update(b,i,Array.sub(a,i))
				; copyArray' (a,b,i+1))
    
    fun copyArray (a,b) = if Array.length(a) > Array.length(b) 
			      then raise Match 
				  else copyArray'(a,b,0)

(* Strings *)

    fun iterTake str = iterTake'(str,0,"")
	
    and iterTake' (str,i,a) = 
	if i >= (String.size(str)) 
	    then a
	else
	    let val test = String.sub(str,i) 
	    in if Char.equal(#" ",test)
		   then a
	       else iterTake' (str,i+1, a ^ Char.toString(test))
	    end  

(* alternative Version *)
(*  fun iterTake' ((#" "::xr),a) = implode (rev(a))
      | iterTake' ((x::xr),a) = iterTake' (xr,(x::a))
	
    fun iterTake str = iterTake' ((explode str),nil)  *)

(* Test, ob bestimmte node-Art vorliegt *)

    fun isSimple n = case n of
	Simple _ => true
      | _ => false

    and isRelNode n = case n of
	RelNode _ => true
      | _ => false

    and isRelRefNode n = case n of
	RelRefNode _ => true
      | _ => false

    and isLimit n = case n of
	Limit _ => true
      | _ => false

(* Zugriff auf bestimmte node-Felder *)

    (* get_xdim *)
    fun get_xdim n = case n of Simple(r) => !(#width(r))
                             | Concat(r) => !(#width(r))
                             | Container(r) => !(#width(r))
                             | RelNode(r) => !(#width(r))
                             | RelRefNode(r) => !(#width(r))
			     | Limit(_) => 2
                             | Empty => 0

    (* get_ydim *)
    fun get_ydim n = case n of Concat(r) => !(#height(r))
                             | Container(r) => !(#height(r))
                             | RelNode(r) => !(#height(r))
                             | Empty => 0
                             | _ => 1

  
    (* get_l_xdim *)
    fun get_l_xdim (Container(r)) = !(#l_width(r))
      | get_l_xdim (Concat(r))  =  !(#l_width(r))
      | get_l_xdim (RelNode(r)) = (get_l_xdim(
					    !(#content(r)))) + 
				(if isSimple (!(#content(r)))
				     orelse !(#counter(r)) = 1 
				     then 0 
				 else String.size(#rep(r)))
      | get_l_xdim node = get_xdim node

    fun getDesc n = case n of Simple(r) => #desc(r)
                            | Concat(r) => #desc(r)
                            | Container(r) => #desc(r) 
                            | Limit(r) => #desc(r)
                            | RelNode(r) => #desc(r)
                            | RelRefNode(r) => #desc(r)
                            | Empty => INTERPUNCT	

    fun getParent n = case n of Concat(r) => #parent(r)
                              | Container(r) => #parent(r)
                              | Simple(r) => #parent(r) 
                              | Limit(r) => #parent(r)
                              | RelNode(r) => #parent(r)
                              | RelRefNode(r) => #parent(r)
                              | _ => raise Match  

    fun getIndex n = case n of Concat(r) => #index(r)
                             | Container(r) => #index(r)
                             | Simple(r) => #index(r)
                             | Limit(r) => #index(r)
                             | RelNode(r) => #index(r) 
                             | RelRefNode(r) => #index(r)
                             | _ => raise Match

    fun getDepth n = case n of Limit(r) => #depth(r)
                             | Concat(r) => #depth(r)
                             | Container(r) => #depth(r)
                             | Simple(r) => #depth(r)
                             | RelNode(r) => #depth(r)
                             | RelRefNode(r) => #depth(r)
                             | _ => raise Match

    fun getRep (Simple(r))     = #rep(r)
      | getRep (RelNode(r))    = #rep(r)
      | getRep (RelRefNode(r)) =  #rep(r)
      | getRep _               = ""
	
    fun getKids n = case n of Concat(r) => #kids(r)
                            | Container(r) => #kids(r)
			    | _ => (Array.array(0,Empty))

    fun getContent (RelNode(r)) = !(#content(r))
      | getContent _ = raise Match

    fun getStatus (Concat(r))     = #status(r)
      | getStatus (Container(r))  = #status(r)
      | getStatus (Simple(r))     = #status(r) 
      | getStatus (Limit(r))      = #status(r)
      | getStatus (RelNode(r))    = #status(r)
      | getStatus (RelRefNode(r)) = #status(r)
      | getStatus  _ = raise Match

    fun getGroup n = case n of Concat(r) => #group(r)
                              | Container(r) => #group(r)
                              | Simple(r) => #group(r) 
                              | Limit(r) => #group(r)
                              | RelNode(r) => #group(r)
                              | RelRefNode(r) => #group(r)
                              | _ => raise Match

    fun getColor (Simple(r))     = #color(r) 
      | getColor (RelNode(r))    = #color(r)
      | getColor (RelRefNode(r)) = #color(r)
      | getColor  _ = raise Match

    fun getSort (Limit(r)) = #sort(r)
      | getSort _  = raise Match

    fun getReflectValue n = case getDesc(n) of
	                    INTERPUNCT => raise Match
			  | VALUE(r) => #value(r) 
			  | I_VALUE(r) => UnsafeValue.cast (#value(r))

(* Zugriff auf bestimmte "Vorfahren" bzw. deren Felder *)   

    fun getValueAnc n = let val p = getParent(n) 
			in if p = Empty 
			       then n 
			   else if getDesc(p) = INTERPUNCT
				    then getValueAnc(p) 
				else p
			end

    fun getNoRelAnc n = let val p = getParent(n)
			in case p of RelNode _ => getNoRelAnc p
		                   | _ => (p,getIndex(n)) 
			end 

    fun getAncIndex n = if n = Empty 
			    then raise Match
			else if getParent n = Empty 
				 then getIndex n
			     else getAncIndex (getParent(n))

(* Hilfsfunktion zur Bestimmung von byneed-Futures *)

fun isByneed n = let
		     val future = case getDesc(n) of
			 Types.VALUE(r) => UnsafeValue.cast (#value(r)) 
		       | Types.I_VALUE(r) => UnsafeValue.cast (#value(r)) 
		       | Types.INTERPUNCT => raise Match
		 in
		     (Future.isLazy(future)) handle _ => false
		 end


(* Test, ob Container vertikal anordnet *)

    fun setsVertical n = case n of
	Container(r) 
        => checkContKids (#kids(r),0)
	   orelse ( case Array.sub(#kids(r),0) of
		    Simple(rr) => String.equal("struct",#rep(rr))
		  | _ => false )
      | _ => false
	                  			 
    and checkContKids (a,i) = if i >=  Array.length(a) 
				  then false
			      else (case Array.sub(a,i) of
				    Concat(r) 
				    => if checkConcKids (#kids(r),0)
	                                 then true
				       else checkContKids (a,i+1)
			   	  | RelNode(r) 
			            => ( case !(#content(r)) of 
					 Concat(rr)  
					 => checkConcKids (#kids(rr),0) 
					    orelse checkContKids (a,i+1) 
				       | Container(rr) => true 
				       | _ => checkContKids (a,i+1) ) 
				  | _ => checkContKids (a,i+1) )

    and checkConcKids (a,i) = if i >=  Array.length(a) 
				  then false 
			      else (case Array.sub(a,i) of
				    Container(r) => true
                                  | Concat(r) 
				    => checkConcKids(#kids(r),0)
				       orelse checkConcKids (a,i+1)
				  | RelNode(r) 
				    => ( case !(#content(r)) of 
					 Concat(rr)  
					 => checkConcKids (#kids(rr),0)  
					    orelse checkConcKids (a,i+1) 
				       | Container(rr) => true 
				       | _ => checkConcKids (a,i+1) )
                                  | _ => checkConcKids (a,i+1) )



(* RelNodes *)
	    
    fun setContent (n,c) = case n of RelNode(r) => #content(r) := c
                                   | _ => ()
                                        
    fun incrCounter n = case n of RelNode(r) 
	                          => (#counter(r) := !(#counter(r)) + 1; n)
                                | _ => n	

end (* struct *)

end
