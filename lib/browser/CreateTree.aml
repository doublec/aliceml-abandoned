(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Fixity from "x-alice:/lib/rtt/Fixity"
import structure Inf from "x-alice:/lib/rtt/Inf"
import structure Label from "x-alice:/lib/rtt/Label"
import structure Name from "x-alice:/lib/rtt/Name"
import structure Path from "x-alice:/lib/rtt/Path"
import structure PathMap from "x-alice:/lib/rtt/PathMap"
import structure PervasiveType from "x-alice:/lib/rtt/PervasiveType"
import structure Type from "x-alice:/lib/rtt/Type"
import structure Reflect from "x-alice:/lib/system/Reflect"
import structure UnsafeValue from "x-alice:/lib/system/UnsafeValue"

import structure Doc from "Doc"
import structure Node from "Node"
import structure GtkSupport from "GtkSupport"

import structure Settings from "Settings"
import structure Dictionaries from "Dictionaries"
import structure Update from "Update"
import structure CreateTreeHelper from "CreateTreeHelper"

import signature CREATE_TREE from "CREATE_TREE-sig"

local
    open Doc Node Settings Dictionaries CreateTreeHelper
	
in	
    
structure CreateTree :> CREATE_TREE =
struct
    
    exception createTree_unknownNode   

     (*** creates a new tree ***)

     (* checking mode / construction in RELATION MODE *)

     fun createTree (opt,va,t,p,i,d,canvas) =
	 if !relmode (* RELATION MODE *)
	     andalso not(isAtomType(t)) 
	     (* atomic values are always represented as in tree mode *)
             andalso ( not(isListType t andalso null(castList(va))) )
             (* empty list mustn't be inserted in relation manager *)
	     then 
	     let val ind = if p = Empty then i else getAncIndex p 
		 val desc = createValue(va,t) 
		 val relman = 
		       case RelMan.lookup(reldict,ind) of 
		       SOME x => x (* relation manager exists already *)
		       | NONE => [] 
		 val f = fn t: value * int ref * int
		         => isValue (#1(t)) andalso 
		            if !tokenmode (* token equality *)
				then UnsafeValue.same(asValue(#1(t)),va)   
			    else (* structural equality *)
				asValue(#1(t)) = va  
		 val new_relman = 
		     ( case List.find f relman of
			   NONE (* new value is beeing inserted *)
			   => RelMan.update(reldict,
					    (ind,(V va,
						  ref 1,
						  !relnumber)::relman))
			 | SOME (rv,co,nu) (* counter is beeing 
					      incremented *)
			   => co := !co + 1
		       ; valOf(RelMan.lookup(reldict,ind)) )
		 val (rva,count,number) = valOf(List.find f new_relman)
		 val str = "Ref"^Int.toString(number)
		 val node = if !count = 1 
				then createRelNode (desc,Empty,p,i,d,count,
						    str^" as ",canvas)
			    else createRelRefNode(desc,p,i,d,str,canvas) 
	     in ( if !count = 1 
		      then let val c = createUsualTree (opt,va,t,
							node,0,d,canvas)
			   in setContent (node,c)  
			   end 
		  else ()
                 ; node )
	     end 
	 else (* construction in tree mode *)
	     createUsualTree (opt,va,t,p,i,d,canvas) 
		     	    
     (* usual construction in TREE MODE *)

    and createUsualTree (opt,va,t,p,i,d,canvas) = 
	if d > !max_depth (** depth filter **)
	    then createLimit(createValue(va,t),DEPTH_LIMIT,p,i,d,canvas)
	else if (isSome(opt) andalso valOf(opt) > !max_width) 
                 orelse (isListType t andalso !max_width = 0)
	       (** width filter (used for cascaded representation of lists) **)
		 then let val desc = if isListType t 
					 then createValue(va,t)
				     else INTERPUNCT
		      in createLimit(desc,WIDTH_LIMIT,p,i,d,canvas)
		      end
	     else 
	     let 
		 val fut = UnsafeValue.cast va
	     in if not(Future.isDetermined(fut)) (* future *)
		    then createFutureNode (va,t,p,i,d,canvas)
		else
		  (case Type.inspect t of
		   Type.Con path (* path type *)
		   => let val p_path = 
		       if String.equal(Label.toString(Path.toLab(path)),
				       "package")
			   then lookupPath(packageSign,"Package","package")
		       else if String.equal(Label.toString(Path.toLab(path)),
					    "val_package")
				then lookupPath(packageSign,
						"Package","val_package")
			    else path 
		      in newPath (va,t,p,i,d,p_path,canvas)
		      end
		| Type.Arrow _  (* function *)
		   => createSimple (createValue(va,t),p,i,d,"fn",
				    DEFAULT,canvas)
		| Type.All(var,typ) (* all quantifier *)
		  => createUsualTree (NONE,va,typ,p,i,d,canvas)
		| Type.Exist(var,typ)  (* existencial quantifier *)
		  => createUsualTree (NONE,va,typ,p,i,d,canvas)
		| Type.Lambda(var,typ) (* abstraction *)
		  => raise  createTree_unknownNode 
		| Type.Apply(t1,t2) 
		  =>  if isListType t (* list *)
			  then let val new_opt = if isNone opt 
						     then SOME 2
						 else SOME (valOf(opt)+1)
				   val vv = castList va
				   val listdesc = inspectList(!max_width,vv)
			       in listdescToNode(new_opt,va,t,p,i,d,
						 listdesc,canvas)
			       end
		      else 
			(case unApply (Type.inspect(t)) of 
			 (Type.Con path, ts) (* cascaded path type  *) 
			  => let val p_path = 
			     if String.equal(Label.toString(Path.toLab(path)),
					     "promise") (* promise *)
				 then lookupPath(coreSign,"Promise","promise") 
			     else path 
			     in newPath (va,t,p,i,d,p_path,canvas)
			     end 
			| _ => raise createTree_unknownNode ) (* unknown *)
		| Type.Prod(row) (* record *)
		  => treatProd(va,t,p,i,d,row,canvas) 
		| Type.Mu(sum) (* rekursion *)
		  => createUsualTree (NONE,va,sum,p,i,d,canvas) (* Rekursion *)
		| Type.Sum(row) (* datatype *)
		  => treatSum(va,t,p,i,d,row,canvas) 
		| _ => raise  createTree_unknownNode (* unknown *) )
	     end 
			 
     (******* special handling of LISTS *******)

    and listdescToNode (opt,va,t,p,i,d,ld,canvas) = 
       case ld of 
	Indet(l,f) 
	=> if !relmode (* representation in relation mode *)
	       then createConsList(opt,va,t,l@f,p,i,d,canvas)
	   else let val desc = createValue(va,t)
		    val length = List.length l
		    val na = Array.array(length+1,Empty)
		    val fva = UnsafeValue.cast f : Reflect.value
		    val inty = #2(Type.asApply(t))   
		    val cont = createContainer (desc,p,i,d,na,canvas)
		    val nodearray = listElemArray(l,length,inty,
						  cont,d+1,true,canvas)
		    val future = if length >= !(Settings.max_width) 
				     then createLimit(INTERPUNCT,WIDTH_LIMIT,
						      cont,length,d+1,canvas)
				 else createFutureNode(fva,t,cont,length,d,canvas)
		in ( Array.update(na,length,future)
		    ; copyArray(nodearray,na)
		    ; cont )
		end
      | Det(l,b) 
        => if !relmode (* representation in relation mode *)
		then createConsList(opt,va,t,castList va,p,i,d,canvas)
           else 
	     let val desc = createValue(va,t)
		 val length = List.length l
		 val na = if b orelse !relmode 
			      then Array.array(length + 1,Empty)
			  else Array.array(length,Empty)
		 val inty = #2(Type.asApply(t))   
	     in if b (* width limit exceeded *)
		    then let val cont = createContainer (desc,p,i,d,na,canvas)
			     val nodearray = listElemArray(l,length,inty,
							   cont,d,b,canvas)
			     val last = createLimit (INTERPUNCT,WIDTH_LIMIT,
						     cont,length,d+1,canvas)
			 in ( Array.update(na,length,last)
			     ; copyArray(nodearray,na)
			     ; cont )
			 end
		else 
		   let val concat = createConcat(desc,p,i,d,
						 Array.array(3,Empty),canvas)
		       val lbra = createSimple (INTERPUNCT,concat,0,d,
						"[",BRACK_COLOR,canvas)
		       val rbra = createSimple (INTERPUNCT,concat,2,d,
						"]",BRACK_COLOR,canvas)
		       val cont = createContainer (INTERPUNCT,concat,1,d,
						   na,canvas)
		       val nodearray = listElemArray(List.take(l,length-1),
						     length-1,inty,cont,d,b,
						     canvas)
		       val last = let val inva = UnsafeValue.cast(List.last(l))
			                         : Reflect.value
				  in createTree(NONE,inva,inty,
						cont,length-1,d+1,canvas)
				  end      	
		   in ( Array.update(na,length-1,last)
		       ; copyArray(nodearray,na)
		       ; Array.update(getKids(concat),0,lbra)
		       ; Array.update(getKids(concat),1,cont)
		       ; Array.update(getKids(concat),2,rbra)
		       ; concat )
		   end
	     end
	    
     (* linear representation in tree mode *)
 
     and listElemArray(list,length,listtyp,p,d,b,canvas) = 
	 let val na = Array.array(length,Empty)
	 in ( List.appi (fn (i,item) => 
			 let  val concat = createConcat(INTERPUNCT,p,i,d,
							Array.array(2,Empty),
							canvas)
			     val inva = UnsafeValue.cast(item)
				        : Reflect.value
			     val elem = createTree(NONE,inva,listtyp,
						   concat,0,d+1,canvas)
			     val repr = if b then "::" else ", "
			     val sep = createSimple(INTERPUNCT,concat,1,d,
						    repr,SEP_COLOR,canvas)
			 in ( Array.update(getKids(concat),0,elem)
			     ; Array.update(getKids(concat),1,sep)
			     ; Array.update(na,i,concat))
			 end) list
	     ; na)
	 end
     
     (* cascaded representation in relation mode *)

     and createConsList (opt,va,t,list,p,i,d,canvas) = 
	 if null(list)
	     then createSimple(INTERPUNCT,p,i,d,"nil",DEFAULT,canvas)
	 else 
	  let val desc = createValue(va,t)
	      val inty = #2(Type.asApply(t))
	      val head = UnsafeValue.cast(hd(list)) : Reflect.value 
	      val tail = UnsafeValue.cast(tl(list)) : Reflect.value
	      val na = Array.array(2,Empty)
	      val contnode = createContainer(desc,p,i,d ,na,canvas)
	      val concnode = createConcat(INTERPUNCT,contnode,0,d,
					  Array.array(2,Empty),canvas)
	      val headnode = 
		  if  not(isListType(inty))
		      then createTree(NONE,head,inty,
				      concnode,0,d,canvas)
		  else 
		      let val conc = createConcat(INTERPUNCT,
						  concnode,0,d,
						  Array.array(3,Empty),
						  canvas)
			  val lpar = createSimple(INTERPUNCT,conc,0,d,
						  "(",BRACK_COLOR,canvas)
			  val rpar = createSimple(INTERPUNCT,conc,2,d,
						  ")",BRACK_COLOR,canvas)
			  val hnode = createTree(NONE,head,inty,
						 conc,1,d,canvas)
		      in ( Array.update(getKids(conc),0,lpar)
			  ; Array.update(getKids(conc),1,hnode)
			  ; Array.update(getKids(conc),2,rpar)
			  ; Array.update(getKids(concnode),0,conc)
			  ; conc )
		      end       
	      val sepnode = createSimple(INTERPUNCT,concnode,1,d,
					 "::",SEP_COLOR,canvas)
	      val tailnode = createTree(opt,tail,t,contnode,1,d,canvas)
	  in ( Array.update(getKids(concnode),0,headnode)
	      ; Array.update(getKids(concnode),1,sepnode)
	      ; Array.update(getKids(contnode),0,concnode)
	      ; Array.update(getKids(contnode),1,tailnode)
	      ; contnode )
	  end 

                 
     (***** special handling of RECORDS, TUPLES and DATATYPES *****)

    (* handling of RECORDS *)

    and treatProd (va,t,p,i,d,row,canvas) =  
	let val upperConcat = createConcat(createValue(va,t),p,i,d,
					   Array.array(3,Empty),canvas)
	    val (lbra,rbra) = if Type.isTupleRow(row) 
				  then ("(",")")
			      else ("{","}")
	    val (lbraNode,rbraNode) = (createSimple (INTERPUNCT,upperConcat,
						     0,d,lbra,BRACK_COLOR,
						     canvas),
				       createSimple (INTERPUNCT,upperConcat,
						     2,d,rbra,BRACK_COLOR,
						     canvas))
	    val container = createContfromRow (va,t,upperConcat,1,d,row, 
					       UnsafeValue.proj,canvas) 
	    val upperKids = getKids(upperConcat)
	in ( Array.update(upperKids,0,lbraNode)
	    ; Array.update(upperKids,1,container)
	    ; Array.update(upperKids,2,rbraNode)
	    ; upperConcat)
	end
	
     (* handling of DATATYPES *)

     and treatSum (va,t,p,i,d,row,canvas) = 
	 let val lt_list   = row2list(row)
	     val l_vector  = labelvector(lt_list)
	     val index     = UnsafeValue.tag(va,l_vector)
	     val typ = #2(List.nth(lt_list,index))
	     val intyp = if Type.isApply(typ) 
		         andalso Type.isCon(#1(Type.asApply(typ))) 
		         andalso Path.equal(Type.asCon(#1(Type.asApply(typ))),
					    PervasiveType.path_strict)
			     then  #2(Type.asApply(typ))
			 else typ
	     val emptyrow = case Type.inspect(intyp) of 
		            Type.Prod(row') 
			    => Type.isEmptyRow(row') 
			  | _ => false
	     val label = if emptyrow 
			     then Label.toString(Vector.sub(l_vector,index))
			 else  Label.toString(Vector.sub(l_vector,index))^" "
	     val upperConcat = if emptyrow 
				   then Empty 
			       else createConcat(createValue(va,t),p,i,d,
						 Array.array(4,Empty),canvas)
	     val (lbra,rbra) =  let val row' = Type.asProd(intyp)
				in if Type.isTupleRow(row')
				       then ("(",")")
				   else ("{","}")
				end
			        handle Type.Type => ("_","_")
	     val (lbraNode,rbraNode) = if lbra = "_" orelse emptyrow
					   then (Empty,Empty) 
				       else (createSimple(INTERPUNCT,
							  upperConcat,1,d,
							  lbra,BRACK_COLOR,
							  canvas),
					     createSimple (INTERPUNCT,
							   upperConcat,3,d,
							   rbra,BRACK_COLOR,
							   canvas))
	     val container = case Type.inspect(intyp) of 
		             Type.Prod(row') 
			     => if Type.isEmptyRow(row') 
				    then Empty
				else createContfromRow(va,t,upperConcat,2,d,
						       row', 
						       UnsafeValue.projTagged,
						       canvas)
			   | _ => let val inva = UnsafeValue.projTaggedTuple
				                             (va,1,0)
				      val node = createTree (NONE,inva,intyp,
							     upperConcat,2,d+1,
							     canvas) 
				  in node 
				  end
	     val labelnode =  createSimple (INTERPUNCT,
					    if container = Empty then p 
					    else upperConcat,
					    if container = Empty then i 
					    else 0,d,label,
					    LABEL_COLOR,canvas) 
	     val upperKids = getKids(upperConcat)
	 in if container = Empty 
		then labelnode 
	    else (Array.update(upperKids,0,labelnode)
		  ; Array.update(upperKids,1,lbraNode)
		  ; Array.update(upperKids,2,container)
		  ; Array.update(upperKids,3,rbraNode)
		  ; upperConcat) 
	 end

     (* creates a Container from a row *)

    and createContfromRow (va, t, p, i, d, row, proj,canvas) = 
	let val lt_list   = row2list(row)
	    val l_vector  = labelvector(lt_list)
	    val wlimit    = List.length(lt_list) > !max_width 
	    val l         = if wlimit 
				then !max_width
			    else List.length(lt_list)
	    val al = if wlimit then !max_width +1 else l
	    val container = createContainer(INTERPUNCT,p,i,d,
					    Array.array(al,Empty),canvas)
	    val createProdC = if Type.isTupleRow(row)
				  then createProdConcatTuple
			      else createProdConcat
	    val nodes = 
		Array.tabulate(al,
			       (fn i => 
				if wlimit andalso i = !max_width
				    then createLimit (INTERPUNCT,
						      WIDTH_LIMIT,
						      container,
						      i,d,canvas)
				else createProdC (Label.toString
						  (#1(List.nth(lt_list,i))),
						  proj(va,l_vector,i),
						  #2(List.nth(lt_list,i)),
						  container,i,d,al,canvas)) )
	in ( copyArray(nodes,getKids(container))
	    ; container )
	end

     and createProdConcat (label,va,t,p,i,d,l,canvas) = 
	 let val last = (i = l-1) 
	     val c_length = if last then 3 else 4
	     val concat = createConcat (INTERPUNCT,p,i,d,
					Array.array(c_length,Empty),canvas)
	     val l_node = createSimple (INTERPUNCT,concat,0,d,label,
					LABEL_COLOR,canvas)
	     val eq_node = createSimple (INTERPUNCT,concat,1,d," = ",
					 EQU_COLOR,canvas)
	     val sep_node = if last 
				then Empty
			    else createSimple (INTERPUNCT,concat,3,d,", ",
					       SEP_COLOR,canvas)
	     val node = createTree (NONE,va,t,concat,2,d+1,canvas)
	     val concat_kids = getKids(concat)
	 in ( Array.update(concat_kids,0,l_node)
	     ; Array.update(concat_kids,1,eq_node)
	     ; Array.update(concat_kids,2,node)
	     ; if last 
		   then () 
	       else Array.update(concat_kids,3,sep_node)
	     ; concat)
	 end
     
     (* vary special case of tuple *)

     and createProdConcatTuple (label,va,t,p,i,d,l,canvas) = 
	 let val last = (i = l-1)
	     val c_length = if last then 1 else 2
	     val concat = if last then Empty
			  else createConcat (INTERPUNCT,p,i,d,
					     Array.array(c_length,Empty),
					     canvas)
	    val sep_node = if last 
			       then Empty 
			   else createSimple (INTERPUNCT,concat,1,d,", ",
					      SEP_COLOR,canvas)
	    val node = createTree (NONE,va,t,
				   if last then p else concat,
				   if last then i else 0,
				   d+1,canvas)
	    val concat_kids = getKids(concat)
	 in if last 
		then node 
	    else ( Array.update(concat_kids,0,node)
		  ; Array.update(concat_kids,1,sep_node)
		  ;concat)                                       
	 end

     (******* special handling of values whose type is a PATH TYPE *******) 

    and newPath (v,t,p,i,d,path,canvas) =
        (case PathMap.lookup(pathTable, path) of
	   NONE (* nothing knwon about this type - not registered *)
	   => createSimple(INTERPUNCT,p,i,d,"_",DEFAULT,canvas)
	 | SOME create 
	   => let val doc = if d > !(Settings.max_depth) 
				then LIMIT{desc = createValue(v,t),
					   sort = DEPTH_LIMIT}
				    else create (!max_width,d,v,t)
	      in  docToNode (doc,p,i,d,canvas) 
	      end )

    (* converts docs to nodes *)

    and docToNode (doc,p,i,d,canvas) = 
        (case doc of
         SIMPLE(r) 
	 => createSimple (#desc(r),p,i,d,#rep(r),#color(r),canvas)  
       | CONCAT(r) => let val na = Array.array(Vector.length(#kids(r)),Empty)
			  val concat = createConcat(#desc(r),p,i,d,na,canvas)
		      in (Vector.appi 
			  (fn (i,a) 
			   => Array.update(na,i,
					   docToNode(a,concat,i,d,canvas))) 
			  (#kids(r))
			  ; concat)
		      end
       | CONTAINER(r) => let val na = Array.array(Vector.length(#kids(r)),
						  Empty)
			     val container = createContainer(#desc(r),p,i,d,
							     na,canvas)
			 in (Vector.appi
			     (fn (i,a) 
			      => Array.update(na,i,
					docToNode(a,container,i,d,canvas)))
			     (#kids(r))
			     ; container)
			 end
       | LIMIT(r) => createLimit(#desc(r),#sort(r),p,i,d,canvas) 
       | EMBEDDED(v,t) => createTree (NONE,v,t,p,i,d+1,canvas)
       | EMBEDDED_INF(v,t) => createTreeInf (v,t,p,i,d+1,canvas) ) 
  	     
     (******* special handling of FUTURES *******)
	     
     and createFutureNode (va,t,p,i,d,canvas) = 
	 let val desc = createValue(va,t)
	     val fut = UnsafeValue.cast va
	     val str = if Future.isLazy fut then "byneed" else "future"
	     val simple =  createSimple (desc,p,i,d,str,DEFAULT,canvas)
	 in ( case Transient.iterLookup
	                     (transdict,fn (vv,_,li) 
			                => List.exists(fn n  
						       => UnsafeValue.same  
						         (getValue(getDesc(n)),
							  va))  li 
			      handle General.Match => false) of 
	      SOME ((vv,thr,li),i)   
	      => Transient.update(transdict,(i,(vv,thr,li@[simple]))) 
            | NONE  
	      => (let val id = Dictionaries.Transient.getHighestIndexAssigned
		                             (Dictionaries.transdict) +1
		      val watcher = Update.watcher(fut,va,id,
						   createTree,createTreeInf,
						   canvas)
		  in ( Transient.insertI(transdict,(va,watcher,[simple])) ; ())
		  end)
	     ; simple )
	 end 	
  
     (***************************************)

     (*** analogous tree creation for modules ***)
 
     (*** creates a new tree ***)

     (* checking mode / construction in RELATION MODE *)

     and createTreeInf (va,t,p,i,d,canvas) =
	 if !relmode (* RELATION MODE *)
	     then let val ind = if p = Empty then i else getAncIndex p 
		      val desc = createIValue(va,t) 
		      val relman = 
			    case RelMan.lookup(reldict,ind) of 
			    SOME x => x (* relation manager exists already *)
			  | NONE => []
		      val f = fn t: value * int ref * int
			      => isModule (#1(t)) andalso 
			         if !tokenmode (* token equality *)
				     then UnsafeValue.same(asModule(#1(t)),va)
				 else (* structural equality *)
				     asModule(#1(t)) = va  
		      val new_relman = 
			  ( case List.find f relman of
				NONE (* new value is beeing inserted *)
				=> RelMan.update(reldict,
						 (ind,(M va,
						       ref 1,
						       !relnumber)::relman))
			      | SOME (rv,co,nu) (* counter is beeing 
						   incremented *)
				=> co := !co + 1 
			    ; valOf(RelMan.lookup(reldict,ind)) )
		      val (rva,count,number) = valOf(List.find f new_relman)
		      val str = "Ref"^Int.toString(number)
		      val node = if !count = 1 
				     then createRelNode (desc,Empty,p,i,d,
							 count,str^" as ",
							 canvas)
				 else createRelRefNode(desc,p,i,d,str,canvas) 
		  in ( if !count = 1 
			   then let val c = createUsualTreeInf (va,t,node,0,d,
								canvas)
				in setContent (node,c)  
				end 
		       else ()
		      ; node )
		  end 
	 else (* construction in tree mode *) 
	     createUsualTreeInf (va,t,p,i,d,canvas) 
 			         
     (* usual construction in TREE MODE *)

     and createUsualTreeInf (va,t,p,i,d,canvas) = 
	 if d > !max_depth (** depth filter **)	  
	     then let val desc = createIValue(va,t)  
		  in createLimit(desc,DEPTH_LIMIT,p,i,d,canvas) 
		  end 
	else 
	(case Inf.inspect t of  
	 Inf.Sig(s) (* signature / structure *) 
	 => let val ilist = List.rev(Inf.items(s)) 
	    in treatSig (va,t,p,i,d,ilist,canvas) 
	    end  
       | Inf.Arrow(path,i1,i2) (* functor *)
	 => createSimple (createIValue(va,t),p,i,d,"functor", 
			       DEFAULT,canvas) 
       | Inf.Exist(path,i1,i2) (* existencial quantification *) 
	 => createUsualTreeInf (va,i2,p,i,d,canvas) 
       | Inf.Sing(m) (* singleton *) 
	 => let val ti = #2(Inf.asMod(m)) 
	    in createUsualTreeInf (va,ti,p,i,d,canvas)
	    end 
       | _ => createSimple (INTERPUNCT,p,i,d,"_",DEFAULT,canvas) (* unknown *) ) 
	     
    (* handling of SIGNATURES / STRUCTURES  -
       construction of the frame *)

    and treatSig (va,t,p,i,d,ilist,canvas) = 
	let val ilength = List.length(ilist)
	    val limited = ilength > !max_width
	    val a_length = if limited 
			       then 3 + !max_width
			   else 2 + List.length(ilist)
	    val container = 
		createContainer(createIValue(va,t),p,i,d,
				Array.array(a_length,Empty),canvas)
	    val s_begin = createSimple(INTERPUNCT,container,0,d,"struct",
				       DEFAULT,canvas)
	    val s_end = createSimple(INTERPUNCT,container,a_length-1,d,
				     "end",DEFAULT,canvas)
	in ( Array.update(getKids(container),0,s_begin) 
	    ; Array.update(getKids(container),a_length-1,s_end) 
	    ; if not(limited)
		  then setItems (va,ilist,container,d,ilength,canvas)
	      else let val limit = createLimit(INTERPUNCT,WIDTH_LIMIT,
					       container,a_length-2,d,
					       canvas)
		   in ( Array.update(getKids(container),a_length-2,limit)
		       ; setItems (va,List.take(ilist,!max_width),
				   container,d,!max_width,canvas) )
		   end 
	    ; container ) 
	end   

     and setItems (va,ilist,p,d,length,canvas) = 
	 appi_break ((fn (i,item) 
		      => let val vv = UnsafeValue.cast va
			     val label = itemToLabel(item) 
			     val in_vv = UnsafeValue.projPoly(vv,label)
			     val node = createItemNode(in_vv,item,p,i+1,d,canvas)
			 in Array.update(getKids(p),i+1,node)
			 end),
		     length-1,
		     ilist) 
	 
    (* construction of different items *)

    and createItemNode (vv,item,p,i,d,canvas) = 
	case Inf.inspectItem item of
	Inf.FixItem(_,_) 
	=> let val fix = #2(Inf.asFixItem(item))
	       val str = case fix of
		         Fixity.NONFIX => "  nonfix" 
	               | Fixity.PREFIX(i) => "  prefix "^Int.toString(i)
		       | Fixity.POSTFIX(i) => "  postfix "^Int.toString(i)
		       | Fixity.INFIX(i,Fixity.LEFT) 
			 => "  infix "^Int.toString(i) 
		       | Fixity.INFIX(i,Fixity.RIGHT) 
			 => "  infixr "^Int.toString(i) 
		       | Fixity.INFIX(i,Fixity.NEITHER) 
			 => "  infixn "^Int.toString(i)
	   in createSimple (INTERPUNCT,p,i,d,str,DEFAULT,canvas) 
	   end 
      | Inf.ValItem(l,t) 
	=> let val conc = createConcat (INTERPUNCT,p,i,d,Array.array(4,Empty),
					canvas)
	       val s_val = createSimple (INTERPUNCT,conc,0,d,"  val ",DEFAULT,
					 canvas)
	       val lab = createSimple (INTERPUNCT,conc,1,d,
				       Label.toString(l),LABEL_COLOR,
				       canvas)
	       val equ = createSimple (INTERPUNCT,conc,2,d," = ",SEP_COLOR,
				       canvas)
	       val value =  createTree (NONE,vv,t,conc,3,d+1,canvas)  
	   in ( Array.update(getKids(conc),0,s_val)
	       ; Array.update(getKids(conc),1,lab)
	       ; Array.update(getKids(conc),2,equ)
	       ; Array.update(getKids(conc),3,value)
	       ; Array.update(getKids(p),i,conc)
	       ; conc )
	   end
      | Inf.TypItem(path,_)
	=> let val label = Path.toLab(path)
	       val str = "  type "^Label.toString(label)
	   in createSimple (INTERPUNCT,p,i,d,str,DEFAULT,canvas)
	   end 
      | Inf.ModItem(path,inf)
	=> let val conc = createConcat (INTERPUNCT,p,i,d,
					Array.array(4,Empty),canvas)
	       val s_struct = createSimple (INTERPUNCT,conc,1,d,
					    "  structure ",DEFAULT,canvas)
	       val name = createSimple (INTERPUNCT,conc,1,d,
					Label.toString(Path.toLab(path)),
					LABEL_COLOR,canvas)
	       val equ = createSimple (INTERPUNCT,conc,2,d," = ",SEP_COLOR,
				       canvas)
	       val vv_inf = UnsafeValue.cast vv : Reflect.module
	       val value =  createTreeInf (vv_inf,inf,conc,3,d+1,canvas) 
	   in ( Array.update(getKids(conc),0,s_struct)
	       ; Array.update(getKids(conc),1,name)
	       ; Array.update(getKids(conc),2,equ)
	       ; Array.update(getKids(conc),3,value)
	       ; Array.update(getKids(p),i,conc)
	       ; conc )
	   end
      | Inf.InfItem(path,_)
	=> let val conc = createConcat (INTERPUNCT,p,i,d,
					Array.array(2,Empty),canvas)
	       val s_sig = createSimple (INTERPUNCT,conc,0,d,
					 "  signature ",DEFAULT,canvas)
	       val name = createSimple (INTERPUNCT,conc,1,d,
					Label.toString(Path.toLab(path)),
					LABEL_COLOR,canvas)
	   in ( Array.update(getKids(conc),0,s_sig)
	       ; Array.update(getKids(conc),1,name)
	       ; Array.update(getKids(p),i,conc)
	       ; conc)
	   end
      | Inf.HiddenItem(item') 
	=> let val conc = createConcat (INTERPUNCT,p,i,d,
					Array.array(2,Empty),canvas)
	       val ask = createSimple (INTERPUNCT,conc,0,d,"  ? ",
				       DEFAULT,canvas) 
	       val h_item = createItemNode (vv,item',conc,1,d,canvas)
	   in ( Array.update(getKids(conc),0,ask)
	       ; Array.update(getKids(conc),1,h_item)
	       ; Array.update(getKids(p),i,conc)
	       ; conc)
	   end
       
end 
 
end 
 
