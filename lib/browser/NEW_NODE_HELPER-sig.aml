(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Inf from "x-alice:/lib/rtt/Inf"
import structure Label from "x-alice:/lib/rtt/Label"
import structure Type from "x-alice:/lib/rtt/Type"
import structure Path from "x-alice:/lib/rtt/Path"
import structure Reflect from "x-alice:/lib/system/Reflect"
import structure Gtk from "x-alice:/lib/gtk/Gtk"

import structure Node from "Node"
import structure GtkSupport from "GtkSupport"

local 
    open Node
in

signature NEW_NODE_HELPER =
sig

    datatype 'a list_desc = Det of 'a list * bool (* ohne Future *)
                          | Indet of 'a list * 'a list (* mit Future *)
    
   (* Hilfsfunktionen zur Bestimmung und Zerlegung von "Apply"-Typen *)

    val isApply: Type.desc -> bool	
    val unApply: Type.desc -> Type.desc * Type.t list 

    val isAtomType: Type.t -> bool

    val itemToLabel: Inf.item -> Label.lab

  (* Behandlung von Listen *)
	
    val compList : Type.t

    val inspectList : int * 'a list  -> 'a list_desc 
    val castList : 'a -> 'b list

   (* Operationen auf Rows *)
    val row2list : Type.row -> (Label.lab * Type.typ) list
    val labelvector : (Label.lab * Type.typ) list -> Label.lab Vector.vector

    (* Operationen auf Arrays *)
    val copyArray: 'a Array.array * 'a Array.array  -> unit

    (* Hilfsfunktion fuer Strings *)
(*
    val iterTake : string -> string   
*)

    val appi_break: (int * 'a -> 'b) * int * 'a list -> unit 	

end

end
