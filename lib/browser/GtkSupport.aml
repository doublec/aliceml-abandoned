(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure TextIO from "x-alice:/lib/system/TextIO"
import structure UnsafeValue from "x-alice:/lib/system/UnsafeValue"
import structure Gtk from "x-alice:/lib/gtk/Gtk"
import structure Gdk from "x-alice:/lib/gtk/Gdk"
import structure GtkCanvas from "x-alice:/lib/gtk/GtkCanvas"
import structure Inspector from "x-alice:/lib/tools/Inspector"

import signature GTK_SUPPORT from "GTK_SUPPORT-sig"
 
structure GtkSupport :> GTK_SUPPORT  =
    struct
	
	type tag = Gtk.object
	type color = Gtk.object

	(************ Primitive Gtk Instructions **************)
	(************ Einfache Gtk Instructionen **************)

	fun toplevelWindowNew() = Gtk.windowNew Gtk.WINDOW_TOPLEVEL
	val windowSetTitle = Gtk.windowSetTitle
	val windowSetPolicy = Gtk.windowSetPolicy
	val windowSetDefaultSize = Gtk.windowSetDefaultSize
	val widgetSetUsize =  Gtk.widgetSetUsize
	val widgetSetSensitive = Gtk.widgetSetSensitive
	val widgetShowAll = Gtk.widgetShowAll 
	val widgetHideAll = Gtk.widgetHideAll
	val widgetDestroy = Gtk.widgetDestroy
	val objectDestroy = Gtk.objectDestroy
	val containerAdd = Gtk.containerAdd
	val signalConnect = Gtk.signalConnect
	val labelNew = Gtk.labelNew
	val radioButtonNewWithLabel = Gtk.radioButtonNewWithLabel
	val radioButtonGroup = Gtk.radioButtonGroup
	val toggleButtonSetActive = Gtk.toggleButtonSetActive
	val toggleButtonGetActive = Gtk.toggleButtonGetActive
	val spinButtonGetValueAsInt = Gtk.spinButtonGetValueAsInt
	val adjustmentNew = Gtk.adjustmentNew
	val widgetSetScrollAdjustments = Gtk.widgetSetScrollAdjustments
	val adjustmentGetFieldPageSize = Gtk.adjustmentGetFieldPageSize
	val adjustmentGetFieldUpper = Gtk.adjustmentGetFieldUpper
	val adjustmentGetFieldValue = Gtk.adjustmentGetFieldValue
	val layoutFreeze = Gtk.layoutFreeze
	val layoutThaw = Gtk.layoutThaw
	val menuBarAppend = Gtk.menuBarAppend
	val menuItemNewWithLabel = Gtk.menuItemNewWithLabel
	val menuItemRightJustify = Gtk.menuItemRightJustify
	    
	(************ GtkCanvas Primitives ********************)
	(************ GtkCanvas Instruktionen *****************)
	    
	fun canvasNew() = GtkCanvas.new 0
	val canvasRoot = GtkCanvas.root 
	val canvasItemNew = GtkCanvas.itemNew
	val canvasItemSet = GtkCanvas.itemSet
	val canvasItemLowerToBottom = GtkCanvas.itemLowerToBottom
	val canvasSetScrollRegion = GtkCanvas.setScrollRegion
	val canvasRECTANGLE = GtkCanvas.RECTANGLE
	val canvasItemMove = GtkCanvas.itemMove
	    
	(************ Gdk Primitives **************************)
	(************ Gdk Befehle    **************************)
	    
	val fontLoad = Gdk.fontLoad
	val fontGetFieldAscent = Gdk.fontGetFieldAscent
	val fontGetFieldDescent = Gdk.fontGetFieldDescent
	val stringWidth = Gdk.stringWidth
	    
	type event = Gdk.event
	    
	(************ Window creation helpers ******************)
	(************ Hilfsprozeduren zur 
	              Menu- und Fenstererzeugung ***************)
	    
	val uglyNULL = UnsafeValue.cast () : Gtk.object
	    
	(* ABSTRACTIONS FOR MENU CREATION *)

	(* SEP represents separation lines on the menu window *)
	datatype MenuLabel = SEP | LABEL of string

	(* Handler carries signal and appropriate handler function *)
	datatype Handler = Handler of string * (Gtk.arg list -> unit)
	    
	(* represents a hierarchy of menu items *)
	datatype MenuConstructObj = 
	    BarObj of MenuConstructObj list
	  | PopupObj of MenuConstructObj list
	  | MenuObj of {title: string, 
			items: MenuConstructObj list, 
			sensitive: bool} 
	  | EntryObj of MenuLabel * Handler list * bool  

	(* Represents one radio button and associated handlers *)
	datatype RadioButtonObj = RBObj of string * Handler list

	(* Represents one button and associated handlers *)
	datatype ButtonObj = BObj of string * Handler list
	    
	(* createMenu *)
	fun createMenu (BarObj(l)) =
	    let
		val bar = Gtk.menuBarNew()
		val create = (fn i => 
			      Gtk.menuBarAppend(bar,createMenu(i)))  
	    in 
		(  (List.app create l) 
		 ;   bar) 
	    end  
	  | createMenu (PopupObj(l)) =  
	    let
		val menu = Gtk.menuNew()
		val create = (fn i => 
			      Gtk.menuAppend (menu,createMenu i))
	    in
		(List.app create l
		 ;Gtk.menuPopup(menu,
				uglyNULL,
				uglyNULL,
				uglyNULL,
				uglyNULL,
				3,0)
		 ;Gtk.widgetShowAll (menu)
		 ; menu)
	    end 
	  | createMenu (MenuObj(r)) = 
	    let
		val menu_item = Gtk.menuItemNewWithLabel( #title(r))
		val menu = Gtk.menuNew()
		val _ = Gtk.menuItemSetSubmenu(menu_item,menu)
		val create = fn i => 
		    Gtk.menuAppend(menu,createMenu i)
	    in
		(List.app create (#items(r))
		 ; widgetSetSensitive(menu_item,#sensitive(r)) 
		 ; menu_item)
	    end
	  | createMenu (EntryObj(label,handlerlist,sensitive)) =
	    let
		val item = case label of
		    SEP => Gtk.menuItemNew()
		  | LABEL(label) => Gtk.menuItemNewWithLabel(label)
		val connect = fn Handler(str,handler) 
		    => (Gtk.signalConnect (item,str, handler);())
	    in
		(List.app connect handlerlist
		 ; widgetSetSensitive(item,sensitive)
		 ; item)
	    end

	(* createCombo *)       
	fun createCombo strlist = 
	    let
		val combo = Gtk.comboNew()
	    in 
		(Gtk.comboSetPopdownStrings(combo,
					    UnsafeValue.cast(strlist) )
		;combo)
	    end

	(* createNotebookPages - 
	 takes notebook and string * Gtk object pair  
        and inserts page in Notebook *)		
	fun createNotebookPages n (title,page) = 
	    let
		val t = Gtk.labelNew title
	    in
		Gtk.notebookAppendPage(n, page, t)
	    end

	(* createNotebook - takes string * Gtk.object list 
        and creates notebook with strings as labels *)
	fun createNotebook l = 
	    let 
		val n =  Gtk.notebookNew ()
	    in
		(Gtk.notebookSetShowTabs(n, true (* 1 *) (* showlabel *))
		 ;Gtk.notebookSetTabPos(n,Gtk.POS_TOP)
		 ;List.app (createNotebookPages n) l
		 ;n)
	    end

	(* creates one button item and connects with handlers, 
	 needs predecessor *)
	fun createRadioItem (RBObj(stri,handlerlist),pred) = 
	    let
		val group = if pred =  
	            uglyNULL then  uglyNULL
			    else Gtk.radioButtonGroup(pred)
		val button = Gtk.radioButtonNewWithLabel(group, stri)
		val connect = fn Handler(str,handler) 
		    => (Gtk.signalConnect (button,str, handler);())
	    in
		(List.app connect handlerlist; button)
	    end

	(* creates Radio Buttons from list of RBObj's *)
	fun createRadioButtons li = 
	    let
		val box =  Gtk.vboxNew(false ,4)
		val create = 
		    fn (x,e) => 
		    let
			val button = createRadioItem(x,e)
		    in
			(Gtk.boxPackStart(box,button,
						  false,
						  true,0)
			;button)
		    end
	    in
		(List.foldl create uglyNULL li; box)
	    end

	(* auxiliary function *)
	fun connect item = (fn Handler(str,handler) 
			    => (Gtk.signalConnect (item,str, handler);()))
		
	(* createButton *)
	fun createButton (BObj(title,handlerlist)) = 
	    let
		val button =  Gtk.buttonNewWithLabel(title)
		val con = connect button
	    in
		(List.app con handlerlist
		 ; button)
	    end
		       
	(* createButtonBox *)
	fun createButtonBox {buttons = l, borderwidth = b} =  
	    let
		val bbox = Gtk.hbuttonBoxNew()
	    in
		(Gtk.containerSetBorderWidth(bbox,b)
		 ;Gtk.buttonBoxSetLayout(bbox,
					 Gtk.BUTTONBOX_SPREAD)
		 ; List.app (fn b => Gtk.containerAdd(bbox,
					   (createButton b))) l
		 ; bbox)
	    end

	(* createTable *)
	fun createTable {rows = r, cols = c, entries = l}   = 
	    let 
		val table = Gtk.tableNew(r,c,true)
		val attach = (fn (obj,x1,x2,y1,y2) 
			      => Gtk.tableAttachDefaults(table,
					       obj,x1,x2,y1,y2))
	    in
		(List.app attach l
		 ; table )
	    end

	(* createSpinButton *)
	fun createSpinButton {init = i, 
			      lower = l, 
			      upper = u, 
			      inc = ic, 
			      dec = d}
	    = let
		  val a = Gtk.adjustmentNew(Real.fromInt(i), 
					    Real.fromInt(l),
					    Real.fromInt(u), 
					    Real.fromInt(ic), 
					    0.0, 
					    0.0)
	      in
		  Gtk.spinButtonNew(a,Real.fromInt(ic),d)
	      end

	(* vertical GTk box creation *)
	fun createVBoxDefaults l = 
	    let
		val vbox = Gtk.vboxNew(false,4)
		val p = fn i =>  Gtk.boxPackStart(vbox,i,
						  false ,
						  true ,0)
	    in
		(List.app p l
		 ; vbox)
	    end

	fun createVBox l = 
	    let
		val vbox = Gtk.vboxNew(false,4)
		val p = fn (a,i,j,k) =>  Gtk.boxPackStart(vbox,a,i,j,k)
	    in
		(List.app p l
		 ; vbox)
	    end

	(* Gtk frame creation *)
	fun createFrame (title,obj) = 
	    let 
		val frame = Gtk.frameNew(title)
	    in
		(Gtk.containerAdd(frame,obj)
		 ; frame)
	    end

	(* scroll window creation *)
	fun  createScrollWindowDefaults(inc1,inc2,max_x, max_y) =  
	    let
		val adj1 = Gtk.adjustmentNew(0.0,0.0,max_x ,
					     inc1,inc2,max_x )
		val adj2 = Gtk.adjustmentNew(0.0,0.0,max_y ,
					     inc1,inc2,max_y ) 
		val scrolled = Gtk.scrolledWindowNew(adj1,adj2)
		val hadj = Gtk.scrolledWindowGetHadjustment(scrolled)
		val vadj = Gtk.scrolledWindowGetVadjustment(scrolled)
	    in
		(Gtk.scrolledWindowSetPolicy(scrolled,
					     Gtk.POLICY_ALWAYS,
					     Gtk.POLICY_ALWAYS)
		 ; (scrolled,hadj,vadj))
	    end

	(* status bar creation, yields associated posting functions *)
	fun createStatusbar()  = 
	    let 
		val status = Gtk.statusbarNew()
		val type_context = 
		    Gtk.statusbarGetContextId(status,"type")
		val postMessageType = fn str =>
		    (Gtk.statusbarPop(status,
				      type_context)
		     ;Gtk.statusbarPush(status,type_context,
					str))
		val mode_context = 
		    Gtk.statusbarGetContextId(status,"mode")
		val postMessageMode = fn str =>
		    (Gtk.statusbarPop(status,
				      mode_context)
		     ;Gtk.statusbarPush(status,mode_context,
					str)) 
	    in
		(Gtk.boxSetHomogeneous(status,false)
		 ;(status,postMessageType,postMessageMode))
	    end

	(* Stop Button *)
	val stopButton = let 
			     val button = menuItemNewWithLabel("stop")
			 in 
			     (widgetSetSensitive(button,false);button)
			 end
		     
	fun stopButtonSetActive b = widgetSetSensitive(stopButton,b)

	    (* Text Window *)

	fun createTextWindow() = 
	    let
		val textwindow = ref uglyNULL
		val alive = ref false
		val text = 
		    Gtk.textNew(uglyNULL,uglyNULL)
		val scrolled = Gtk.scrolledWindowNew(uglyNULL,uglyNULL)
		fun send str = 
		    (if not(!alive) 
			 then 
			     (textwindow := toplevelWindowNew()  
			      ; containerAdd(!textwindow,scrolled)
			      ;Gtk.widgetSetUsize(!textwindow,300,200)
			      ;Gtk.windowSetTitle(!textwindow,
			   "Alice Browser - Type Information")
			      ;widgetShowAll(!textwindow)
			      ; signalConnect (!textwindow, 
					       "delete-event", 
					       fn _ => 
				    (Gtk.containerRemove(!textwindow,
							 scrolled)
				     ; alive := false
				     ; widgetDestroy(!textwindow)))
			      ; alive := true;0)
		     else 
			 Gtk.textBackwardDelete(text,
				                Gtk.textGetLength(text))
		     ;Gtk.textInsert(text,
				     uglyNULL,
				     uglyNULL,
				     uglyNULL,
				     str,
				     ~1))
	    in
		( containerAdd(scrolled,text)
		 ; Gtk.scrolledWindowSetPolicy(scrolled,
					       Gtk.POLICY_AUTOMATIC,
					       Gtk.POLICY_AUTOMATIC)
		; send)
	    end

(******************** Complex Handler Functions **************************)

	(* "About..."-WindowHandler *)
	val aboutWindow =  (fn () =>  
	  let
	      val dialog = Gtk.dialogNew()
	      val ddialog = (fn _ =>  Gtk.widgetDestroy(dialog)) 
	      val ok = createButton(BObj("ok",[Handler("clicked",ddialog)]))
	      val l =  Gtk.labelNew("Alice Browser \n"
				    ^ "Created by \n"
				    ^ "Bernadette Blum & Marvin Schiller")
	  in
		  ( Gtk.windowSetTitle(dialog,"information")
		   ; Gtk.containerAdd((Gtk.dialogGetFieldActionArea(dialog)),
				      ok)
		   ; Gtk.containerAdd((Gtk.dialogGetFieldVbox(dialog)),l)
		   ;Gtk.widgetShowAll(dialog))
	  end)  

	(* Scrolling *)
	    
	fun scroll (d,scrolled,adj,max) = 
	    let
		val pages =  Gtk.adjustmentGetFieldPageSize(adj)
		val value = Gtk.adjustmentGetFieldValue(adj)
	    in
		( if Real.>(Real.+(Real.+(value,d),pages),max) 
		      then  Gtk.adjustmentSetValue(adj,Real.-(max,pages))
		  else  Gtk.adjustmentSetValue(adj,Real.+(value,d))
		      ;())
	    end  

	(* handles scrolling via key press *)
	fun handleGdkKeyPress ([Gdk.EVENT(event)],
			       scrolled,hadj,vadj,max_x,max_y) = 
	    case event of 
		Gdk.GDK_KEY_PRESS({keyval = 65361,...}) => 
		    scroll(~10.0,scrolled,hadj,max_x) 
	      | Gdk.GDK_KEY_PRESS({keyval = 65363,...}) => 
		    scroll(10.0,scrolled,hadj,max_x) 
	      | Gdk.GDK_KEY_PRESS({keyval = 65362,...}) => 
		    scroll(~10.0,scrolled,vadj,max_y)    
	      | Gdk.GDK_KEY_PRESS({keyval = 65364,...}) => 
		    scroll(10.0,scrolled,vadj,max_y)
	      | _ => ()

	(* Yields coordinates relative to the whole canvas *)
	fun calcAbsoluteMousePointerPosition(x,y,hadj,vadj) = 
	    let
		val valueh = adjustmentGetFieldValue(hadj)
		val valuev = adjustmentGetFieldValue(vadj) 
		val x = Real.+ (x,valueh)
		val y = Real.+ (y,valuev)
	    in
		(x,y)
	    end

	(* auxilliary for event handling *)
	fun getMouseClickEventInfo ([Gdk.EVENT(event)],hadj,vadj) = 
	    case event of
		Gdk.GDK_BUTTON_PRESS({button = b, ...} as r) => 
		    SOME(calcAbsoluteMousePointerPosition(#x(r),#y(r),
							  hadj,vadj),b)
	      | _ => NONE
	     
	(* auxiliary for setSelectionMenuSensitive *)
	fun getSelectionMenu bar = 
	    let
		val menu_heading_items = UnsafeValue.cast 
		    (Gtk.containerChildren(bar)) : Gtk.object list
		val menu_heading_selection = List.nth(menu_heading_items,1)
		val submenu = 
		    Gtk.menuItemGetFieldSubmenu(menu_heading_selection)
	    in
		(menu_heading_selection,submenu)
	    end

	(* Switches "selection" menu on/off *)
	fun setSelectionMenuSensitive (bar,sensitive) = 
	    let
		val (menu_heading_selection,submenu) = getSelectionMenu bar
		val selection_menu = hd
		    (UnsafeValue.cast 
		     (Gtk.containerChildren(menu_heading_selection)) 
		     : Gtk.object list)    
	    in
		(widgetSetSensitive(selection_menu,sensitive)
		 ;widgetSetSensitive(submenu,sensitive))
	    end

	(* switches the field of the Selection menu on/off *)
	fun setFieldSensitive (bar,sensitive,i)= 
	    let
		val (menu_heading_selection,submenu) = 
		    getSelectionMenu bar
		val children = UnsafeValue.cast 
		    (Gtk.containerChildren(submenu)) : Gtk.object list
		val field = List.nth(children,i)
	    in
		widgetSetSensitive(field,sensitive)
	    end

	(* switches the expand option on/off *)
	fun setExpandSensitive(bar,sensitive) = 
	    setFieldSensitive (bar,sensitive,0)

	(* switches the shrink option on/off *)
	fun setShrinkSensitive(bar,sensitive) = 
	    setFieldSensitive (bar,sensitive,1)   
     
	(******************** Canvas Items ***************************)

	exception MissingColor
	
	(* Gtk color System *)
	val map  = Gdk.colormapGetSystem ()
	    
	(* registers a color (specified by rgb parameters) 
                                    with the Gtk system *)
	fun allocColor (r,g,b) = 
	    let val c =  Gdk.allocColor (r,g,b)
		val _ = Gdk.colormapAllocColor (map, c, 
						false, 
						true)
	    in
		c
	    end
    
	(* creates the white rectangle as canvas background *)
	fun createCanvasBackground(canvas,xsize,ysize) = 
	    canvasItemNew 
	    ( canvasRoot(canvas), 
	     GtkCanvas.RECTANGLE,
	     [("x1", Gtk.DOUBLE 0.0),
	      ("y1", Gtk.DOUBLE 0.0),
	      ("x2", Gtk.DOUBLE xsize),
	      ("y2", Gtk.DOUBLE ysize),
	      ("fill_color_gdk", 
	       Gtk.OBJECT(allocColor(65535,65535,65535))),
	      ("outline_color_gdk", 
	       Gtk.OBJECT (allocColor(0,0,0)))]) 

	(* function that sets the canvas size and associated scroll values *)
	fun resizeCanvas (x,y,scrolled,canvas,background,valueh,valuev, 
			  max_x, max_y) =  
	    let 
		val adj1 = Gtk.adjustmentNew(valueh,0.0,max_x ,
					     20.0,50.0,max_x )
		val adj2 = Gtk.adjustmentNew(valuev,0.0,max_y ,
					     20.0,50.0,max_y )
	    in
		( widgetSetScrollAdjustments(scrolled,adj1,adj2) 
		 ;canvasSetScrollRegion(canvas,0.0,0.0,x,y)
		 ;canvasItemSet(background,"x2", Gtk.DOUBLE x)
		 ;canvasItemSet(background,"y2", Gtk.DOUBLE y))
	    end

	(* creates a Gtk group *)
	fun newTag(parent,x,y) = 
	    canvasItemNew(parent, 
			  GtkCanvas.GROUP,
			  [("x", Gtk.DOUBLE y), 
			   ("y", Gtk.DOUBLE y)])		
	    
	(* prints text in the top left corner of a group *)
	fun print00 (str,group,color,fontname) = 
	    canvasItemNew(group, 
			  GtkCanvas.TEXT, 
			  [("text", Gtk.STRING str),
			   ("font", Gtk.STRING fontname),
			   ("fill_color_gdk", 
			    Gtk.OBJECT(color) ),
			   ("anchor", Gtk.INT(2))]) 

	(* puts a group at a specified position *)
	fun positionGroup (group,x,y) = 
	    if x=0.0 andalso y=0.0 then ()
	    else 
		(GtkCanvas.itemSet(group,"x", Gtk.DOUBLE x) 
		 ;GtkCanvas.itemSet(group,"y", Gtk.DOUBLE y))
			
        (* moves a Gtk group 
		 (arguments represent distance in characters) *)
	fun moveGroup (group,x,y,font_height,font_width) = 
	    if x=0 andalso y=0 then ()
	    else
		let
		    val rx = Real.fromInt(x * font_width)
		    val ry = Real.fromInt(y * font_height)
		    val _ = () 
		in
		    GtkCanvas.itemMove(group,rx,ry)
		end
	  
	(* queries the boundaries (in character positions) of the object *) 
	fun getCoordinates (group,font_height,font_width) = 
	    let
		val (rx1,ry1,rx2,ry2) = 
		    GtkCanvas.itemGetBounds(group, 0.0 , 0.0 , 0.0 , 0.0)
		val x1 = (Real.trunc rx1) div font_width
		val y1 = (Real.trunc ry1) div font_height
		val x2 = (Real.trunc rx2) div font_width
		val y2 = (Real.trunc ry2) div font_height
	    in
		(x1,y1,x2,y2)
	    end
		
	(* same as above with only two return values *)
	fun getPosition (group,font_height, font_width) = 
	    let
		val (rx1,ry1,_,_) = 
		    GtkCanvas.itemGetBounds(group, 0.0 , 0.0 , 0.0 , 0.0)
		val x1 = (Real.trunc rx1) div font_width
		val y1 = (Real.trunc ry1) div font_height
	    in
		(x1,y1)
	    end

	(* moves a Gtk item (absolute parameters) *)
	fun itemMoveTo (group,rx,ry) = 
	    let
		val (rx1,ry1,_,_) = 
		    GtkCanvas.itemGetBounds(group, 0.0 , 0.0 , 
					    1000.0 , 1000.0)
		val (absx,absy) = GtkCanvas.itemI2w(group,rx1,ry1)
		val dx = Real.- (rx, absx)
		val dy = Real.- (ry, absy)
	    in
		if absx = rx andalso absy = ry
		    then ()
		else (GtkCanvas.itemMove(group,dx,dy))
	    end

	(* creates horizontal Line on canvas *)
	fun createSepLine (group,actline,x,font_height)= 
	    if actline > 0 
		then
		    let
			val mx = Real.trunc(x)
			val linepos = actline * font_height
			    - (font_height div 2)
		    in
			GtkCanvas.itemNew
			(group,   		 
			 GtkCanvas.LINE, 
			 [("points", 
			   Gdk.POINTS ([0, linepos, mx, linepos])),
			  ("fill_color_gdk", 
			   Gdk.OBJECT(allocColor(40000,40000,50000)) ),
			  ("line_style",Gdk.INT(Gdk.LINE_ON_OFF_DASH)),
			  ("width_pixels", Gdk.INT 1)])  
		    end
	    else uglyNULL 

	(* adjusts length of a separation line *)
	fun resizeSepLine(line,x) = 
	    let 
		val (rx1,ry1,rx2,ry2) = 
		    GtkCanvas.itemGetBounds(line, 0.0,
					    0.0,
					    0.0,
					    0.0)
		val y1 = Real.trunc(Real.+(ry1,1.0))
	    in
		(GtkCanvas.itemSet(line,
				   "points", 
				   Gdk.POINTS ([0, y1, x, y1])))
	    end
	
	(* moves separation line below the group it belongs to *)
	fun yPosSepLine (item,group,font_height) = 
	    let
		val (_,ry1,_,_) = 
		    GtkCanvas.itemGetBounds(group, 0.0,
					    0.0,
					    0.0,
					    0.0)
		val y = Real.trunc(ry1) - (font_height div 2)
		val (_,_,lx2,_) = 
		    GtkCanvas.itemGetBounds(item, 0.0,
					    0.0,
					    0.0,
					    0.0)
	    in
		GtkCanvas.itemSet(item,
				  "points", 
				  Gdk.POINTS ([0, y, 
					       Real.trunc(lx2), 
					       y]))   
	    end 
	
	(* auxiliary for arrow creation *)
	fun translate (nil,h,v,h_off,v_off) = nil
	  | translate (x1::x2::xr,h,v,h_off,v_off) = 
	    ((x1 * h) div 8 + h_off)::
	    ((x2 * v) div 8 + v_off)::translate(xr,h,v,h_off,v_off)
	  | translate _ = raise Match
     
	(* creates arrow from pointset *)
	fun createArrow(group,points,color) = 
	    GtkCanvas.itemNew(group,
			      GtkCanvas.POLYGON,
			      [("points", 
				Gdk.POINTS points),
			       ("fill_color_gdk",
				Gtk.OBJECT(color)),
			       ("outline_color_gdk",
				Gdk.OBJECT(allocColor(0,0,0))),
			       ("width_pixels", Gdk.INT 1)])

	(* creates arrow pointing rightwards *)
	fun createArrowRight(group,color,font_height,font_width) = 
	    let
		val w = (font_width * 3) div 2
		val h = font_height  
		val points = [4,0, 4,2, 0,2, 0,6, 4,6, 4,8, 8,4]
		val points' = translate(points,w,h,0,0)
		val group' = newTag(group,0.5,0.5)
	    in
		createArrow(group',points',color)
	    end

	(* analogeous to above *)
	fun createArrowDown(group,color,font_height,font_width) = 
	    let
		val w = (font_width * 3) div 2
		val h = font_height 
		val points = [2,0, 2,4, 0,4, 4,8, 8,4, 6,4, 6,0]
		val points' = translate(points,w,h,0,0)
		val group' = newTag(group,0.5,0.5)
	    in
		createArrow(group',points',color)
	    end

	(* creates simple orange coloured rectangle *)
	fun createRectangle (group,x1,y1,x2,y2) = 
	    GtkCanvas.itemNew 
	    ( group, 
	     GtkCanvas.RECTANGLE,
	     [("x1", Gtk.DOUBLE x1),
	      ("y1", Gtk.DOUBLE y1),
	      ("x2", Gtk.DOUBLE x2),
	      ("y2", Gtk.DOUBLE y2),
	      ("fill_color_gdk", 
	       Gtk.OBJECT(allocColor(65000,50000,50000))),
	      ("outline_color_gdk", 
	       Gtk.OBJECT (allocColor(65000,50000,50000)))]) 

end

 
