(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Node from "Node"
import structure GtkSupport from "GtkSupport"
import structure Color from "Color"
import structure Layout from "Layout"
import structure Settings from "Settings"

import signature DRAW from "DRAW-sig"

local open Node Layout 

in

structure Draw :> DRAW =
struct

    exception MissingColor
    exception DrawError
    exception NodeFound of int * int * node 
    	   
    (* GtkSupport Functionality *)
    
    fun groupToPosition (node,x,y) = 
	GtkSupport.moveGroup(getGroup(node),x,y,
			     Settings.getFontHeight(),
			     Settings.getFontWidth())

    fun getCoordinates group =  
	GtkSupport.getCoordinates (group,
				   Settings.getFontHeight(),
				   Settings.getFontWidth()) 

    fun moveGroup(group,dx,dy) = 
	GtkSupport.moveGroup(group,dx,dy,
			     Settings.getFontHeight(),
			     Settings.getFontWidth()) 

    fun createArrowDown (group,color) =  
	GtkSupport.createArrowDown(group,color,
				   Settings.getFontHeight(),
				   Settings.getFontWidth()) 

    fun createArrowRight (group,color) =  
	GtkSupport.createArrowRight(group,color,
				    Settings.getFontHeight(),
				    Settings.getFontWidth()) 
							    
		
    (* moves node to a specified position (in character units) *)
    fun move(n,x,y) = let
			   val group = getGroup(n)
			   val (old_x,
				old_y,
				old_x2,
				old_y2) = getCoordinates (group) 
			   val needs_printing =  old_x = 0 
			                         andalso old_y = 0
			                         andalso old_x2 = 0
			                         andalso old_y2 = 0
			   val dx = x-old_x
			   val dy = y-old_y
		       in
			   (moveGroup(group,dx,dy)
			    ; needs_printing)
		       end

    (* moves and returns right bottom corner coordinates *)
    fun moveVerbose(n,x,y) = (move(n,x,y)
		       ;(x+ Node.get_l_xdim(n),
			 y+get_ydim(n)-1)) (* maybe get_l_xdim 
					    is 
					    not sufficient ! *)

    (* Draws Atomic Nodes - Simple and RelRefNodes *)
    fun atomDraw (node,x,y,upd) = 
	(if upd 
	     then if move (node,x,y)
		      then (GtkSupport.print00(getRep(node),
					     getGroup(node),
					     Color.lookupColor(getColor(node)),
					     !Settings.fontname);())
		  else ()
	 else (groupToPosition(node,x,y)
	       ;GtkSupport.print00 (getRep(node),
				  getGroup(node),
				  Color.lookupColor(getColor(node)),
				  !Settings.fontname)
		       ; ())
	     ;getStatus(node) := CLEAN
	     ;(x+String.size(getRep(node)),y))
   
    (* Draws Limit Nodes *)
    fun drawLimit (node,x,y,upd) = 
	let 
	    val createArrow = if getSort(node) = DEPTH_LIMIT
				  then createArrowDown
			      else createArrowRight
	in
	    (if upd 
		 then if move(node,x,y)
			  then (createArrow(getGroup(node),
					    Color.lookupColor(LIMIT_COLOR));())
		      else ()
	     else (groupToPosition(node,x,y)
		   ;createArrow(getGroup(node),
		         	Color.lookupColor(LIMIT_COLOR));())
		   ;getStatus(node) := CLEAN 
		   ;(x+2,y))
	end
    
    (* Auxiliary for drawConcat *)
    fun concatHorFunct upd  =  (fn (a,(x,y))  => draw(a,x,y,upd)) 

    (* DrawsConcats *) 
    and drawConcat (n,x,y,upd) = 
	let 
	    val (new_x,new_y) = (if upd 
				     then (move(n,x,y);()) 
				 else groupToPosition(n,x,y)
				     ; (Array.foldl (concatHorFunct upd) 
					(0,0) 
					(getKids(n)))) 
	in 
	    (getStatus(n) := CLEAN
	     ;(new_x+x,new_y+y))
	end

    (* Auxiliaries for drawConcat *)
    and containerHorFunct upd =  
	(fn (a,(x,y,_))  => let
				val (new_x,new_y) 
				    = draw(a,x,y,upd)
			    in (new_x,new_y,0)
			    end)
	
    and containerVerFunct upd = 
	(fn (a,(x,y,_)) 
	 => let
		val (x1,y1) = 
		    draw(a,x,y,upd)
	    in
		(x,y1+1,x1)
	    end)
	   
    (* Draws Container Nodes *)
    and drawContainer(n,x,y,upd) =  
	let 
	    val vertical = setsVertical(n)
	    val funct = if vertical 
			    then (containerVerFunct upd)
			else (containerHorFunct upd)
	    val (new_x',new_y',new_x2) = 
		(if upd 
		     then (move(n,x,y);()) 
		 else groupToPosition(n,x,y)
		     ;(Array.foldl funct 
		       (0,0,0) 
		       (getKids(n)))) 
	    val (new_x,new_y) = if vertical 
				    then (new_x2,new_y' -1)
				else  (new_x',new_y') 
	in
	    (getStatus(n) := CLEAN
	     ;(new_x+x,new_y+y))
	end 
    
    (* Draws RelNodes *)
    and drawRelNode (n,x,y,upd) = case n of
	RelNode(r) 
	=> if !(#counter(r)) = 1 orelse isSimple(getContent(n))
	       then (if upd then (move(n,x,y);()) 
		     else groupToPosition(n,x,y) 
			 ;let
			      val (new_x,new_y) = 
				  draw (getContent(n),0,0,upd)
			  in
			      (x+new_x,y+new_y)
			  end)
	   else if upd then 
	       let
		   val content = 
		       (if move(n,x,y) 
			    then (GtkSupport.print00 (getRep(n),
					      getGroup(n),
				              Color.lookupColor(getColor(n)),
				    	      !Settings.fontname);()) 
			else ()
			    ;getContent(n))
		   val (x2,y2) = draw (content,
				       String.size(getRep(n))
				       ,0
				       ,upd)
	       in
		   (x+x2, y+y2)
	       end
		else (groupToPosition(n,x,y)
		      ; GtkSupport.print00 (getRep(n),
					    getGroup(n),
					    Color.lookupColor(getColor(n)),
					    !Settings.fontname)
		      ;let
			   val content = getContent(n)
			   val (x2,y2) = draw (content,
					       String.size(getRep(n))
					       ,0
					       ,upd)
		       in
			   (x+x2, y+y2)
		       end)
		    
      | _ => raise DrawError

   
    (* Draws Node Trees *)
    and draw (((Simple _ as n ) 
      | (RelRefNode _ as n)) ,x,y,upd) = 
	if !(getStatus(n)) = DIRTY  
	    then atomDraw (n,x,y,upd)
	else moveVerbose(n,x,y)  	
      | draw (Concat(_) as n,x,y,upd) 
	    = (if (!(getStatus(n))) = DIRTY  
		   then drawConcat (n,x,y,upd)
	       else moveVerbose(n,x,y))  
      | draw (Container(_) as n,x,y,upd) 
	    = if (!(getStatus(n))) = DIRTY  
		   then drawContainer (n,x,y,upd)
	       else moveVerbose(n,x,y)
      | draw (Limit(_) as n,x,y,upd) = 
		   if  (!(getStatus(n))) = DIRTY  
		       then drawLimit (n,x,y,upd)
		   else moveVerbose(n,x,y) 
      | draw (RelNode(r) as n,x,y,upd) = 
		       if  !(#status(r)) = DIRTY 
			   then drawRelNode (n,x,y,upd)
		       else ( moveVerbose(n,x,y) 
			     ;( case !(#counter(r)) of
			       1 => (x+get_xdim(getContent(n)),
				     y+get_ydim(getContent(n)))		 
			     | _ => (x+get_xdim(n),y+get_ydim(n)) ))
      | draw  (Empty,x,y,upd) =  (x,y)
			   
end (* structure *)
       
end (* local *)
