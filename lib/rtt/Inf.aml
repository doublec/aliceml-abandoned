(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001-2003
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(*******************************************************************************

On Paths and Instantiation / Alpha Renaming:

We use `paths' to name types, modules, and interfaces. A path is a unique name
with additional location information. Location information is not required for
type checking but is maintained solely for pretty printing purposes and to
simplify external binding analysis on interfaces (like performed by
BindEnvFromSig, for example).

We conceptually distinguish between _free_ and _instantiated_ signatures. A
free signature is one bound by an interface declaration, while instantiated ones
are those assigned to modules. This extends to higher-order interfaces.

To avoid capturing issues, all instantiations of the `same' signature need to
bind different paths. The instance function must be used in strategic places to
ensure this invariant.

There are three binders for module paths: signature items, functors, and
dependent interfaces. Type and interface paths are only bound by interface
items. The location information of a path p is as follows:

- For the parameter x in a functor or interface function, p = x
- For an item x in a _free_ signature, p = x
- For an item x in an instantiated signature, i.e. a signature that is the
  interface of a functor or interface parameter or an enclosing signature's
  module item, p = p'.x, where p' is the path of the corresponding binder.

As an example, consider the following interface with annotated path locations:

	sig{
	    type t[t]
	    module a[a] : sig{
		type u[a.u]
		module b[a.b] : sig{type v[a.b.v]}
		module c[a.c] : fun(d[d] : sig{type v[d.v]}) -> sig{type w[w]}
		interface j[a.j]
	    }
	    interface k[k] = sig{type t[t]}
	}

A pretty printer should suppress any path component that is the path of an
enclosing entity (e.g. the a. prefix inside the signature of a).

Instantiation does prefix all nested paths of a signature with the given path p.

On Abbreviations:

As for types, we try to maintain abbreviations to generate more user friendly
output. This is managed through a special node ABBREV, which refers to the
original type term as well as to the reduced/substituted one.

On Lookup:

To make lookups more efficient, signatures cache a lookup hash table. To reduce
size of signature representation among pickling, this can explicitly be flushed
using the compress function.

On Singletons:

Since we have no functor paths, we only have few axioms for canonicalising
singleton interfaces. But we have similar axioms for singleton kinds:

	SING_{SING_k j}(j')  = SING_k j
	SING_{DEP x:j.k}(j') = DEP x:j.SING_k(j' x)

On Identity and Narrowing:

To speed up matching of signatures with itself each signature carries a stamp.
If we encounter two equal stamps we can shortcut any matching. This is
partiularly important for linktime component type checking.

Since we perform signature narrowing in many places - in particular to minimise
component import signatures - a simple stamp would be too weak a mechanism. In
order to be able to recognise quickly if a signatures is an ancestor of another
one with respect to narrowing, every signature actually carries a list of all
its ancestors (including itself as the list's head). More precisely, this list
is the path in the ancestor tree of the signature. The ancestor relationship
can be test quickly by looking up the list head of one signature in the
ancestor list of the other. Usually hierarchies are flat, so linear search is
acceptable (TODO: verify this claim).

TODO:

- Make signature extension functional (requires functional lookup table?).

*******************************************************************************)

import structure Assert       from "../utility/Assert"
import structure Cell         from "../utility/Cell"
import functor   MkHashImpMap from "../data/MkHashImpMap"
import structure GlobalStamp  from "../data/GlobalStamp"
import structure Name         from "Name"
import structure Label        from "Label"
import structure Path         from "Path"
import structure PathSet      from "PathSet"
import structure PathMap      from "PathMap"
import structure Type         from "Type"
import structure Fixity       from "Fixity"
import signature INF          from "INF-sig"

(*DEBUG
import structure Addr         from "../utility/Addr"
import structure TextIO       from "../system/TextIO"
import structure PrettyPrint  from "../utility/PrettyPrint"
import structure PPPath       from "PPPath"
import structure PPType       from "PPType"
*)

structure Inf :> INF =
struct
  (* Types *)

    open Cell

    type lab	= Label.t
    type path	= Path.t
    type typ	= Type.t
    type tkind	= Type.kind
    type fix    = Fixity.t


    (* A map for signatures *)

    datatype space = FIX' | VAL' | TYP' | MOD' | INF'

    structure Tab = MkHashImpMap(type t = space * lab
				 val equal = op=
				 fun hash(_,l) = Label.hash l)

    datatype inf' =
	  TOP					(* top *)
	| CON    of path * kind			(* interface constructor *)
	| SIG    of sign			(* signature *)
	| THAT   of mod				(* singleton *)
	| FUN    of path * inf * inf		(* arrow (functor) *)
	| EXIST  of path * inf * inf		(* hidden module *)
	| LAMBDA of path * inf * inf		(* abstraction (dep. function)*)
	| APPLY  of inf * mod			(* application *)
	| ABBREV of inf * inf			(* abbreviations *)

    and item =
	  FIX    of lab  * fix			(* fixity *)
	| VAL    of lab  * typ			(* value *)
	| TYP    of path * tkind		(* type *)
	| MOD    of path * inf			(* module *)
	| INF    of path * kind			(* interface *)
	| HIDDEN of item			(* existentially quantified *)

    and kind' =
	  GROUND				(* ordinary interface *)
	| SING   of inf				(* singleton *)
	| DEP    of path * inf * kind		(* dependent *)

    withtype mod  = path * inf' cell		(* [m] *)
    and      inf  = inf' cell			(* [jota,j] *)
    and      kind = kind' cell			(* [kappa,k] *)
    and      sign = item list ref *		(* [sigma,s] *)
		    item Tab.t option ref *
		    GlobalStamp.t list
			(* The list of items in a sig is in reverse order! *)

    type t = inf

    structure Map     = Cell.MkMap(type t = inf')
    structure KindMap = Cell.MkMap(type t = kind')


  (* Realisations *)

    type typ_rea = typ PathMap.t
    type mod_rea = mod PathMap.t
    type inf_rea = inf PathMap.t

    type rea	 = { typ_rea : typ_rea
		   , mod_rea : mod_rea
		   , inf_rea : inf_rea
		   }

    fun rea()    = { typ_rea = PathMap.map()
		   , mod_rea = PathMap.map()
		   , inf_rea = PathMap.map()
		   } : rea

    fun isEmptyRea {typ_rea, mod_rea, inf_rea} =
	PathMap.isEmpty typ_rea andalso
	PathMap.isEmpty mod_rea andalso
	PathMap.isEmpty inf_rea

    val dummyRea = rea()

    fun cloneRea {typ_rea, mod_rea, inf_rea} : rea =
	{ typ_rea = PathMap.clone typ_rea
	, mod_rea = PathMap.clone mod_rea
	, inf_rea = PathMap.clone inf_rea
	}

    fun unionRea({typ_rea, mod_rea, inf_rea}, rea : rea) =
	(PathMap.unionDisjoint(typ_rea, #typ_rea rea);
	 PathMap.unionDisjoint(mod_rea, #mod_rea rea);
	 PathMap.unionDisjoint(inf_rea, #inf_rea rea))


  (* Mismatch information *)

    datatype mismatch =
	  MissingFix       of lab
	| MissingVal       of lab
	| MissingTyp       of lab
	| MissingMod       of lab
	| MissingInf       of lab
	| MismatchFix      of lab * fix * fix
	| MismatchVal      of lab * typ * typ * Type.mismatch
	| MismatchTyp      of lab * tkind * tkind * Type.kind_mismatch
	| MismatchMod      of lab * mismatch
	| MismatchInf      of lab * kind_mismatch
	| MismatchDom      of mismatch
	| MismatchRan      of mismatch
	| MismatchParam    of mismatch
	| MismatchBody     of mismatch
	| MismatchFun      of mismatch
	| MismatchArg      of mismatch
	| Incompatible     of inf * inf
	| IncompatibleMod  of path * path

    and kind_mismatch =
	  MismatchKindDom  of mismatch
	| MismatchKindRan  of kind_mismatch
	| IncompatibleKind of kind * kind
	| IncompatibleInf  of mismatch

    exception Mismatch of mismatch
    exception KindMismatch of kind_mismatch


  (* Very basic helpers *)

    (* Almost everything in this module is mutually recursive. To avoid
     * confusing reordering and allow for easy tracing (see below) we use
     * the old forward reference trick.
     *)

    nonfix mod

    fun mapr  f   xs		= mapr'(f,xs)
    and mapr'(f,  nil )		= nil
      | mapr'(f, x::xs)		= let val xs' = mapr'(f,xs) in f x :: xs' end

    fun dummy _			= raise Assert.failure
    val modFwd			= ref(dummy : path * inf -> mod)
    val applyFwd'		= ref(dummy : inf * mod -> inf)
    val narrowFwd 		= ref(dummy : inf * inf -> inf)
    val narrowModFwd 		= ref(dummy : mod * inf -> mod)
    val realiseFwd		= ref(dummy : rea * inf -> inf)
    val realiseKindFwd		= ref(dummy : rea * kind -> kind)
    val replaceNarrowedFwd	= ref(dummy : path * inf * inf -> inf)
    val matchFwd		= ref(dummy : inf * inf -> rea)
    val matchKindFwd 		= ref(dummy : kind * kind -> unit)
    val maximiseFwd		= ref(dummy : PathSet.t * inf -> inf)
    val maximiseExistFwd	= ref(dummy : PathSet.t * path* inf* inf -> inf)

    fun mod(p,j)		= !modFwd(p,j)
    fun apply'(j,m)		= !applyFwd'(j,m)
    fun narrow(j1,j2)		= !narrowFwd(j1,j2)
    fun narrowMod(m,j)		= !narrowModFwd(m,j)
    fun realise(rea,j)		= !realiseFwd(rea,j)
    fun realiseKind(rea,k)	= !realiseKindFwd(rea,k)
    fun replaceNarrowed(p,j,j')	= !replaceNarrowedFwd(p,j,j')
    fun match(j1,j2)		= !matchFwd(j1,j2)
    fun matchKind(k1,k2)	= !matchKindFwd(k1,k2)
    fun maximise(u,j)		= !maximiseFwd(u,j)
    fun maximiseExist(u,p,j1,j2) = !maximiseExistFwd(u,p,j1,j2)


  (* Debugging aids *)

    val new     = cell
    val newKind = cell

    (*DEBUG: The following allows tracing of all interface nodes.

    fun pth p = PrettyPrint.toString(PPPath.ppPath p, 1000000)

    fun id j = Int.toString(hash (*DEBUG Addr.addr*) j)

    val rec inf'ToString =
	fn TOP		=> "TOP"
	 | CON(p,_)	=> "CON(" ^ pth p ^ ")"
	 | SIG s	=> "SIG(" ^ sigToString s ^ ")"
	 | THAT(p,j)	=> "THAT(" ^ pth p ^ "," ^ inf j ^ ")"
	 | FUN(p,j1,j2)	=> "FUN(" ^ pth p ^ "," ^ inf j1 ^ "," ^ inf j2 ^ ")"
	 | EXIST(p,j1,j2)
			=> "EXIST(" ^ pth p ^ "," ^ inf j1 ^ "," ^ inf j2 ^ ")"
	 | LAMBDA(p,j1,j2)
			=> "LAMBDA(" ^ pth p ^ "," ^ inf j1 ^ "," ^ inf j2 ^ ")"
	 | APPLY(j1,(p,j2))
			=> "APPLY(" ^ inf j1 ^ "," ^ pth p ^ "," ^ inf j2 ^ ")"
	 | ABBREV(j1,j2) => "ABBREV(" ^ inf j1 ^ "," ^ inf j2 ^ ")"

    and inf = fn j => id j (*DEBUG ^ "=" ^ inf'ToString(content j)*)

    and sigToString = fn(ref itemsr,_,_) =>
	String.separate ";" (List.rev (List.map itemToString itemsr))

    and itemToString =
	fn FIX(l,f) => "" (*DEBUG "fix " ^ Label.toString l*)
	 | VAL(l,t) => "val " ^ Label.toString l ^ ":" ^ (*Int.toString(Type.hash t)DEBUG*) PrettyPrint.toString(PPType.ppTyp t, 1000000)
	 | TYP(p,k) => "typ " ^ pth p ^ ":" ^ PrettyPrint.toString(PPType.ppKind k, 1000000)
	 | MOD(p,j) => "mod " ^ pth p ^ ":" ^ inf j
	 | INF(p,k) => "inf " ^ pth p ^ ":" ^ kind k
	 | HIDDEN i => "?" ^ itemToString i

    and kind'ToString =
	fn GROUND	=> "GROUND"
	 | SING j	=> "SING(" ^ inf j ^ ")"
	 | DEP(p,j,k)	=> "DEP(" ^ pth p ^ "," ^ inf j ^ "," ^ kind k ^ ")"

    and kind = fn k => id k (*DEBUG ^ "=" ^ kind'ToString (content k)*)

    fun infToString j  = id j ^ "=" ^ inf'ToString (content j)
    fun kindToString k = id k ^ "=" ^ kind'ToString (content k)

    val new = fn j' =>
	let
	    val j = cell j'
	in
	    TextIO.print("new " ^ id j ^ " = " ^ inf'ToString j' ^ "\n");
	    j
	end

    val replace = fn(j,j') =>
	( TextIO.print("replace " ^ id j ^ " = " ^ inf'ToString (content j) ^
		       " with " ^ inf'ToString j' ^ "\n");
	  replace(j,j')
	)

    val newKind = fn k' =>
	let
	    val k = newKind k'
	in
	    TextIO.print("new " ^ id k ^ " = " ^ kind'ToString k' ^ "\n");
	    k
	end

    *)


  (* Signature helpers *)

    exception Hidden

    fun items(ref items, _, _)	= items
    fun stamps (_,_,zs)		= zs
    fun narrows(s1,s2)		= List.contains (stamps s1) (List.hd(stamps s2))

    fun itemDom(FIX(l,_))	= (FIX',l)
      | itemDom(VAL(l,_))	= (VAL',l)
      | itemDom(TYP(p,_))	= (TYP',Path.toLab p)
      | itemDom(MOD(p,_))	= (MOD',Path.toLab p)
      | itemDom(INF(p,_))	= (INF',Path.toLab p)
      | itemDom(HIDDEN _)	= raise Hidden

    fun itemPath(TYP(p,_))	= p
      | itemPath(MOD(p,_))	= p
      | itemPath(INF(p,_))	= p
      | itemPath _		= raise Assert.failure

    fun tab((itemsr, ref(SOME tab), _) : sign) = tab
      | tab((itemsr, r, _) : sign) =
	let
	    val tab = Tab.map()
	in
	    List.app (fn item => Tab.insertDisjoint(tab, itemDom item, item)
				 handle Hidden => ()) (!itemsr);
	    r := SOME tab;
	    tab
	end
(*DEBUG*)handle e => raise e

    fun missing(FIX',l) = MissingFix l
      | missing(VAL',l) = MissingVal l
      | missing(TYP',l) = MissingTyp l
      | missing(MOD',l) = MissingMod l
      | missing(INF',l) = MissingInf l


  (* Calculating free paths *)

    fun paths j = let val u = PathSet.set() in paths'(u,j); u end
    and paths'(u,j) =
	case content j
	 of TOP			=> ()
	  | CON(p,k)		=> (PathSet.insert(u,p); pathsKind'(u,k))
	  | SIG s		=> pathsSig'(u,s)
	  | THAT m		=> pathsMod'(u,m)
	  | ( FUN(p,j1,j2)
	    | EXIST(p,j1,j2)
	    | LAMBDA(p,j1,j2) )	=> (paths'(u,j2); paths'(u,j1))
	  | APPLY(j,m)		=> (paths'(u,j); paths'(u,#2 m))
				   (*EXPERIMENTAL: non-generative arguments *)
	  | ABBREV(j1,j2)	=> paths'(u,j2)

    and pathsMod'(u, (p,j))	= (PathSet.insert(u,p); paths'(u,j))

    and pathsSig'(u,s)		= List.app (pathsItem' u) (items s)
    and pathsItem' u (FIX _)	= ()
      | pathsItem' u (VAL(l,t))	= PathMap.appi (fn(p,_) => PathSet.insert(u,p))
					       (Type.paths t)
      | pathsItem' u (TYP(p,k))	= PathMap.appi (fn(p,_) => PathSet.insert(u,p))
					       (Type.pathsKind k)
      | pathsItem' u (MOD(p,j))	= paths'(u,j)
      | pathsItem' u (INF(p,k))	= pathsKind'(u,k)
      | pathsItem' u (HIDDEN i)	= pathsItem' u i

    and pathsKind k = let val u = PathSet.set() in pathsKind'(u,k); u end
    and pathsKind'(u,k) =
	case content k
	 of GROUND		=> ()
	  | SING j		=> paths'(u,j)
	  | DEP(p,j,k)		=> (pathsKind'(u,k); paths'(u,j))


  (* Kinds *)

    datatype kind_desc =
	  GroundKind
	| SingKind of inf
	| DepKind  of path * inf * kind

    exception Kind

    fun inspectKind k =
	case content k
	  of GROUND		=> GroundKind
	   | SING j		=> SingKind j
	   | DEP pjk		=> DepKind pjk

    val kGround			= newKind GROUND
    fun groundKind()		= kGround
    fun depKind(p,j,k)		= newKind(DEP(p,j,k))
    fun singKind j		= let val k = kind j in
				      if isSingKind k
				      then k
				      else newKind(SING j)
				  end

    and kind j =
	case content j
	 of ( TOP
	    | SIG _
	    | THAT _
	    | FUN _ )		=> groundKind()
	  | CON(p,k)		=> k
	  | EXIST(p,j1,j2)	=> kind j2
	  | LAMBDA(p,j1,j2)	=> depKind(p, j1, kind j2)
	  | ABBREV(j1,j2)	=> kind j2
	  | APPLY(j1,m)		=> let val (p',j3,j4) = asDepKind(kind j1)
				       val  rea       = match(#2 m,j3)
				   in
				       PathMap.insertDisjoint(#mod_rea rea, p',
							      narrowMod(m,j3));
				       realiseKind(rea,j4)
				   end
(*DEBUG*)handle e => raise e

    and asDepKind k =
	case content k
	 of DEP pjk		=> pjk
	  | SING j		=> asDepKind(kind j)
	  | GROUND		=> raise Kind
    and asSingKind k =
	case content k
	 of SING j		=> j
	  | (GROUND | DEP _)	=> raise Kind

    and isGroundKind k =
    	case content k
	 of GROUND		=> true
	  | SING j		=> isGroundKind(kind j)
	  | _			=> false
    and isDepKind k =
	case content k
	 of DEP _		=> true
	  | SING j		=> isDepKind(kind j)
	  | _			=> false
    and isSingKind k =
	case content k
	 of SING j		=> true
	  | _			=> false



  (* Inspection *)

    fun asMod m = m

    exception Interface

    datatype desc =
	  Top
	| Con    of path
	| Sig    of sign
	| Arrow  of path * inf * inf
	| Exist  of path * inf * inf
	| Lambda of path * inf * inf
	| Apply  of inf * mod
	| Sing   of mod

    fun isAbbrev j = case content j of ABBREV _ => true | _ => false
    fun asAbbrev j = case content j of ABBREV z => z | _ => raise Interface

    fun inspect j =
	case content j
	  of ABBREV(_,j2)	=> inspect j2
	   | TOP		=> Top
	   | CON(p,_)		=> Con p
	   | SIG s		=> Sig s
	   | THAT m		=> Sing m
	   | FUN pjj		=> Arrow pjj
	   | EXIST pjj		=> Exist pjj
	   | LAMBDA pjj		=> Lambda pjj
	   | APPLY jm		=> Apply jm

    fun isTop j =
	case content j
	  of (TOP | SIG _ | FUN _)				=> true
	   | (ABBREV(_,j2) | EXIST(_,_,j2) | THAT(_,j2))	=> isTop j2
	   | (CON _ | LAMBDA _ | APPLY _)			=> false
    fun isSig j =
	case content j
	  of SIG _						=> true
	   | (ABBREV(_,j2) | EXIST(_,_,j2) | THAT(_,j2))	=> isSig j2
	   | (TOP | FUN _ | CON _ | LAMBDA _ | APPLY _)		=> false
    fun isArrow j =
	case content j
	  of FUN _						=> true
	   | (ABBREV(_,j2) | EXIST(_,_,j2) | THAT(_,j2))	=> isArrow j2
	   | (TOP | SIG _ | CON _ | LAMBDA _ | APPLY _)		=> false
    fun isExist j =
	case content j
	  of EXIST _						=> true
	   | (ABBREV(_,j2) | THAT(_,j2))			=> isExist j2
	   | (TOP | SIG _ | FUN _ | CON _ | LAMBDA _ | APPLY _)	=> false
    fun isSing j =
	case content j
	  of THAT _						=> true
	   | (ABBREV(_,j2) | EXIST(_,_,j2))			=> isSing j2
	   | (TOP | SIG _ | FUN _ | CON _ | LAMBDA _ | APPLY _)	=> false
    fun isCon j =
	case content j
	  of CON _						=> true
	   | (ABBREV(_,j2) | EXIST(_,_,j2) | THAT(_,j2))	=> isCon j2
	   | (TOP | SIG _ | FUN _ | LAMBDA _ | APPLY _)		=> false
    fun isLambda j =
	case content j
	  of LAMBDA _						=> true
	   | (ABBREV(_,j2) | EXIST(_,_,j2) | THAT(_,j2))	=> isLambda j2
	   | (TOP | SIG _ | FUN _ | CON _ | APPLY _)		=> false
    fun isApply j =
	case content j
	  of APPLY _						=> true
	   | (ABBREV(_,j2) | EXIST(_,_,j2) | THAT(_,j2))	=> isApply j2
	   | (TOP | SIG _ | FUN _ | CON _ | LAMBDA _)		=> false

    fun asSig j =
	case content j
	  of SIG s						=> s
	   | (ABBREV(_,j2) | EXIST(_,_,j2) | THAT(_,j2))	=> asSig j2
	   | (TOP | FUN _ | CON _ | LAMBDA _ | APPLY _)		=> raise Interface
    fun asArrow j =
	case content j
	  of FUN pjj						=> pjj
	   | (ABBREV(_,j2) | EXIST(_,_,j2) | THAT(_,j2))	=> asArrow j2
	   | (TOP | SIG _ | CON _ | LAMBDA _ | APPLY _)		=> raise Interface
    fun asExist j =
	case content j
	  of EXIST pjj						=> pjj
	   | (ABBREV(_,j2) | THAT(_,j2))			=> asExist j2
	   | (TOP | SIG _ | FUN _ | CON _ | LAMBDA _ | APPLY _)	=> raise Interface
    fun asSing j =
	case content j
	  of THAT m						=> m
	   | (ABBREV(_,j2) | EXIST(_,_,j2))			=> asSing j2
	   | (TOP | SIG _ | FUN _ | CON _ | LAMBDA _ | APPLY _)	=> raise Interface
    fun asCon j =
	case content j
	  of CON(p,_)						=> p
	   | (ABBREV(_,j2) | EXIST(_,_,j2) | THAT(_,j2))	=> asCon j2
	   | (TOP | SIG _ | FUN _ | LAMBDA _ | APPLY _)		=> raise Interface
    fun asLambda j =
	case content j
	  of LAMBDA pjj						=> pjj
	   | (ABBREV(_,j2) | EXIST(_,_,j2) | THAT(_,j2))	=> asLambda j2
	   | (TOP | SIG _ | FUN _ | CON _ | APPLY _)		=> raise Interface
    fun asApply j =
	case content j
	  of APPLY jm						=> jm
	   | (ABBREV(_,j2) | EXIST(_,_,j2) | THAT(_,j2))	=> asApply j2
	   | (TOP | SIG _ | FUN _ | CON _ | LAMBDA _)		=> raise Interface


  (* Creation and injection, reduction *)

    nonfix mod
    fun mod(m as (p,j)) = reduceMod(m,j)	(* ASSUME j ~ instance(p,j) *)
    and reduceMod(m,j) =
	case content j
	 of ABBREV(_,j2)	=> reduceMod(m,j2)
	  | THAT m'		=> m'
	  | _			=> m

    val top'		= let val j = new TOP in fn() => j end
    fun con'(p,k)	= new(CON(p,k))
    fun sign' s		= new(SIG s)
    fun arrow'(p,j1,j2)	= new(FUN(p,j1,j2))
    fun exist'(p,j1,j2)	= new(EXIST(p,j1,j2))

    fun abbrev'(j1,j2)	=
	let
	    val j1' = reduceAbbrevL j1
	    val j2' = reduceAbbrevR j2
	in
	    if Cell.equal(j1',j2')
	    then j1'
	    else new(ABBREV(j1',j2'))
	end
    and reduceAbbrevL j	=
	case content j
	 of ABBREV(j1,_)	=> reduceAbbrevL j1
	  | _			=> j
    and reduceAbbrevR j	=
	case content j
	 of ABBREV(_,j2)	=> reduceAbbrevR j2
	  | _			=> j

    fun sing'(m as (p,j)) = reduceSing(m,j)	(* ASSUME j ~ instance(p,j) *)
    and reduceSing(m,j) =
	case content j
	 of ABBREV(_,j2)	=> reduceSing(m,j2)
	  | THAT _		=> j
	  | _			=> new(THAT m)

    fun lambda'(p,j1,j2) = reduceEta(p,j1,j2)
    and reduceEta(p1,j1,j2) =
	case content j2
	 of APPLY(j3,(p4,j4)) =>
		if Path.equal(p1,p4) andalso not(occurs(p1,j3))
		then j3
		else new(LAMBDA(p1,j1,j2))
	  | ABBREV(_,j3) =>
		reduceEta(p1,j1,j3)
	  (* Not needed, since k is never singleton
	  | CON(_,k) =>
		if isSingKind k
		then reduceEta(p1, j1, asSingKind k)
		else new(LAMBDA(p1,j1,j2))
	  *)
	  | _ =>
		new(LAMBDA(p1,j1,j2))
    and occurs(p,j) = true (*TODO*)

    fun apply'(j,m) = reduceBeta(j,j,m,NONE)
    and reduceBeta(j,j',m,jo) =
	case content j'
	 of LAMBDA(p,j1,j2) =>
	    let
		val rea = match(#2 m,j1)
		val _   = PathMap.insertDisjoint(#mod_rea rea,
						 p, narrowMod(m,j1))
(*DEBUG*)handle e => raise e
		val j2' = realise(rea,j2)
	    in
		case jo of NONE     => j2'
			 | SOME j'' => abbrev'(apply'(j'',m), j2')
	    end
	  | EXIST(p,j1,j2) =>
		reduceBeta(j, j2, m, jo)
	  | ABBREV(j1,j2) =>
		reduceBeta(j, j2, m, SOME(Option.getOpt(jo,j1)))
	  (* Not needed, since k is never singleton
	  | CON(_,k) =>
		if isSingKind k
		then reduceBeta(j, asSingKind k, m, jo)
		else new(APPLY(j,m))
	  *)
	  | _ =>
	    let
		val (_,j1,_) = asDepKind(kind j')
		val  m'      = narrowMod(m,j1)
	    in
		new(APPLY(j,m'))
	    end


    (* kind-safe interface *)

    fun ground j	= if isGroundKind(kind j) then j else raise Kind

    val top		= top'
    fun con(p,k)	= if isSingKind k then asSingKind k else con'(p,k)
    val sign		= sign'
    fun arrow(p,j1,j2)	= arrow'(p, ground j1, ground j2)
    fun exist(p,j1,j2)	= let val u = paths j2 in
			      maximiseExist(u, p, maximise(u, ground j1),
						  ground j2)
			  end
    val sing		= sing'
    fun abbrev(j1,j2)	= (ignore(matchKind(kind j2, kind j1))
			   handle KindMismatch m =>
			      raise Mismatch(Incompatible(j1,j2));
			   abbrev'(j1,j2))
    fun lambda(p,j1,j2)	= lambda'(p, ground j1, j2)
    fun apply(j,m)	= let val j' = apply'(j,m) in
			      if not(isApply j') then () (* matched already *)
			      else ignore(match(#2 m, #2(asDepKind(kind j))));
			      j'
			  end


  (* Signature construction *)

    fun newSig'(is,zs)	= (ref is, ref NONE, GlobalStamp.stamp()::zs)
    fun newSig is	= newSig'(is, [])
    fun emptySig()	= newSig []

    fun hide(FIX(l,q))	= true
      | hide(VAL(l,t))	= true
      | hide(TYP(p,k))	= (Path.hide p; Type.isSingKind k)
      | hide(MOD(p,j))	= (Path.hide p; isSing j)
      | hide(INF(p,k))	= (Path.hide p; isSingKind k)
      | hide(HIDDEN _)	= raise Assert.failure

    fun hideItem' dom item =
	(if itemDom item <> dom then SOME item
	 else if hide item then NONE
	 else SOME(HIDDEN item)
	) handle Hidden => SOME item
    fun hideItem(itemsr, item) =
	itemsr := List.mapPartial (hideItem'(itemDom item)) (!itemsr)

    fun extend(s as (itemsr,_,_), dom, item) =
	(Tab.insertWithi (extendClash itemsr) (tab s, dom, item);
	 itemsr := item :: !itemsr)
    and extendClash itemsr (dom,item',item) = (hideItem(itemsr,item'); item)

    fun extendFix(s,l,q) = extend(s, (FIX',l), FIX(l,q))
    fun extendVal(s,l,t) = extend(s, (VAL',l), VAL(l,t))
    fun extendTyp(s,p,k) = extend(s, (TYP', Path.toLab p), TYP(p,k))
    fun extendMod(s,p,j) = extend(s, (MOD', Path.toLab p), MOD(p,j))
    fun extendInf(s,p,k) = extend(s, (INF', Path.toLab p), INF(p,k))

    fun extendHidden(s as (itemsr,_,_), item) = itemsr := HIDDEN item :: !itemsr

    fun extendHiddenTyp(s,p,k) = (Path.hide p; extendHidden(s, TYP(p,k)))
    fun extendHiddenMod(s,p,j) = (Path.hide p; extendHidden(s, MOD(p,j)))
    fun extendHiddenInf(s,p,k) = (Path.hide p; extendHidden(s, INF(p,k)))


  (* Signature inspection *)

    exception Item

    datatype item_desc =
	  FixItem of lab * fix
	| ValItem of lab * typ
	| TypItem of path * tkind
	| ModItem of path * inf
	| InfItem of path * kind
	| HiddenItem of item

    fun inspectItem(FIX lf)	= FixItem lf
      | inspectItem(VAL lt)	= ValItem lt
      | inspectItem(TYP pk)	= TypItem pk
      | inspectItem(MOD pj)	= ModItem pj
      | inspectItem(INF pk)	= InfItem pk
      | inspectItem(HIDDEN i)	= HiddenItem i

    fun isFixItem(FIX _)	= true
      | isFixItem(HIDDEN i)	= isFixItem i
      | isFixItem _		= false
    fun isValItem(VAL _)	= true
      | isValItem(HIDDEN i)	= isValItem i
      | isValItem _		= false
    fun isTypItem(TYP _)	= true
      | isTypItem(HIDDEN i)	= isTypItem i
      | isTypItem _		= false
    fun isModItem(MOD _)	= true
      | isModItem(HIDDEN i)	= isModItem i
      | isModItem _		= false
    fun isInfItem(INF _)	= true
      | isInfItem(HIDDEN i)	= isInfItem i
      | isInfItem _		= false
    fun isHiddenItem(HIDDEN _)	= true
      | isHiddenItem _		= false

    fun asFixItem(FIX lq)	= lq
      | asFixItem(HIDDEN i)	= asFixItem i
      | asFixItem _		= raise Item
    fun asValItem(VAL lt)	= lt
      | asValItem(HIDDEN i)	= asValItem i
      | asValItem _		= raise Item
    fun asTypItem(TYP pk)	= pk
      | asTypItem(HIDDEN i)	= asTypItem i
      | asTypItem _		= raise Item
    fun asModItem(MOD pj)	= pj
      | asModItem(HIDDEN i)	= asModItem i
      | asModItem _		= raise Item
    fun asInfItem(INF pk)	= pk
      | asInfItem(HIDDEN i)	= asInfItem i
      | asInfItem _		= raise Item
    fun asHiddenItem(HIDDEN i)	= i
      | asHiddenItem _		= raise Item


  (* Signature lookup *)

    fun strong(item as (FIX _ | VAL _))	= item
      | strong(item as TYP(p,k))	= if Type.isSingKind k then item else
					  TYP(p, Type.singKind(Type.con(p,k)))
      | strong(item as MOD(p,j))	= if isSing j then item
					  else MOD(p, sing'(mod(p,j)))
      | strong(item as INF(p,k))	= if isSingKind k then item
					  else INF(p, singKind(con'(p,k)))
      | strong(HIDDEN _)		= raise Assert.failure

    fun selectFix(FIX(l,q))		= q
      | selectFix _			= raise Assert.failure
    fun selectVal(VAL(l,t))		= t
      | selectVal _			= raise Assert.failure
    fun selectTyp(TYP(p,k))		= k
      | selectTyp _			= raise Assert.failure
    fun selectMod(MOD(p,j))		= j
      | selectMod _			= raise Assert.failure
    fun selectInf(INF(p,k))		= k
      | selectInf _			= raise Assert.failure

    fun selectTyp'(TYP(p,k))		= Type.asSingKind k
      | selectTyp' _			= raise Assert.failure
    fun selectMod'(MOD(p,j))		= asSing j
      | selectMod' _			= raise Assert.failure
    fun selectInf'(INF(p,k))		= asSingKind k
      | selectInf' _			= raise Assert.failure

    exception Lookup of lab

    fun lookup space (s,l) =
	case Tab.lookup(tab s, (space,l))
	 of SOME item => item
	  | NONE      => raise Lookup l

    val pathTyp		= itemPath o lookup TYP'
    val pathMod		= itemPath o lookup MOD'
    val pathInf		= itemPath o lookup INF'

    val lookupFix	= selectFix o lookup FIX'
    val lookupVal	= selectVal o lookup VAL'
    val lookupTyp	= selectTyp o lookup TYP'
    val lookupMod	= selectMod o lookup MOD'
    val lookupInf	= selectInf o lookup INF'

    val lookupTyp'	= selectTyp' o strong o lookup TYP'
    val lookupMod'	= selectMod' o strong o lookup MOD'
    val lookupInf'	= selectInf' o strong o lookup INF'


  (* Strip signature lookup tables *)

    fun compress j =
	case content j
	 of TOP			=> ()
	  | CON(_,k)		=> compressKind k
	  | SIG s		=> compressSig s
	  | THAT(_,j)		=> compress j
	  | ( FUN(_,j1,j2)
	    | EXIST(_,j1,j2)
	    | LAMBDA(_,j1,j2)
	    | APPLY(j1,(_,j2))
	    | ABBREV(j1,j2) )	=> (compress j1 ; compress j2)

    and compressKind k =
	case content k
	 of GROUND		=> ()
	  | SING j		=> compress j
	  | DEP(_,j,k)		=> (compress j ; compressKind k)

    and compressSig(isr,tab,_)	= (List.app compressItem (!isr); tab := NONE)

    and compressItem(MOD(_,j))	= compress j
      | compressItem(INF(_,k))	= compressKind k
      | compressItem _		= ()


  (* Closure check *)

    exception Unclosed of lab * typ

    fun close s			= List.app closeItem (items s)
    and closeItem(FIX _)	= ()
      | closeItem(VAL(l,t))	= if Type.isClosed t then ()
				  else raise Unclosed(l,t)
      | closeItem(TYP(_,k))	= ()
      | closeItem(MOD(_,j))	= closeInf j
      | closeItem(INF(_,k))	= ()
      | closeItem(HIDDEN i)	= closeItem i
	(* ASSUME that types and interfaces are always closed *)

    and closeInf j =
	case content j
	 of (TOP | CON _)	=> ()
	  | SIG s		=> close s
	  | THAT(_,j1)		=> closeInf j1
	  | ( FUN(_,j1,j2)
	    | EXIST(_,j1,j2)
	    | LAMBDA(_,j1,j2)
	    | APPLY(j1,(_,j2)))	=> (closeInf j1; closeInf j2)
	  | ABBREV(j1,j2)	=> closeInf j2


  (* Splitting existentials *)

    fun splitExist j = splitExist'(j,j)
    and splitExist'(j,j') =
	case content j
	 of ABBREV(_,j'')  => splitExist'(j,j'')
	  | EXIST(p,j1,j2) => let val (pjs,j) = splitExist j2
			      in ((p,j1)::pjs, j) end
	  | _              => ([],j)


  (* Maximisation *)

    (* Calculate the most general supersignature (i.e. "syntactically smallest")
     * that still binds the given set of paths.
     *)

    fun maximise(u,j) =
	case content j
	 of SIG s =>
	    let
		val s' = maximiseSig(u,s)
	    in
		if List.null(items s') then top'()
		else if s = s' then j
		else sign' s'
	    end
	  | THAT(p,j) =>
		(PathSet.insert(u,p); maximise(u,j); top'())
	  | EXIST(p,j1,j2) =>
	    let
		val j2' = maximise(u,j2)
		val j1' = maximise(u,j1)
	    in
		if Cell.equal(j1,j1') andalso Cell.equal(j2,j2')
		then j
		else maximiseExist(u,p,j1',j2')
	    end
	  | ABBREV(j1,j2) =>
	    let
		val j2' = maximise(u,j2)
	    in
		if Cell.equal(j2,j2')
		then j
		else j2'
	    end
	  | (TOP | CON _ | FUN _ | APPLY _) =>
		top'()
	  | LAMBDA _ =>
		raise Kind

    and maximiseExist(u,p,j1,j2) =
	if PathSet.member(u,p) then exist'(p, j1, replaceNarrowed(p,j1,j2)) else
	case content j1 of TOP => j2
			 | _   => exist'(p,j1,j2)

    and maximiseSig(u,s) =
	let
	    val change = ref false
	    val items' = List.mapPartial (maximiseItem(u,change)) (items s)
	in
	    if !change
	    then newSig items'
	    else s
	end

    and maximiseItem (u,change) (item as FIX _) =
	    (change := true; NONE)
      | maximiseItem (u,change) (item as VAL(l,t)) =
	    (change := true; NONE)
      | maximiseItem (u,change) (item as TYP(p,k)) =
	    if PathSet.member(u,p)
	    then (PathMap.appi (fn(p,_) => PathSet.insert(u,p))
			       (Type.pathsKind k); SOME item)
	    else (change := true; NONE)
      | maximiseItem (u,change) (item as MOD(p,j)) =
	    if PathSet.member(u,p)
	    then (paths'(u,j); SOME item)
	    else let
		val j' = maximise(u,j)
	    in
		if Cell.equal(j,j') then SOME item else
		case content j' of TOP => (change := true; NONE)
				 | _   => (change := true; SOME(MOD(p,j')))
	    end
      | maximiseItem (u,change) (item as INF(p,k)) =
	    if PathSet.member(u,p)
	    then (pathsKind'(u,k); SOME item)
	    else (change := true; NONE)
      | maximiseItem (u,change) (item as HIDDEN item') =
	    Option.map HIDDEN (maximiseItem (u,change) item')


  (* Narrowing *)

   (*
     * ASSUME that j1 < j2
     *
     * The fact that interface subtyping - and thus narrowing - allows
     * elimination of core quantifiers is a bit annoying - we cannot simply
     * take the value items from the original signature but have to take the
     * restricted ones and perform appropriate substitutions on bound type
     * identifiers (for which we have to maintain a realisation). This requires
     * prior calculation of a type realisation and thus a 2-pass approach.
     *
     * Minimisation removes redundant existentials or hidden items.
     *)

    type narrow_context =
	{extend :  bool,
	 used :    PathSet.t,
	 typ_rea : typ_rea,
	 typ :     Type.realise_context}

    fun narrowContext extend =
	{extend  = extend,
	 used    = PathSet.set(),
	 typ_rea = PathMap.map(),
	 typ     = Type.realiseStart()}

    fun narrow'(c,j1,j2) =
	if Cell.equal(j1,j2) then j1 else
	case (content j1, content j2)
	 of (_, CON _) => j1
	  | (_, TOP)   => j2

	  | (_, ABBREV(_,j22)) => narrow'(c,j1,j22)
	  | (ABBREV(_,j12), _) =>
	    let
		val j12' = narrow'(c,j12,j2)
	    in
		if Cell.equal(j12,j12')
		then j1
		else j12'
	    end

	  | (_, THAT(_,j2')) => narrow'(c,j1,j2')
	  | (THAT m1, _) =>
	    let
		val m = narrowMod'(c,m1,j2)
	    in
		if Cell.equal(#2 m1, #2 m)
		then j1
		else sing' m
	    end

	  | (_, EXIST(p2,j21,j22)) => narrow'(c,j1,j22)
	  | (EXIST(p1,j11,j12), _) =>
	    let
		val j12' = narrow'(c,j12,j2)
		val j11' = maximise(#used c,j11)
	    in
		if Cell.equal(j11,j11') andalso Cell.equal(j12,j12')
		then j1
		else maximiseExist(#used c, p1,j11',j12')
	    end

	  | (SIG s1, SIG s2) =>
	    let
		val s1' = narrowSig'(c,s1,s2)
	    in
		if s1 = s1'
		then j1
		else sign' s1'
	    end

	  | (FUN(p1,j11,j12), FUN(p2,j21,j22)) =>
	    let
		val typ_rea' = PathMap.clone(#typ_rea c)
		val _        = narrowTypRea(typ_rea',j11,j21)
		val _        = narrowTypRea(typ_rea',j12,j22)
		val c'       = {extend  = #extend c,
				used    = #used c,
				typ_rea = typ_rea',
				typ     = #typ c}
		val j12'     = narrow'(c',j12,j22)
	    in
		if Cell.equal(j12,j12')
		then j1
		else arrow'(p1,j11,j12')
	    end

	  | (APPLY _, APPLY _)	=> (paths'(#used c,j1); j1)
	  | (LAMBDA _,LAMBDA _)	=> raise Kind
	  | _			=> raise Mismatch(Incompatible(j1,j2))

    and narrowMod'(c, (p,j1), j2) =
	(PathSet.insert(#used c, p) ; (p, narrow'(c,j1,j2)))

    and narrowSig'(c,s1,s2) =
	if narrows(s2,s1) then s2 else
	let
	    val tab1   = tab s1
	    val tab2   = tab s2
	    val change = ref false
	    val maximiseItem = maximiseItem(#used c, change)

	    fun narrowItem item1 =
		(case (item1, Tab.lookup(tab2, itemDom item1))
		 of (FIX _, SOME(FIX _)) =>
			SOME item1
		  | (VAL(l1,t1), SOME(VAL(l2,t2))) =>
		    let
			val t2' = Type.realiseCont(#typ c,#typ_rea c,t2)
		    in
			PathMap.appi (fn(p,_) => PathSet.insert(#used c,p))
				     (Type.paths t1);
			SOME(if Type.equal(t1,t2')
			     then item1
			     else (change := true; VAL(l2,t2')))
		    end
		  | (TYP(p1,k1), SOME(TYP _)) =>
			(PathMap.appi (fn(p,_) => PathSet.insert(#used c,p))
				      (Type.pathsKind k1);
			 SOME item1)
		  | (MOD(p1,j1), SOME(MOD(p2,j2))) =>
		    let
			val j1' = narrow'(c,j1,j2)
		    in
			SOME(if Cell.equal(j1,j1')
			     then item1
			     else (change := true; MOD(p1,j1')))
		    end
		  | (INF(p1,k1), SOME(INF _)) =>
			(pathsKind'(#used c,k1); SOME item1)
		  | (_, NONE) =>
		    if #extend c
		    then maximiseItem item1
		    else (change:= true; Option.map HIDDEN (maximiseItem item1))
		  | _ =>
			raise Assert.failure
		) handle Hidden =>
			maximiseItem item1

	     val items1' = List.mapPartial narrowItem (items s1)
	in
	    if !change
	    then newSig'(items1', stamps s1)
	    else s1
	end


    and narrowTypRea(typ_rea,j1,j2) =
	if Cell.equal(j1,j2) then () else
	case (content j1, content j2)
	 of (ABBREV(_,j1'), _)	=> narrowTypRea(typ_rea,j1',j2)
	  | (_, ABBREV(_,j2'))	=> narrowTypRea(typ_rea,j1,j2')
	  | (THAT(_,j1'), _)	=> narrowTypRea(typ_rea,j1',j2)
	  | (EXIST(_,_,j1'), _)	=> narrowTypRea(typ_rea,j1',j2)
	  | (_, EXIST(_,_,j2'))	=> narrowTypRea(typ_rea,j1,j2')
	  | (SIG s1, SIG s2)	=> narrowTypReaSig(typ_rea,s1,s2)
	  | _			=> ()

    and narrowTypReaSig(typ_rea,s1,s2) =
	if narrows(s1,s2) then () else
	let
	    val tab1 = tab s1

	    fun narrowTypReaItem(item2 as TYP(p2,k2)) =
		if Type.isSingKind k2 then () else
		let
		    val (p1,k1) =
			asTypItem(Tab.lookupExistent(tab1, itemDom item2))
		in
		    PathMap.insert(typ_rea, p2, Type.con(p1,k1))
		end
	      | narrowTypReaItem(item2 as MOD(p2,j2)) =
		let
		    val (p1,j1) =
			asModItem(Tab.lookupExistent(tab1, itemDom item2))
		in
		    narrowTypRea(typ_rea,j1,j2) handle Mismatch m =>
			raise Mismatch(MismatchMod(Path.toLab p2, m))
		end
	      | narrowTypReaItem _ = ()
	in
	    List.app narrowTypReaItem (items s2)
	    handle Tab.Unknown dom => raise Mismatch(missing dom)
	end


    fun narrow''(extend,j1,j2) =
	let
	    val c = narrowContext extend
	in
	    narrowTypRea(#typ_rea c,j1,j2);
	    narrow'(c,j1,j2)
	end

    fun narrowSig''(extend,s1,s2) =
	let
	    val c = narrowContext extend
	in
	    narrowTypReaSig(#typ_rea c,s1,s2);
	    narrowSig'(c,s1,s2)
	end

    fun narrow(j1,j2)       = narrow''(false,j1,j2)
    fun narrowExt(j1,j2)    = narrow''(true,j1,j2)
    fun narrowSig(s1,s2)    = narrowSig''(false,s1,s2)
    fun narrowSigExt(s1,s2) = narrowSig''(true,s1,s2)
    fun narrowMod(m1,j2)    = narrowMod'(narrowContext false, m1,j2)


  (* Cloning for substitution. *)

    datatype inst_flag = BothSingleton | LeftSingleton	(* used for infimum *)
    datatype inst      = NoInst of inst_flag | InstTop | InstDot of path

    type build_context =
	 { inf :  inf Map.t
	 , kind : kind KindMap.t
	 , typ :  Type.realise_context
	 , rea :  rea
	 , inst : inst
	 }

    fun instContext(c as {inf, kind, typ, rea, inst}, inst') =
	let
	    val inst'' = case (inst,inst')
			 of (_, NoInst BothSingleton) => inst'
			  | (NoInst _, _)             => inst
			  | _                         => inst'
	in
	    {inf = inf, kind = kind, typ = typ, rea = rea, inst = inst'}
	end

    fun build(c : build_context, j) =
	case Map.lookup(#inf c, j)
	 of SOME j'		=> j'
	  | NONE		=>
	case content j
	 of TOP			=> buildOld(c, j)
	  | SIG s		=> buildSig(c, j, sign', s)
	  | THAT m		=> buildSing(c, j, sing', m)
	  | FUN(p,j1,j2)	=> buildBind(c, j, arrow', p,j1,j2)
	  | EXIST(p,j1,j2)	=> buildBind(c, j, exist', p,j1,j2)
	  | LAMBDA(p,j1,j2)	=> buildBind(c, j, lambda', p,j1,j2)
	  | APPLY(j1,m)		=> buildApply(c, j, apply', j1,m)
	  | ABBREV(j1,j2)	=> buildPair(c, j, abbrev', j1,j2)
	  | CON(p,k)		=>
	case PathMap.lookup(#inf_rea(#rea c), p)
	 of NONE		=> buildOld(c, j)
	  | SOME j'		=> buildNew(c, j,j')
	    (* DEBUG
		(matchKind(kind j',k)
		 handle KindMismatch m => raise Mismatch(Incompatible(j,j'));
		 buildNew(c,j,j')
		)
	    *)

    and buildOld(c,j)    = (Map.insertDisjoint(#inf c, j,j); j)
    and buildNew(c,j,j') = (Map.insertDisjoint(#inf c, j,j'); j')

    and buildPath({inst = NoInst _, ...},   p) = p
      | buildPath({inst = InstTop, ...},    p) = Path.instance p
      | buildPath({inst = InstDot p', ...}, p) = if Path.isHidden p
						 then Path.instance p
						 else Path.dot(p', Path.toLab p)
(*DEBUG
handle e =>
(TextIO.print "Inf.buildPath failure: ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p, 80);
TextIO.print "\n";
raise e)
*)

    and buildBind(c, j, toInf, p,j1,j2) =
	let
	    val p'  = buildPath(instContext(c,InstTop), p)
	    val j1' = build(instContext(c, InstDot p'), j1)
	    val _   = if isSing j1 orelse
			Cell.equal(j1,j1') andalso Path.equal(p,p') then () else
		      PathMap.insertDisjoint(#mod_rea(#rea c), p, mod(p',j1'))
(*DEBUG
before (
TextIO.print "Inf.build: ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p, 80);
TextIO.print " -> ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p', 80);
TextIO.print "\n";
())
*)
	    val j2' = build(instContext(c, InstTop), j2)
	in
	    if Path.equal(p,p') andalso Cell.equal(j1,j1')
				andalso Cell.equal(j2,j2')
	    then buildOld(c, j)
	    else buildNew(c, j, toInf(p',j1',j2'))
	end
(*DEBUG*)handle e => raise e

    and buildPair(c, j, toInf, j1,j2) =
	let
	    val j1' = build(c,j1)
	    val j2' = build(c,j2)
	in
	    if Cell.equal(j1,j1') andalso Cell.equal(j2,j2')
	    then buildOld(c, j)
	    else buildNew(c, j, toInf(j1',j2'))
	end

    and buildApply(c, j, toInf, j1, m as (p,j2)) =
	let
	    val j1'            = build(c,j1)
	    val m' as (p',j2') = buildMod(c,m)
	in
	    if Path.equal(p,p') andalso Cell.equal(j1,j1')
				andalso Cell.equal(j2,j2')
	    then buildOld(c, j)
	    else buildNew(c, j, toInf(j1',m'))
	end

    and buildSing(c, j, toInf, m as (p,j1)) =
	let
	    val m' as (p',j1') = buildMod(c,m)
	in
	    if Cell.equal(j1,j1') andalso Path.equal(p,p')
	    then buildOld(c, j)
	    else buildNew(c, j, toInf m')
	end

    and buildMod(c, m as (p,j)) =
	case PathMap.lookup(#mod_rea(#rea c), p)
	 of NONE    => m
	  | SOME m' => narrowMod'({extend  = false,
				   used    = PathSet.set(),
				   typ_rea = #typ_rea(#rea c),
				   typ     = #typ c}, m', j)

    and buildSig(c, j, toInf, s) =
	let
	    val change = ref false
	    val items' = mapr (fn item => buildItem(c,change,item)) (items s)
	in
	    if !change
	    then buildNew(c, j, toInf(newSig items'))
	    else buildOld(c, j)
	end

    and buildItem(c, change, item as FIX _) =
	    item
      | buildItem(c, change, item as VAL(l,t)) =
	let
	    val t' = Type.realiseCont(#typ c, #typ_rea(#rea c), t)
(*DEBUG*)handle e => raise e
(*DEBUG
val _ = if l = Label.fromString "new" then (
TextIO.print "Inf.buildItem: \"new\"\n";
TextIO.print "t = ";
PrettyPrint.output(TextIO.stdOut, PPType.ppTyp t, 80);
TextIO.print "\n";
TextIO.print "t' = ";
PrettyPrint.output(TextIO.stdOut, PPType.ppTyp t', 80);
TextIO.print "\n";
TextIO.print "typ_rea = {\n";
PathMap.appi (fn(p,t) => (
  TextIO.print "  ";
  PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p, 80);
  TextIO.print " -> ";
  PrettyPrint.output(TextIO.stdOut, PPType.ppTyp t, 80);
  TextIO.print "\n";
())) (#typ_rea(#rea c));
TextIO.print "}\n";
())
else ()
*)
	in
	    if Type.same(t,t') then item else
	    (change := true; VAL(l,t'))
	end
      | buildItem(c, change, item as TYP(p,k)) =
	let
	    val p' = buildPath(c,p)
	    val k' = Type.realiseKindCont(#typ c, #typ_rea(#rea c), k)
(*DEBUG*)handle e => raise e
	in
	    if Type.sameKind(k,k') andalso Path.equal(p,p') then item else
	    (
		if Type.isSingKind k then ()
		else (PathMap.insert(#typ_rea(#rea c),p,Type.con(p',k'));
(*DEBUG
TextIO.print "Inf.build: ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p, 80);
TextIO.print " -> ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p', 80);
TextIO.print "\n";
*)
())
(*DEBUG*)handle e => raise e;
		change := true; TYP(p',k')
	    )
	end
      | buildItem(c, change, item as MOD(p,j)) =
	let
	    val p' = buildPath(c,p)
	    val j' = build(instContext(c, InstDot p'), j)
	in
	    if Cell.equal(j,j') andalso Path.equal(p,p') then item else
	    (
		if isSing j then ()
		else (PathMap.insert(#mod_rea(#rea c), p, mod(p',j'));
(*DEBUG
TextIO.print "Inf.build: ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p, 80);
TextIO.print " -> ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p', 80);
TextIO.print "\n";
*)
())
(*DEBUG*)handle e => raise e;
		change := true; MOD(p',j')
	    )
	end
      | buildItem(c, change, item as INF(p,k)) =
	let
	    val p' = buildPath(c,p)
	    val k' = buildKind(c,k)
	in
	    if Cell.equal(k,k') andalso Path.equal(p,p') then item else
	    (
		if isSingKind k then ()
		else (PathMap.insert(#inf_rea(#rea c), p, con(p',k'));
(*DEBUG
TextIO.print "Inf.build: ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p, 80);
TextIO.print " -> ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p', 80);
TextIO.print "\n";
*)
())
(*DEBUG*)handle e => raise e;
		change := true; INF(p',k')
	    )
	end
      | buildItem(c, change, HIDDEN item') =
	    HIDDEN(buildItem(c, change, item'))


    and buildKind(c,k) =
	case KindMap.lookup(#kind c, k)
	 of SOME k'		=> k'
	  | NONE		=>
	case content k
	 of GROUND		=> buildOldKind(c,k)
	  | SING j		=> buildSingKind(c, k, singKind, j)
	  | DEP(p,j,k1)		=> buildBindKind(c, k, depKind, p,j,k1)

    and buildOldKind(c,k)    = (KindMap.insertDisjoint(#kind c, k, k); k)
    and buildNewKind(c,k,k') = (KindMap.insertDisjoint(#kind c, k, k'); k')

    and buildSingKind(c, k, toKind, j) =
	let
	    val j' = build(c,j)
	in
	    if Cell.equal(j,j')
	    then buildOldKind(c, k)
	    else buildNewKind(c, k, toKind j')
	end

    and buildBindKind(c, k, toKind, p,j,k1) =
	let
	    val p'  = buildPath(c,p)
(*DEBUG
val _ = (
TextIO.print "Inf.buildKind: ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p, 80);
TextIO.print " -> ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p', 80);
TextIO.print "\n";
())
*)
	    val j'  = build(instContext(c, InstDot p'), j)
	    val k1' = buildKind(instContext(c, InstTop), k1)
	in
	    if Cell.equal(j,j') andalso Cell.equal(k1,k1')
	    then buildOldKind(c, k)
	    else buildNewKind(c, k, toKind(p,j',k1'))
	end


  (* Realisation *)

    and realise(rea, j) =
	if isEmptyRea rea then j else
	build({inf  = Map.map(),
	       kind = KindMap.map(),
	       typ  = Type.realiseStart(),
	       rea  = rea,
	       inst = InstTop}, j)

    and replaceNarrowed(p,j,j') =
	let
	    val rea = rea()
	in
	    PathMap.insertDisjoint(#mod_rea rea, p, mod(p,j));
	    build({inf  = Map.map(),
		   kind = KindMap.map(),
		   typ  = Type.realiseStart(),
		   rea  = rea,
		   inst = NoInst LeftSingleton}, j')
	end


  (* Instantiation (bound renaming) *)

    fun instance(p,j) =
	let
(*DEBUG
val _ = TextIO.print "Inf.instance...\n"
val _ = TextIO.print("j = " ^ infToString j ^ "\n")
*)
	    val rea = rea()
	    val j'  = build({inf  = Map.map(),
			     kind = KindMap.map(),
			     typ  = Type.realiseStart(),
			     rea  = rea,
			     inst = InstDot p}, j)
	in
(*DEBUG
TextIO.print "Inf.instance done.\n";
*)
	    (j',rea)
	end
				   (* should remove p,j refs from u! *)


  (* Matching *)

    fun match(j1,j2) =
	let
	    val rea = rea()
	in
(*DEBUG
TextIO.print "Inf.match...\n";
TextIO.print("j1 = " ^ infToString j1 ^ "\n");
TextIO.print("j2 = " ^ infToString j2 ^ "\n");
*)
	    match'(Type.matchStart(), rea, j1,j2);
	    rea
(*
before
TextIO.print "Inf.match done.\n"
*)
	end
    and match'(mt,rea,j1,j2) =
	if Cell.equal(j1,j2) then () else
	case (content j1, content j2)
	 of (ABBREV(_,j1'), _) => match'(mt,rea,j1',j2)
	  | (_, ABBREV(_,j2')) => match'(mt,rea,j1,j2')
	  | (EXIST(_,_,j12), _) =>
		match'(mt,rea,j12,j2)
	  | (_, EXIST(_,_,j22)) =>
		match'(mt,rea,j1,j22)
	  | (_, TOP) =>
		()
	  | (THAT m1, THAT m2) =>
		matchMod(mt,rea,m1,m2)
	  | (THAT(p1,j1'), _) =>
		match'(mt,rea,j1',j2)
	  | (CON(p1,_), CON(p2,_)) =>
		if Path.equal(p1,p2) then () else
		(case PathMap.lookup(#inf_rea rea, p1)
		   of SOME j1' => match'(mt,rea,j1',j2)
		    | NONE     =>
		 case PathMap.lookup(#inf_rea rea, p2)
		   of SOME j2' => match'(mt,rea,j1,j2')
		    | NONE     => raise Mismatch(Incompatible(j1,j2))
		)
	  | (CON(p1,_), _) =>
		(case PathMap.lookup(#inf_rea rea, p1)
		   of SOME j1' => match'(mt,rea,j1',j2)
		    | NONE     => raise Mismatch(Incompatible(j1,j2))
		)
	  | (_, CON(p2,_)) =>
		(case PathMap.lookup(#inf_rea rea, p2)
		   of SOME j2' => match'(mt,rea,j1,j2')
		    | NONE     => raise Mismatch(Incompatible(j1,j2))
		)
	  | (SIG s1, SIG s2) =>
		matchSig(mt,rea,s1,s2)
	  | (FUN(p1,j11,j12), FUN(p2,j21,j22)) =>
		let
		    val rea' = cloneRea rea
		in
		    match'(mt,rea',j21,j11)
		    handle Mismatch m => raise Mismatch(MismatchDom m);
		    PathMap.insertDisjoint(#mod_rea rea', p1,
					   mod(p2, narrow(j21,j11)))
(*DEBUG*)handle e => raise e
;
		    match'(mt,rea',j12,j22)
		    handle Mismatch m => raise Mismatch(MismatchRan m)
		end
	  | (LAMBDA(p1,j11,j12), LAMBDA(p2,j21,j22)) =>
		let
		    val rea' = cloneRea rea
		    val mt'  = Type.matchBranch mt
		in
		    match'(mt',rea',j21,j11)
		    handle Mismatch m => raise Mismatch(MismatchParam m);
		    PathMap.insertDisjoint(#mod_rea rea', p1,
					   mod(p2, narrow(j21,j11)))
(*DEBUG*)handle e => raise e
;
		    equal'(mt',rea',j12,j22)
		    handle Mismatch m => raise Mismatch(MismatchBody m)
		end
	  | (APPLY(j1',m1), APPLY(j2',m2)) =>
		(match'(mt,rea,j1',j2')
		 handle Mismatch m => raise Mismatch(MismatchFun m);
		 (* EXPERIMENTAL: make arguments non-generative *)
		 equal'(mt,rea,#2 m1,#2 m2)
		 (* originally: equalMod'(mt,rea,m1,m2) *)
		 handle Mismatch m => raise Mismatch(MismatchArg m)
		)
	  | _ => raise Mismatch(Incompatible(j1,j2))

    and matchMod(mt, rea, m1 as (p1,j1), m2 as (p2,j2)) =
	if Path.equal(p1,p2) then match'(mt,rea,j1,j2) else
	case PathMap.lookup(#mod_rea rea, p1)
	  of SOME m1' => matchMod(mt,rea,m1',m2)
	   | NONE     =>
	case PathMap.lookup(#mod_rea rea, p2)
	  of SOME m2' => matchMod(mt,rea,m1,m2')
	   | NONE     => raise Mismatch(IncompatibleMod(p1,p2))

    and matchSig(mt,rea,s1,s2) =
	if narrows(s2,s1)
	then ()
	else List.appr (matchItem (mt,rea,tab s1)) (items s2)

    and matchItem (mt,rea,tab1) item2 =
	let
	    val dom as (_,l) = itemDom item2
	    val item1        = strong(Tab.lookupExistent(tab1,dom))
	in
	    case (item1, item2)
	     of (FIX(l1,q1), FIX(l2,q2)) =>
		if q1 = q2
		then ()
		else raise Mismatch(MismatchFix(l,q1,q2))
	      | (VAL(l1,t1), VAL(l2,t2)) =>
		(Type.matchCont(mt,#typ_rea rea,t1,t2)
		 handle Type.Mismatch m =>
			raise Mismatch(MismatchVal(l,t1,t2,m))
		)
	      | (TYP(p1,k1), TYP(p2,k2)) =>
		(Type.matchKindCont(mt,#typ_rea rea,k1,k2)
		 handle Type.KindMismatch m =>
			raise Mismatch(MismatchTyp(l,k1,k2,m));
		 if Type.isSingKind k2 orelse Path.equal(p1,p2) then () else
		 PathMap.insertDisjoint(#typ_rea rea, p2, Type.asSingKind k1)
(*DEBUG
before (
TextIO.print "Inf.match: ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p2, 80);
TextIO.print " -> ";
PrettyPrint.output(TextIO.stdOut, PPType.ppTyp(Type.asSingKind k1), 80);
TextIO.print "\n"
)
*)
(*DEBUG*)handle e => raise e
		)
	      | (MOD(p1,j1), MOD(p2,j2)) =>
		(match'(mt,rea,j1,j2)
		 handle Mismatch m => raise Mismatch(MismatchMod(l,m));
		 if isSing j2 orelse Path.equal(p1,p2) then () else
		 PathMap.insertDisjoint(#mod_rea rea, p2, asSing j1)
(*DEBUG
before (
TextIO.print "Inf.match: ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p2, 80);
TextIO.print " -> ";
TextIO.print(inf j1);
TextIO.print "\n"
)
*)
(*DEBUG*)handle e => raise e
		)
	      | (INF(p1,k1), INF(p2,k2)) =>
		(matchKind'(mt,rea,k1,k2)
		 handle KindMismatch m => raise Mismatch(MismatchInf(l,m));
		 if isSingKind k2 orelse Path.equal(p1,p2) then () else
		 PathMap.insertDisjoint(#inf_rea rea, p2, asSingKind k1)
(*DEBUG
before (
TextIO.print "Inf.match: ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p2, 80);
TextIO.print " -> ";
TextIO.print(inf(asSingKind k1));
TextIO.print "\n"
)
*)
(*DEBUG*)handle e => raise e
		)
	      | _ => raise Assert.failure
	end
	handle Hidden          => ()
	     | Tab.Unknown dom => raise Mismatch(missing dom)

    and matchKind(k1,k2) = matchKind'(Type.matchStart(), rea(), k1,k2)
    and matchKind'(mt,rea,k1,k2) =
	if Cell.equal(k1,k2) then () else
	case (content k1, content k2)
	 of (GROUND, GROUND) => ()
	  | (SING _, GROUND) => ()
	  | (SING j1, SING j2) => equal'(mt,rea,j1,j2)
	  | (DEP(p1,j1,k11), DEP(p2,j2,k21)) =>
	    let
		val rea' = cloneRea rea
		val mt'  = Type.matchBranch mt
	    in
		match'(mt',rea',j2,j1)
		handle Mismatch m => raise KindMismatch(MismatchKindDom m);
		PathMap.insertDisjoint(#mod_rea rea', p1,
				       mod(p2, narrow(j2,j1)))
(*DEBUG*)handle e => raise e
;
		matchKind'(mt',rea',k11,k21)
		handle KindMismatch m => raise KindMismatch(MismatchKindRan m)
	    end
	  | _ => raise KindMismatch(IncompatibleKind(k1,k2))


    and equal'(mt,rea,j1,j2) =
	ignore(match'(Type.matchBranch mt, cloneRea rea, j2,j1);
	       match'(Type.matchBranch mt, cloneRea rea, j1,j2))

    and equalMod'(mt,rea,m1,m2) =
	ignore(matchMod(Type.matchBranch mt, cloneRea rea, m2,m1);
	       matchMod(Type.matchBranch mt, cloneRea rea, m1,m2))


  (* infimum (greatest lower bound) *)

    (*
     * This is a simple-minded and restricted algorithm for infimum.
     * It cannot handle signatures with inconsistent orderings.
     * A more general algorithm is not obvious, since it seems to require
     * some fixpoint operation on realisations (which can induce recursion
     * on core types).
     *
     * A universal algorithm is impossible, because interfaces don't form a
     * lattice. A simple counter example is the ability to encode higher-order
     * unification:
     *  j1 = {typ t : *->*; typ u : <t(int)>}
     *  j2 = {typ t : *->*; typ u : <int>}
     * This example requires finding a solution for int = t(int), which is not
     * unique.
     *)

(*DEBUG*)
    fun infimum(j1,j2) =
	infimum'({inf  = Map.map(),
		  kind = KindMap.map(),
		  typ  = Type.realiseStart(),
		  rea  = rea(),
		  inst = InstTop}, j1, j2)
(*
fun infimum(j1,j2) =
(
TextIO.print "Inf.infimum...\n";
TextIO.print("j1 = " ^ infToString j1 ^ "\n");
TextIO.print("j2 = " ^ infToString j2 ^ "\n");
infimum'({inf  = Map.map(),
	    kind = KindMap.map(),
	    typ  = Type.realiseStart(),
	    rea  = rea(),
	    inst = InstTop}, j1, j2)
before
TextIO.print "Inf.infimum done.\n")
*)
(*DEBUG*)handle e => raise e

    and infimum'(c,j1,j2) =
	if Cell.equal(j1,j2) then j1 else
	case (content j1, content j2)
	 of (CON(p1,_), CON(p2,_)) =>
	    (case PathMap.lookup(#inf_rea(#rea c), p1)
	     of SOME j3 => infimum'(c,j3,j2)
	      | NONE =>
	     case PathMap.lookup(#inf_rea(#rea c), p2)
	     of SOME j3 => infimum'(c,j1,j3)
	      | NONE =>
	     if Path.equal(p1,p2)
	     then j1
	     else raise Mismatch(Incompatible(j1,j2))
	    )
	  | (CON(p1,_), _) =>
	    (case PathMap.lookup(#inf_rea(#rea c), p1)
	     of SOME j3 => infimum'(c,j3,j2)
	      | NONE    => raise Mismatch(Incompatible(j1,j2))
	    )
	  | (_, CON(p2,_)) =>
	    (case PathMap.lookup(#inf_rea(#rea c), p2)
	     of SOME j3 => infimum'(c,j1,j3)
	      | NONE    => raise Mismatch(Incompatible(j1,j2))
	    )
	  | (TOP, _) =>
		(* T /\ j2 = j2 *)
		j2
	  | (_, TOP) =>
		(* j1 /\ T = j1 *)
		j1
	  | (THAT m1, THAT m2) =>
	    let
		val m = infimumMod(c,m1,m2)
(*DEBUG*)handle e => raise e
	    in
		sing' m
	    end
	  | (THAT(p1,j1'), _) =>
	    (case PathMap.lookup(#mod_rea(#rea c), p1)
	     of SOME m => (infimum'(c, sing' m, j2)
(*DEBUG*)handle e => raise e)
	      | NONE   =>
	    let
		val j' = infimum'(instContext(c, NoInst LeftSingleton), j1', j2)
		val m  = mod(p1,j')
(*DEBUG*)handle e => raise e
	    in
		sing' m
	    end)
	  | (_, THAT(p2,j2')) =>
	    (case PathMap.lookup(#mod_rea(#rea c), p2)
	     of SOME m => (infimum'(c, j1, sing' m)
(*DEBUG*)handle e => raise e)
	      | NONE   =>
	    let
		val j' = infimum'(instContext(c, NoInst LeftSingleton), j2', j1)
		val m  = mod(p2,j')
(*DEBUG*)handle e => raise e
	    in
		sing' m
	    end)
	  | (SIG s1, SIG s2) =>
	    (* s1 /\ s2 = ... *)
	    let
		val s = infimumSig(c,s1,s2)
(*DEBUG*)handle e => raise e
	    in
		sign' s
	    end
(*
	  | (EXIST(p1,j11,j12), _) =>
	    let
		val j11' = build(instContext(c,p1), j11)
		val j12' = infimum'(c,j12,j2)
	    in
		exist'(p1,j21,j22')
	    end
	  | (_, EXIST(p2,j21,j22)) =>
	    let
		val j21' = build(instContext(c,p2), j21)
		val j22' = infimum'(c,j2,j22)
	    in
		exist'(p2,j21,j22')
	    end
	  | (FUN(p1,j11,j12), FUN(p2,j21,j22)) =>
	    let
		val (j11',rea1) = match(j21,j11) handle Mismatch m =>
				    raise Mismatch(MismatchDom m)
		val  _          = PathMap.insertDisjoint(#mod_rea rea1,p1,(p2,j11'))
		val (j22',rea2) = match(realise(rea1,j12), j22)
				  handle Mismatch m =>
				    raise Mismatch(MismatchRan m)
	    in
		if Cell.equal(j22,j22')
		then (j2, rea2)
		else (arrow'(p2,j21,j22'), rea2)
	    end
	  | (LAMBDA(p1,j11,j12), LAMBDA(p2,j21,j22)) =>
	    let
		val (j11',rea) = match(j21,j11) handle Mismatch m =>
				    raise Mismatch(MismatchParam m)
	    in
		PathMap.insertDisjoint(#mod_rea rea, p1, (p2,j11'));
		equal(realise(rea,j12), j22) handle Mismatch m =>
				    raise Mismatch(MismatchBody m);
		(j2, rea())
	    end
	  | (APPLY(j1',m1), APPLY(j2',m2)) =>
	    let
		val (j',rea1) = match(j1',j2') handle Mismatch m =>
				    raise Mismatch(MismatchFun m)
		val (m',rea2) = matchMod(isNested,m1,m2) handle Mismatch m =>
				    raise Mismatch(MismatchArg m)
	    in
		unionRea(rea2,rea1) handle PathMap.Collision _ =>
		    raise Mismatch(Incompatible(j1,j2));
		if Cell.equal(j2',j') andalso Cell.equal(#2 m2, #2 m')
		then (j2, rea2)
		else (apply'(j',m'), rea2)
	    end
*)	  | (ABBREV(_,j1), _) => infimum'(c,j1,j2)
	  | (_, ABBREV(_,j2)) => infimum'(c,j1,j2)
	  | _ => raise Mismatch(Incompatible(j1,j2))

    and infimumMod(c, m1 as (p1,j1), m2 as (p2,j2)) =
	case PathMap.lookup(#mod_rea(#rea c), p1)
	 of SOME m3 => (infimumMod(c,m3,m2)
(*DEBUG*)handle e => raise e)
	  | NONE =>
	case PathMap.lookup(#mod_rea(#rea c), p2)
	 of SOME m3 => (infimumMod(c,m1,m3)
(*DEBUG*)handle e => raise e)
	  | NONE =>
	if not(Path.equal(p1,p2))
	then raise Mismatch(IncompatibleMod(p1,p2)) else
	let
	    val j = infimum'(instContext(c, NoInst BothSingleton), j1,j2)
(*DEBUG*)handle e => raise e
	in
	    mod(p1,j)
	end

    and infimumSig(c,s1,s2) =
	if narrows(s2,s1) then s1 else
	if narrows(s1,s2) then s2 else
	let
	    val items1 = List.rev(items s1)
	    val items2 = List.rev(items s2)
	    val change = ref false	(* dummy *)
	in
	    newSig(infimumItems(c,change, tab s1, tab s2, items1,items2, []))
	end

    and infimumItems(c,change, tab1,tab2, [], [], items) =
	    items
      | infimumItems(c,change, tab1,tab2, item1::items1, [], items) =
	let
	    val item1' = buildItem(c,change,item1)
	in
	    infimumItems(c,change, tab1,tab2, items1,[], item1'::items)
	end
      | infimumItems(c,change, tab1,tab2, [], item2::items2, items) =
	(case #inst c
	  of NoInst LeftSingleton => raise Mismatch(missing(itemDom item2))
	   | _ =>
	let
	    val item2' = buildItem(c,change,item2)
	in
	    infimumItems(c,change, tab1,tab2, [],items2, item2'::items)
	end)
      | infimumItems(c,change, tab1,tab2, items1 as item1::items1',
					  items2 as item2::items2', items) =
	let
	    val domo1  = SOME(itemDom item1) handle Hidden => NONE
	    val domo2  = SOME(itemDom item2) handle Hidden => NONE
	    val found1 = case domo1 of NONE => false | SOME dom1 =>
			 Option.isSome(Tab.lookup(tab2, dom1))
	    val found2 = case domo2 of NONE => false | SOME dom2 =>
			 Option.isSome(Tab.lookup(tab1, dom2))
	in
	    case (found2, found1)
	     of (_, false) =>
		let
		    val item1' = buildItem(c,change,item1)
		in
		    infimumItems(c,change, tab1,tab2, items1',items2,
				 item1'::items)
		end
	      | (false, _) =>
		(case #inst c
		  of NoInst LeftSingleton=> raise Mismatch(missing(valOf domo2))
		   | _ =>
		let
		    val item2' = buildItem(c,change,item2)
		in
		    infimumItems(c,change, tab1,tab2, items1,items2',
				 item2'::items)
		end)
	      | (true, true) =>
		if domo1 <> domo2 then raise Mismatch(missing(valOf domo1)) else
		let
		    val item = infimumItem(c,item1,item2)
		in
		    infimumItems(c,change, tab1,tab2, items1',items2',
				 item::items)
		end
	end

    and infimumItem(c, item as FIX(l,q1), FIX(_,q2)) =
	    if q1 = q2
	    then item
	    else raise Mismatch(MismatchFix(l,q1,q2))
      | infimumItem(c, VAL(l,t1), VAL(_,t2)) =
	(* TODO: No support for type infimum yet *)
	let
	    val t1' = Type.realiseCont(#typ c, #typ_rea(#rea c), t1)
	    val t2' = Type.realiseCont(#typ c, #typ_rea(#rea c), t2)
	in
	    (Type.match(t2',t1'); VAL(l,t2')) handle Type.Mismatch _ =>
	    (Type.match(t1',t2'); VAL(l,t1')) handle Type.Mismatch m =>
	    raise Mismatch(MismatchVal(l,t1',t2',m))
	end
      | infimumItem(c, TYP(p1,k1), TYP(p2,k2)) =
	(* TODO: No support for kind infimum yet *)
	let
	    val p'  = buildPath(c,p1)
	    val k1' = Type.realiseKindCont(#typ c, #typ_rea(#rea c), k1)
	    val k2' = Type.realiseKindCont(#typ c, #typ_rea(#rea c), k2)
	    val k'  =
		(Type.matchKind(k2',k1'); k2') handle Type.KindMismatch _ =>
		(Type.matchKind(k1',k2'); k1') handle Type.KindMismatch m =>
		raise Mismatch(MismatchTyp(Path.toLab p', k1',k2',m))
	    val t'  = Type.con(p',k')	(* reduces singletons *)
	in
	    if Type.isSingKind k1 then ()
	    else (PathMap.insertDisjoint(#typ_rea(#rea c), p1, t');
(*DEBUG
TextIO.print "Inf.infimum: ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p1, 80);
TextIO.print " -> ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p', 80);
TextIO.print "\n";
*)())
(*DEBUG*)handle e => raise e
;
	    if Type.isSingKind k2 then ()
	    else (PathMap.insertDisjoint(#typ_rea(#rea c), p2, t');
(*DEBUG
TextIO.print "Inf.infimum: ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p2, 80);
TextIO.print " -> ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p', 80);
TextIO.print "\n";
*)())
(*DEBUG*)handle e => raise e
;
	    TYP(p',k')
	end
      | infimumItem(c, MOD(p1,j1), MOD(p2,j2)) =
	let
	    val p' = buildPath(c,p1)
	    val j' = infimum'(instContext(c, InstDot p'), j1,j2)
		     handle Mismatch m =>
			raise Mismatch(MismatchMod(Path.toLab p', m))
	    val m' = mod(p',j')
	in
	    if isSing j1 then ()
	    else (PathMap.insertDisjoint(#mod_rea(#rea c), p1, m');
(*DEBUG
TextIO.print "Inf.infimum: ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p1, 80);
TextIO.print " -> ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p', 80);
TextIO.print "\n";
*)())
(*DEBUG*)handle e => raise e
;
	    if isSing j2 then () else
	    (PathMap.insertDisjoint(#mod_rea(#rea c), p2, m');
(*DEBUG
TextIO.print "Inf.infimum: ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p2, 80);
TextIO.print " -> ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p', 80);
TextIO.print "\n";
*)())
(*DEBUG*)handle e => raise e
;
	    MOD(p',j')
	end
      | infimumItem(c, INF(p1,k1), INF(p2,k2)) =
	let
	    val p' = buildPath(c,p1)
	    val k' = infimumKind(c,k1,k2) handle KindMismatch m =>
		     raise Mismatch(MismatchInf(Path.toLab p', m))
	    val j' = con'(p',k')	(* reduces singletons *)
	in
	    if isSingKind k1 then ()
	    else PathMap.insertDisjoint(#inf_rea(#rea c), p1, j')
(*DEBUG*)handle e => raise e
;
	    if isSingKind k2 then ()
	    else PathMap.insertDisjoint(#inf_rea(#rea c), p2, j')
(*DEBUG*)handle e => raise e
;
	    INF(p',k')
	end
      | infimumItem _ = raise Assert.failure

    and infimumKind(c,k1,k2) =
	(* TODO: contravariance in parameters *)
	let
	    val k1' = buildKind(instContext(c, InstTop), k1)
	    val k2' = buildKind(instContext(c, InstTop), k2)
	in
	    (matchKind(k2',k1'); matchKind(k1',k2'); k1')
	end


  (* Tie forwarding knots *)

    val _ = modFwd             := mod
    val _ = applyFwd'          := apply'
    val _ = narrowFwd          := narrow
    val _ = narrowModFwd       := narrowMod
    val _ = realiseFwd         := realise
    val _ = realiseKindFwd     := realiseKind
    val _ = replaceNarrowedFwd := replaceNarrowed
    val _ = matchFwd           := match
    val _ = matchKindFwd       := matchKind
    val _ = maximiseFwd        := maximise
    val _ = maximiseExistFwd   := maximiseExist
end
