(*
 * Author:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001-2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Label		from "Label"
import structure Path		from "Path"
import structure Fixity		from "Fixity"
import structure Type		from "Type"
import structure Inf		from "Inf"
import structure PervasiveType	from "PervasiveType"
import structure DynMatch	from "../system/DynMatch"

(*DEBUG
import structure TextIO         from "../system/TextIO"
import structure PrettyPrint    from "../utility/PrettyPrint"
import structure PPPath         from "PPPath"
import structure PPType         from "PPType"
import structure PPInf          from "PPInf"
*)

local
    (*DEBUG
    structure Inf =
    struct
	open Inf

	local
	    fun prPath name p =
		(TextIO.print name; TextIO.print " = ";
		 PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p,
				    76 - size name);
		 TextIO.print "\n")

	    fun prTKind name k =
		(TextIO.print name; TextIO.print " = ";
		 PrettyPrint.output(TextIO.stdOut, PPType.ppKind k,
				    76 - size name);
		 TextIO.print "\n")

	    fun prInf name j =
		(TextIO.print name; TextIO.print " = ";
		 PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j,
				    76 - size name);
		 TextIO.print "\n")
	in
	    fun extendTyp(s,p,k) =
		let
		    val _ = TextIO.print "### Runtime signature extension:\n"
		    val _ = prPath "p" p
		    val _ = prTKind "k" k
		in
		    Inf.extendTyp(s,p,k)
		end
(*
	    fun sign s =
		let
		    val _ = TextIO.print "### Runtime signature injection:\n"
		    val j = Inf.sign s
		    val _ = prInf "j" j
		in
		    j
		end
*)
	    fun instance(p,j) =
		let
		    val _ = TextIO.print "### Runtime interface instantiation:\n"
		    val _ = prPath "p" p
		    val _ = prInf "j" j
		    val (j',rea) = Inf.instance(p,j)
		    val _ = prInf "j'" j'
		in
		    (j',rea)
		end

	    fun match(j1,j2) =
		let
		    val _ = TextIO.print "### Runtime interface matching:\n"
		    val _ = prInf "j1" j1
		    val _ = prInf "j2" j2
		in
		   (Inf.match(j1,j2) before TextIO.print "-> OK\n") handle e =>
		       (TextIO.print("-> " ^ General.exnName e ^ "\n"; raise e)
		end

	    fun narrow(j1,j2) =
		let
		    val _ = TextIO.print "### Runtime interface narrowing:\n"
		    val _ = prInf "j1" j1
		    val _ = prInf "j2" j2
		    val j = Inf.narrow(j1,j2)
		    val _ = prInf "j" j
		in
		    j
		end
	end
    end
    *)

    signature LABEL' =
    sig
	type lab = Label.lab

	val fromString :	string -> lab
    end

    signature PATH' =
    sig
	type path = Path.path

	val invent :		unit    -> path
	val pervasive :		string  -> path
	val fromLab :		Label.t -> path
	val fromString :	string  -> path
    end

    signature TYPE' =
    sig
	type var = Type.var
	type typ = Type.typ
	type row = Type.row
	type kind = Type.kind
	type constraint = Type.constraint

	val Unconstrained :	constraint
	val Intensional :	constraint
	val Extensional :	Path.t * Path.t list -> constraint

	val starKind :		unit -> kind
	val extKind :		unit -> kind
	val singKind :		typ -> kind
	val arrowKind :		kind * kind -> kind

	val unknown :		kind -> typ
	val var :		var -> typ
	val con :		Path.t * kind -> typ
	val arrow :		typ * typ -> typ
	val tuple :		typ vector -> typ
	val prod :		row -> typ
	val sum :		row -> typ
	val all :		var * typ -> typ
	val exist :		var * typ -> typ
	val lambda :		var * typ -> typ
	val apply :		typ * typ -> typ

	val newVar :		kind * constraint -> var
	val kind :		typ -> kind

	val unknownRow :	unit -> row
	val emptyRow :		unit -> row
	val extendRow :		Label.t * typ * row -> row

	val fix :		(typ * typ) vector -> unit
    end

    signature FIXITY' =
    sig
	type fix = Fixity.fix
	type assoc = Fixity.assoc

	val LEFT :		assoc
	val RIGHT :		assoc
	val NEITHER :		assoc
	val NONFIX :		fix
	val PREFIX :		int -> fix
	val POSTFIX :		int -> fix
	val INFIX :		int * assoc -> fix
    end

    signature INF' =
    sig
	type mod = Inf.mod
	type inf = Inf.inf
	type sign = Inf.sign
	type kind = Inf.kind
	type rea = Inf.rea

	val emptySig :		unit -> sign
	val extendFix :		sign * Label.t * Fixity.t -> unit
	val extendVal :		sign * Label.t * Type.t -> unit
	val extendTyp :		sign * Path.t * Type.kind -> unit
	val extendMod :		sign * Path.t * inf -> unit
	val extendInf :		sign * Path.t * kind -> unit

	val lookupMod :		sign * Label.t -> inf
	val lookupTyp' :	sign * Label.t -> Type.t
	val lookupInf' :	sign * Label.t -> inf

	val mod :		Path.t * inf -> mod
	val top :		unit -> inf
	val con :		Path.t * kind -> inf
	val sign :		sign -> inf
	val arrow :		Path.t * inf * inf -> inf
	val sing :		mod -> inf
	val lambda :		Path.t * inf * inf -> inf
	val apply :		inf * mod -> inf

	val asSig :		inf -> sign
	val asArrow :		inf -> Path.t * inf * inf

	val groundKind :	unit -> kind
	val depKind :		Path.t * inf * kind -> kind
	val singKind :		inf -> kind

	val kind :		inf -> kind
	val instance :		Path.t * inf -> inf * rea
	val realise :		rea * inf -> inf
	val match :		inf * inf -> rea
	val infimum :		inf * inf -> inf

	type mismatch
	exception Mismatch of mismatch
    end

    signature PERVASIVE_TYPE' =
    sig
	val lookup :		string -> Type.t
    end

    signature DYN_MATCH' =
    sig
	type module
	val match :		module * Inf.inf -> Inf.rea
	val strengthen :	module * Inf.inf -> Inf.inf
	val thin :		module * Inf.inf -> module
	val seal :		module * Inf.inf -> module
    end
in
    (* structure is named __pervasive to avoid spurious warnings during
     * bootstrapping (about unavailable RTTs). *)
    structure __pervasive =
    struct
	structure Label         = Label :> LABEL'
	structure Path          = Path :> PATH'
	structure Fixity        = Fixity :> FIXITY'
	structure Type          = Type :> TYPE'
	structure Inf           = Inf :> INF'
	structure PervasiveType = PervasiveType :> PERVASIVE_TYPE'
	structure DynMatch      = DynMatch :> DYN_MATCH'
    end
end
