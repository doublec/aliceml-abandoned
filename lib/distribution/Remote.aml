(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2001-2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Component         from "x-alice:/lib/system/Component"
import signature COMPONENT_MANAGER
    from "x-alice:/lib/system/COMPONENT_MANAGER-sig"
import structure Unix              from "x-alice:/lib/system/Unix"
import structure Url               from "x-alice:/lib/system/Url"
import structure Http              from "x-alice:/lib/system/Http"
import structure HttpServer        from "x-alice:/lib/system/HttpServer"
import structure HttpClient        from "x-alice:/lib/system/HttpClient"
import signature REMOTE            from "REMOTE-sig"
import structure UnsafeRemote      from "UnsafeRemote"

import structure Debug from "x-alice:/lib/system/Debug"

signature REMOTE_PORT =
    sig
	type ticket = Url.t

	exception Ticket
	exception Proxy of exn
	exception SitedArgument			(* only as proxy cause *)
	exception SitedResult			(* only as proxy cause *)
	exception Protocol of string		(* only as proxy cause *)

	val export: string -> ticket
	val download: ticket -> string

	val exportFn: (string -> string) -> ticket
	val call: ticket * string -> string
    end

structure HttpRemotePort :> REMOTE_PORT =
    struct
	type ticket = Url.t

	exception Ticket
	exception Proxy of exn
	exception SitedArgument
	exception SitedResult
	exception Protocol of string

	val pickleContentType = "application/x-alice-pickle"

	val rootUrl =
	    lazy (Url.fromString
		      ("http://" ^ (UnsafeRemote.getLocalIP ()) ^ ":" ^
		       Int.toString (HttpServer.start NONE) ^ "/"))

	val counter = ref 0

	fun register handler =
	    let
		val p = Promise.promise ()
		val n = Ref.exchange (counter, Promise.future p)
		val uri = Url.setPath (Url.empty, ["export", Int.toString n])
	    in
		Promise.fulfill (p, n + 1);
		HttpServer.register (uri, handler);
		Url.resolve rootUrl uri
	    end

	(* Error Handling *)

	exception Response of Http.response

	val ok                   = 200
	val badRequest           = 400
	val methodNotAllowed     = 405
	val unsupportedMediaType = 415

	fun errorResponse statusCode =
	    Http.makeResponse
		{statusCode,
		 contentType = "text/plain",
		 body = Http.reasonPhrase statusCode}

	fun checkMethod (request: Http.request, method) =
	    if #method request <> method then
		let
		    val response = errorResponse methodNotAllowed
		in
		    Http.StringMap.insert (#headers response, "Allow", method);
		    raise Response response
		end
	    else ()

	fun checkContentType (request: Http.request, contentType) =
	    case Http.StringMap.lookup (#headers request, "content-type") of
		SOME s where (s = contentType) => ()
	      | SOME _ => raise Response (errorResponse unsupportedMediaType)
	      | NONE => raise Response (errorResponse badRequest)

	(* Provided Functionality *)

	fun export packedValue =
	    let
		fun handler request =
		    (checkMethod (request, "GET");
		     Http.makeResponse
			 {statusCode = ok,
			  contentType = pickleContentType,
			  body = packedValue})
		    handle Response response => response
	    in
		register handler
	    end

	fun download url =
	    let
		val response =
		    HttpClient.get url
		    handle HttpClient.Authority => raise Ticket
	    in
		#body response
	    end

	fun exportFn f =
	    let
		fun handler request =
		    (checkMethod (request, "POST");
		     checkContentType (request, pickleContentType);
		     Http.makeResponse
			 {statusCode = ok,
			  contentType = pickleContentType,
			  body = f (#body request)})
		    handle Response response => response
	    in
		register handler
	    end

	fun call (url, packedValue) =
	    let
		val response =
		    HttpClient.post (url, {contentType = pickleContentType,
					   body = packedValue})
		    handle HttpClient.Authority => raise Ticket
	    in
		(*--** check "content-type" header *)
		case #statusCode response of
		    200 => #body response
		  | statusCode => raise Protocol (#reasonPhrase response)
	    end
    end

functor MkRemote(RemotePort: REMOTE_PORT) :> REMOTE =
    struct
	exception Proxy = RemotePort.Proxy
	exception SitedArgument = RemotePort.SitedArgument
	exception SitedResult = RemotePort.SitedResult
	exception Protocol = RemotePort.Protocol

	(*--------------------------------------------------------------
	 * Proxies and RPC
	 *)

	datatype 'a result = RETURN of 'a | RAISE of exn

	fun proxyCallback (url, unpackedArgument) =
	    let
		val packedArgument = UnsafeRemote.packValue unpackedArgument
				     handle Pickle.Sited =>
					 raise Proxy SitedArgument
					(*--** Sited may originate from a
					 failed future *)
		val packedResult = RemotePort.call (url, packedArgument)
				   handle e => raise Proxy e
		val unpackedResult = UnsafeRemote.unpackValue packedResult
				     handle _ =>
					raise Proxy (IO.Io
						     {name = "Remote",
						      function = "proxy",
						      cause = Pickle.Corrupt})
	    in
		case unpackedResult of
		    RETURN y => y
		  | RAISE e => raise e
	    end

	val _ = UnsafeRemote.setCallback proxyCallback

	__primitive val dynamicCall : HttpRemotePort.ticket * 'a -> 'b =
	    "Remote.dynamicCall"

	fun proxy f =
	    let
		fun f' packedArgument =
		    let
			val unpackedArgument =
			    UnsafeRemote.unpackValue packedArgument
			    handle _ => raise Proxy (IO.Io
						     {name = "Remote",
						      function = "proxy",
						      cause = Pickle.Corrupt})
			val unpackedResult = RETURN (f unpackedArgument)
		    in
			UnsafeRemote.packValue unpackedResult
			handle Pickle.Sited => raise Proxy SitedResult
					(*--** Sited may originate from a
					 failed future *)
		    end
		    handle e =>
			UnsafeRemote.packValue (RAISE e)
			handle _ => UnsafeRemote.packValue
					(RAISE (Proxy SitedResult))
		val url = RemotePort.exportFn f'
	    in
		fn x => dynamicCall (url, x)
	    end

	(*--------------------------------------------------------------
	 * Take and Offer
	 *)

	type ticket = string

	exception Ticket = RemotePort.Ticket

	fun offer value =
	    (* make the snapshot here: can raise Sited exception *)
	    Url.toString (RemotePort.export (UnsafeRemote.packValue value))

	fun take ticket =
	    let
		val packedValue = RemotePort.download (Url.fromString ticket)
	    in
		UnsafeRemote.unpackValue packedValue
	    end

	functor Offer(signature S structure X: S) =
	    let
		structure P = Package.Pack(signature S = S structure X = X)
	    in
		(val ticket = offer P.package)
	    end

	functor Take(val ticket: string signature S) =
	    Package.Unpack(val package = take ticket
			   signature S = S)

	(*--------------------------------------------------------------
	 * Remote Execution
	 *)

	functor Execute(val host: string
			signature RESULT
			functor Start(ComponentManager:
				      COMPONENT_MANAGER): RESULT) =
	    let
		val p = Promise.promise ()
		structure T =
		    Offer(signature S =
			      (signature RESULT
			       functor Start(ComponentManager:
					     COMPONENT_MANAGER): RESULT
			       val return: Package.t -> unit)
			  structure X =
			      (signature RESULT = RESULT
			       structure Start = Start
			       val return =
				   proxy (fn package =>
					     Promise.fulfill (p, package))))
		val _ = (*--**DEBUG*)
		    TextIO.print ("ssh " ^ host ^ " alicerun " ^
				  "x-alice:/lib/distribution/RemoteServer " ^
				  T.ticket ^ "\n")
		val _ =
		    Unix.execute ("ssh",
				  [host, "alicerun",
				   "x-alice:/lib/distribution/RemoteServer",
				   T.ticket])
	    in
		Package.Unpack(val package = Promise.future p
			       signature S = RESULT)
	    end
    end

structure Remote = MkRemote(HttpRemotePort)
