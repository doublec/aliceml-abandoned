(*
 * Author:
 *   Guido Tack <tack@ps.uni-sb.de>
 *
 * Copyright:
 *   Guido Tack, 2003
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Gtk            from "x-alice:/lib/gtk/Gtk"
import structure Gdk            from "x-alice:/lib/gtk/Gdk"
import structure Canvas    from "x-alice:/lib/gtk/Canvas"

import structure Types          from "Types"
import structure Defaults       from "Defaults"
import structure TreeNode       from "TreeNode"
import structure VisualNode     from "VisualNode"
import structure GtkNode        from "GtkNode"
import structure ExplorerNode   from "ExplorerNode"
import structure ExplorerSearch from "ExplorerSearch"
import structure OptionsWindow  from "OptionsWindow"
import structure ExplorerGUI    from "ExplorerGUI"
import structure SaveWindow     from "SaveWindow"

import structure MenuManager    from "MenuManager"

structure EventHandler =
  struct

  open Types           
          
  fun nodeEvent (state, serve) event =
      case (!state) of
	  SOME(state as ({gtk={canvas,scale,...},
                          tree={tree=tree,
			        currentNode=currentNode,
                                ...},
			  inspect=inspect,
                          curInspAction=curInspAction,
			  ...}:
			 Types.explorer_state)) =>
	  (case event of
	       (_, [Gdk.EVENT event]) =>
	       serve (fn () =>
                 case event of
		     Gdk.EVENT_BUTTON_PRESS {x=x,y=y,...} =>
		     let
			 val (findX, depth) =
                             GtkNode.findByXY(canvas,!scale,
					      x,y)
			 val t = !tree
			 val n = TreeNode.findByX (t, depth, 0, findX)
			 val (x,y) = TreeNode.getCenter n
		     in
                         case ExplorerNode.curNodeStatus n of
                             Types.FAILED => ()
                           | _ => 
			     (currentNode := SOME n;
			      GtkNode.drawShadow (state, x, y, n);
                              MenuManager.updateMenus n)
		     end
                   | Gdk.EVENT_2BUTTON_PRESS {x=x,y=y,...} =>
		     let
			 val (findX, depth) =
                             GtkNode.findByXY(canvas,!scale,
					      x,y)
			 val t = !tree
			 val n = TreeNode.findByX (t, depth, 0, findX)
			 val (x,y) = TreeNode.getCenter n
		     in
                         case ExplorerNode.curNodeStatus n of
                             (Types.FAILED | Types.UNKNOWN) => ()
                           | _ =>
                             if ExplorerNode.isHidden n then () else
			     (currentNode := SOME n;
			      GtkNode.drawShadow (state, x, y, n);
                              List.app
                                  (fn (i,s) => 
                                      if s= !curInspAction then
                                          i (ExplorerNode.recomputeSpace n)
                                      else ()) (!inspect))
		     end
		   | _ => ())
	     | _ => ())
	| _ => ()

  val itr = Real.fromInt

  fun refreshStatusbar state =
      let
          val (choices, failed, solved) = Types.getSearchState state
      in
          Gtk.labelSetText(ExplorerGUI.noOfChoices,
                           Int.toString choices);
          Gtk.labelSetText(ExplorerGUI.noOfFailed,
                           Int.toString failed);
          Gtk.labelSetText(ExplorerGUI.noOfSolved,
                           Int.toString solved)
      end

  fun destroyMainWindow (resetCanvas,
                         serve,
                         state as ref (SOME {gtk={window,...},
                                             tree={rootSpace,tree,...},
                                             ...})
			 : explorer_state option ref) =
      (Gtk.widgetHide window;
       rootSpace := NONE;
       resetCanvas serve state;
       Types.resetSearchState state;
       Types.resetCancelSearch state;
       refreshStatusbar state;
       ExplorerNode.discardTree (!tree) )
    | destroyMainWindow _ = ()

  fun setBBox (ref (SOME ({gtk={canvas=canvas,...}, ...}: explorer_state)),
	       (minx, maxx, depth)) =
      let
	  val xMin   = Real.round((itr minx)* (TreeNode.defScale))
	  val xMax   = Real.round((itr maxx)* (TreeNode.defScale))
	  val xDim   = abs xMin + (abs xMax)
	  val yDim   = Real.round((itr((depth+1)*TreeNode.verSpaceI) *
				   TreeNode.defScale))
      in
	  Canvas.setScrollRegion(canvas, itr xMin, 0.0,
				      itr xMax, Real.fromInt yDim)
      end
    | setBBox _ = ()


  fun zoomToFit (state : Types.explorer_state option ref) =
      case !state of
          SOME {gtk={canvas,scale,...},
                tree={tree=ref tree,...},
                ...} =>
          let
              val shape = TreeNode.getShape tree
	      val (minx, maxx, depth) = TreeNode.getBBox shape
	      val xSize = Gtk.adjustmentGetFieldPageSize
                              ExplorerGUI.scrolledwindow_xa
	      val ySize = Gtk.adjustmentGetFieldPageSize
                              ExplorerGUI.scrolledwindow_ya
	      val xMin   = Real.round((itr minx)*(TreeNode.defScale))
	      val xMax   = Real.round((itr maxx)*(TreeNode.defScale))
	      val xDim   = itr (abs xMin + (abs xMax))
	      val yDim   = (itr((depth+1)*TreeNode.verSpaceI) *
			    TreeNode.defScale)
                           
              val xScale = ySize / yDim
              val yScale = xSize / xDim
                           
              val scaleTo = Real.min(xScale,yScale)
              val scaleTo = Real.max(0.1,scaleTo)
              val scaleTo = Real.min(3.0,scaleTo)
          in
	      Canvas.setPixelsPerUnit(canvas, scaleTo);
              Gtk.rangeSetValue(ExplorerGUI.scale,scaleTo);
	      scale := scaleTo / Defaults.floatScaleBase
          end
        | _ => ()


  fun refresh (cmw, serve, state) =
      case !state of
          (SOME (rstate as {gtk={canvas,window,scale,...},
                            tree={tree=ref tree,
			          currentNode=ref cn,
                                  ...},
                            ...}
		 : explorer_state)) =>
          let
	      val shape = TreeNode.layoutNode tree
	      val (minx, maxx, depth) = TreeNode.getBBox shape
          in
              Gtk.widgetShowAll window;
              refreshStatusbar state;
              setBBox (state, (minx, maxx, depth));
              Gtk.layoutFreeze canvas;
	      VisualNode.adjust (rstate, tree, 0, 0, TreeNode.verSpaceI, 0);
	      (case cn of NONE => ()
		        | SOME cn =>
		          let
			      val (x,y) = TreeNode.getCenter cn
		          in
			      GtkNode.drawShadow (rstate, x, y, cn)
		          end);
              Gtk.layoutThaw canvas;
              Canvas.setPixelsPerUnit(canvas,
                                           (!scale)*Defaults.floatScaleBase);
              if Types.getZoomFollows state then
                  zoomToFit state
              else ()
          end
        | NONE =>(state := !(cmw serve);
		  refresh (cmw, serve, state))

  fun refreshAfterSearch (node, cmw) (serve, state) =
      (if getHideFailed state then
           VisualNode.hideFailed node
       else (); refresh (cmw, serve, state))

  fun exitHandler (resetCanvas, serve, state) _ =
      serve (fn () => destroyMainWindow (resetCanvas, serve, state))
  fun nodeHideHandler (cmw, serve, state) _ = 
      serve (fn () =>
		(VisualNode.toggleHide state;
                 Option.app MenuManager.updateMenus (Types.getCurrentNode state);
		 refresh (cmw, serve, state)))
  fun nodeUnhideHandler (cmw, serve, state) _ =
      serve (fn () =>
                case !state of
                    SOME {tree={tree=ref tree,
                                currentNode=ref cn,...},...} =>
		    (VisualNode.unhideAll (Option.getOpt(cn,tree));
                     Option.app MenuManager.updateMenus (Types.getCurrentNode state);
		     refresh (cmw, serve, state))
                  | _ => ())
  fun hideFailedHandler (cmw, serve, state) _ =
      serve (fn () =>
                case !state of
                    SOME {tree={tree=ref tree,
                                currentNode=ref cn,...},...} =>
		    (VisualNode.hideFailed (Option.getOpt(cn,tree));
                     Option.app MenuManager.updateMenus (Types.getCurrentNode state);
		     refresh (cmw, serve, state))
                  | _ => ())

  fun exploreOneHandler (cmw, setStatusMsg, serve, state) _ =
      serve (fn () =>
                case !state of
                    SOME {tree={currentNode=ref (SOME cn),...},...} =>
                    ExplorerSearch.search
                        (serve, state, refreshAfterSearch (cn, cmw),
                         setStatusMsg, 1, SOME cn)
                  | _ => ())

  fun exploreAllHandler (cmw, setStatusMsg, serve, state) _ =
      serve (fn () =>
                case !state of
                    SOME {tree={currentNode=ref (SOME cn),...},...} =>
                    ExplorerSearch.search
                        (serve, state, refreshAfterSearch (cn, cmw),
                         setStatusMsg, 0, SOME cn)
                  | _ => ())

  fun exploreNHandler (cmw, setStatusMsg, serve, state) _ =
      serve (fn () =>
                case !state of
                    SOME {tree={currentNode=ref (SOME cn),...},
                          breakAfter=ref breakAfter,
                          ...} =>
                    ExplorerSearch.search
                        (serve, state, refreshAfterSearch (cn, cmw),
                         setStatusMsg, breakAfter, SOME cn)
                  | _ => ())
                                                
  fun resetHandler (cmw, resetCanvas, serve, state) _ =
      serve (fn () =>
                case !state of
                    SOME {tree={rootSpace=ref (SOME rs),...},...} =>
                    (Types.resetSearchState state;
                     Types.resetCancelSearch state;
                     refreshStatusbar state;
                     ExplorerSearch.initSearch (serve, state,
                                                fn (x,y) => refresh (cmw,x,y),
                                                resetCanvas, rs))
                  | _ => ())

  fun selectInspectionAction (serve,
                              state : explorer_state option ref) event = 
      serve (fn () =>
                case !state of
                    SOME {curInspAction=curInspAction,...} =>
                    (case event of (obj, _) =>
                       if (Gtk.checkMenuItemGetFieldActive obj)=1 then
                           let
                               val label = Gtk.binGetChild obj
                           in
                               curInspAction := Gtk.labelGetText label
                           end
                       else
                           ())
                  | _ => ())

  fun viewOptionsHandler (mw, serve, state) _ =
      let
          val configure = OptionsWindow.newOptionsWindow (mw, serve, state)
      in
          Gtk.windowSetPosition(configure, Gtk.WIN_POS_MOUSE);
          Gtk.widgetShowAll configure
      end

  fun debugHandler (serve, state) _ =
      serve (fn () =>
                case !state of
                    SOME {debug=debug,...} =>
                    Types.setDebug state (not (!debug))
                  | NONE => ())


  fun zoomToFitHandler (serve, state : Types.explorer_state option ref) _ =
      serve (fn () => zoomToFit state)

  fun saveHandler (serve, state : Types.explorer_state option ref) _ =
      serve (fn () => SaveWindow.newSaveWindow(serve, state))
end
