(*
 * Author:
 *   Guido Tack <tack@ps.uni-sb.de>
 *
 * Copyright:
 *   Guido Tack, 2003
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Space     from "x-alice:/lib/gecode/Space"
import structure FS        from "x-alice:/lib/gecode/FS"
import structure Print     from "x-alice:/lib/system/Print"

	(**
	* Asserts v holds for all solutions, performs f if failed node met.
	*)
	
    fun testVerify s v f =
	let
	    fun dfe (s,d) =
		 case Space.status s of
		    Space.FAILED => (f (); Space.discard s)
		  | Space.SOLVED => (
		  assert (v s); 
		  Space.discard s)
		  | Space.BRANCH =>
		    let
			val c = Space.clone s
		    in
			Space.commit(s, 1);
			Space.commit(c, 2);
			(dfe (s,d+1));
			(dfe (c,d+1))
		    end
	in
	    dfe ((Space.clone s),0)
	end

	fun testVerifySimple s v = testVerify s v (fn () => assert false)	
	fun testVerifyComplex s v = testVerify s v (fn () => ())	
	
	fun unionTest () =
	let
		val space = Space.new()
		val root as #[a,b,c] = FS.setvarVec (space, 3)
		val top = FS.Value.make (space,#[(0,5)])
	in
		FS.subset (space, a, top);
		FS.subset (space, b, top);
		FS.subset (space, c, top);				
		FS.union (space, a, b, c);
(*        FS.setvarbranch(space, root, FS.FSB_NONE, FS.FSB_MIN); *)
		FS.randomBranch(space, root, 1);
		(root, space)
	end
	
	fun fakeVerify _ = true
	

	fun range2II (i1,i2) = 
	let
		val _= assert (i1 >= 0);
		val diff = i2 - i1
		val ones = IntInf.<< ((IntInf.fromInt 2),Word.fromInt diff ) - (IntInf.fromInt 1)
	in
		IntInf.<<(ones, Word.fromInt i1)
	end
	
	(*Eta forewa! :-) *)
	val vdom2II = Vector.foldl ( fn (r,a)=> IntInf.orb ((range2II r),a) ) (IntInf.fromInt 0)

	fun vTern v1 root space =
	let
		val root2 : (IntInf.int vector)= Vector.map 
				(  fn v => vdom2II ( FS.Reflect.lowerBound (space,v) )  )
				root
	in
		v1 root2
	end

fun vUnion1 (root2 as #[a,b,c]) = (IntInf.orb(b,c) = a)
	
	val vUnion = vTern vUnion1
	
	val (root, space)= unionTest ()
	val _ = testVerifySimple space (vUnion root)
	val _ = print "done.\n";
	val _ = OS.Process.exit OS.Process.success