(*
 * Authors:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt and Andreas Rossberg, 2001-2004
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Foreign              from "../../lib/system/Foreign"
import structure TextIO               from "../../lib/system/TextIO"
import structure OS                   from "../../lib/system/OS"
import structure Url                  from "../../lib/system/Url"

import structure Component            from "../../lib/system/Component"
import structure PPComponent          from "../../lib/system/PPComponent"
import structure PrettyPrint          from "../../lib/utility/PrettyPrint"

import structure Target               from "../infrastructure/Target"
import structure MkOptionParser       from "MkOptionParser"
import signature RECURSIVE_COMPILER   from "RECURSIVE_COMPILER-sig"
import signature INTERACTIVE_TOPLEVEL from "INTERACTIVE_TOPLEVEL-sig"

functor MkToplevel(RecursiveCompiler: RECURSIVE_COMPILER) :
    INTERACTIVE_TOPLEVEL =
struct
    structure OptionParser = MkOptionParser(RecursiveCompiler.Switches)

    fun usage fail = TextIO.output(if fail then
                                       TextIO.stdErr
                                   else TextIO.stdOut,
                                   "Usage: alice [options]\n" ^
				   OptionParser.helpText)

    val banner     = "Alice 0.9.3 (Stockhausen Operette 3 Remix 3)\n"
    val prompt     = "- "
    val contPrompt = "  "

    val useFiles: string list ref = ref nil

    fun use filename =
	let
	    val new = Hole.hole ()
	    val old = Ref.exchange (useFiles, new)
	in
	    Hole.fill (new, old @ [filename])
	end

    fun readInput() =
	case readInput' prompt of [] => NONE
				| ss => SOME(String.concat ss)

    and readInput' prompt =
	(TextIO.print prompt;
	 case TextIO.inputLine(TextIO.stdIn)
	  of NONE      => []
	   | SOME "\n" => "\n" :: readInput' contPrompt
	   | SOME line => if String.sub(line, String.size line - 2) = #";"
			  then [line]
			  else line :: readInput' contPrompt
	)

    fun baseUrl () =
	Url.setScheme (Url.fromString (OS.FileSys.getDir () ^ "/"),
		       SOME "file")

    fun eval compile (printSig, source, context) =
	Foreign.catch (fn _ => eval' compile (printSig, source, context),
		       fn e =>
			  (TextIO.output (TextIO.stdErr, Foreign.exnMessage e);
			   context))
    and eval' compile (printSig, source, context) =
	(case compile (context, source) of
	     (context, Target.COMPONENT {eval, component, ...}) =>
		 let
		     val str = eval (baseUrl ())
		 in
		     if not printSig then () else
		     case Component.inf (component ()) of
		          NONE => TextIO.print "[no result signature]\n"
		        | SOME inf =>
			      let
				  val doc = PPComponent.ppComp (str, inf)
			      in
				  PrettyPrint.output(TextIO.stdOut, doc, 79);
				  TextIO.print "\n"
			      end;
		     context
		 end
	   | (_, Target.FOREIGN _) =>
		 raise RecursiveCompiler.Crash
		     "MkToplevel.eval: cross-compilation not supported")
	handle RecursiveCompiler.Error => context
	     | RecursiveCompiler.Crash s =>
		   (TextIO.output (TextIO.stdErr,
				   "internal failure at " ^ s ^ "\n");
		    context)   (*--** is this cool or what? *)
	     | Component.Failure (_, Component.Eval exn) =>
		   (TextIO.output (TextIO.stdErr,
				   "uncaught exception " ^
				   General.exnName exn ^ "\n");
		    context)
	     | exn =>
		   (TextIO.output (TextIO.stdErr,
				   "internal exception " ^
				   General.exnName exn ^ "\n");
		    context)   (*--** is this cool or what? *)

    val evalString = eval RecursiveCompiler.compileString
    val evalFile   = eval RecursiveCompiler.compileFile

    fun loop context =
	case readInput() of
	    SOME source => loopUses (evalString (true, source, context))
	  | NONE => TextIO.print "\n"
    and loopUses context =
	let
	    val new = Hole.hole ()
	    val old = Ref.exchange (useFiles, new)
	in
	    case old of
		filename::rest =>
		    (Hole.fill (new, rest);
		     loopUses (evalFile (true, filename, context)))
	      | nil =>
		    (Hole.fill (new, nil);
		     loop context)
	end

    fun main'(("--help"|"-h"|"-?")::_) = (usage false; OS.Process.success)
      | main'("--version"::_) =
	(TextIO.output (TextIO.stdOut, "alice "^OptionParser.version ^ "\n\n");
         TextIO.output (TextIO.stdOut, OptionParser.copyright ^ "\n");
         OS.Process.success)
      | main'(_::_) = (usage true; OS.Process.failure)
      | main' nil =
	let
            val _ = TextIO.print banner;
	    open RecursiveCompiler.Switches
	    val context = evalString (false, "",
				      RecursiveCompiler.Context.empty)
	in
	    Language.implicitImport  := false;
	    loop context;
	    OS.Process.success
	end

    fun defaults () = (* override defaults from MkSwitches here *)
	RecursiveCompiler.Switches.Language.implicitImportFile :=
	    SOME "x-alice:/alice.import"

    fun main arguments =
	if RecursiveCompiler.isCrossCompiler then
	    (TextIO.output (TextIO.stdErr,
			    "alice: cross-compilation not supported by \
			    \interactive toplevel\n");
	     OS.Process.failure)
	else
	    let
		open RecursiveCompiler.Switches
	    in
		defaults ();
		Debug.dumpPhases := false;
		Language.allowUnclosedComponents := true;
		Language.reexportImport := true;
		Language.retainFullImport := true;
		Global.traceComponentAccess := true;
                main' (OptionParser.parse arguments)
	    end
	    handle exn =>
		(TextIO.output(TextIO.stdErr,
			       "alice: uncaught internal exception " ^
			       General.exnName exn ^ "\n");
		 OS.Process.failure)
end
