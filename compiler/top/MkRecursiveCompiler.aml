(*
 * Authors:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt and Andreas Rossberg, 1999-2003
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure IO                 from "../../lib/system/IO"
import structure BinIO              from "../../lib/system/BinIO"
import structure TextIO             from "../../lib/system/TextIO"
import structure OS                 from "../../lib/system/OS"
import structure Config             from "../../lib/system/Config"
import structure Url                from "../../lib/system/Url"
import structure Resolver           from "../../lib/system/Resolver"
import structure Reflect            from "../../lib/system/Reflect"
import signature COMPONENT_MANAGER  from "../../lib/system/COMPONENT_MANAGER-sig"
import structure Component          from "../../lib/system/Component"
import structure MkHashImpMap       from "../../lib/data/MkHashImpMap"
import structure Path               from "../../lib/rtt/Path"
import structure Inf                from "../../lib/rtt/Inf"

import structure Crash              from "../infrastructure/Crash"
import structure Source             from "../infrastructure/Source"
import structure Target             from "../infrastructure/Target"
import signature COMPILER           from "COMPILER-sig"
import signature RECURSIVE_COMPILER from "RECURSIVE_COMPILER-sig"

type sig_loader = Source.desc * Url.t -> Inf.sign
type mod_loader = Source.desc * Url.t -> Reflect.module

functor MkRecursiveCompiler(structure ComponentManager: COMPONENT_MANAGER
				where type component = Component.t
			    structure Compiler: COMPILER
			    val extension: string): RECURSIVE_COMPILER =
    struct
	structure Switches = Compiler.Switches
	val isCrossCompiler = Compiler.isCrossCompiler

	exception Error = Compiler.Error

	type context = Compiler.context
	val empty = Compiler.empty

	val extension = extension

	fun error message =
	    (TextIO.output (TextIO.stdErr, "### error: " ^ message ^ "\n");
	     raise Error)
	fun warn message =
	    TextIO.output (TextIO.stdErr, "### warning: " ^ message ^ "\n")

	fun trace message =
	    if !Switches.Global.traceComponentAccess then
		TextIO.print ("### " ^ message ^ "\n")
	    else ()

	fun resolveWrtCwd url =
	    let
		val base =
		    Url.setScheme (Url.fromString (OS.FileSys.getDir () ^ "/"),
				   SOME "file")
	    in
		Url.resolve base url
	    end

	val sourceResolver =
	    Resolver.resolver
	    {name = "source",
	     handlers = case OS.Process.getEnv "ALICE_SOURCE_PATH" of
			     SOME s => Resolver.Handler.parse s
			   | NONE => [Resolver.Handler.default],
	     memoize = false}

	fun readUrl url =
	    case Resolver.localize sourceResolver url of
		SOME (Resolver.FILE name) =>
		    let
			val name' = Url.toStringRaw url
			val f = TextIO.openIn name handle IO.Io {...} =>
				    error("could not open " ^ name')
			val s = TextIO.inputAll f handle IO.Io {...} =>
				    error("error reading " ^ name')
			val _ = TextIO.closeIn f handle IO.Io {...} =>
				    error("error reading " ^ name')
		    in
			SOME s
		    end
	      | SOME (Resolver.STRING s) => SOME s
	      | NONE => NONE

	local
	    val implicitImportRef = ref NONE	(* poor man's laziness *)
	in
	    fun implicitImport() =
		case !implicitImportRef
		  of SOME s => s
		   | NONE =>
		case !Switches.Language.implicitImportFile
		  of NONE => ""
		   | SOME url =>
		let
		    val s = String.map (fn #"\n" => #" " | c => c)
				       (valOf (readUrl (Url.fromString url)))
		in
		    implicitImportRef := SOME s;
		    s
		end handle (Url.NotLocal | Option) =>
			error ("could not locate implicit import file " ^ url)
	end

	fun isBaseSig desc =   (*--** only needed for .NET backend *)
	    case Source.url desc of
		SOME url =>
		    ((Url.toLocalFile url =
		      Url.toLocalFile
			  (resolveWrtCwd (Url.fromString (Config.homeDir () ^
							  "Base.asig"))))
		     handle Url.NotLocal => false)
	      | NONE => false

	fun processBasic process (desc, s) =
	    let
		val prefix = if not(!Switches.Language.implicitImport)
			     orelse isBaseSig desc
			     then ""
			     else implicitImport()
	    in
		process(desc, prefix ^ "\n" ^ s)
	    end

	fun processString process source =
	    processBasic process (Source.stringDesc, source)

	fun processFile process filename =
	    let
		val url = resolveWrtCwd (Url.fromString filename)
		val s = valOf (readUrl url)
		val s' = if not (String.isSuffix ".sml" filename orelse
				 String.isSuffix ".sig" filename) then s else
			 let
			     val filename' =
				 String.substring (filename, 0,
						   String.size filename - 3)
				 ^ "import"
			     val url' = resolveWrtCwd (Url.fromString filename')
			 in
			     case readUrl url' of
			         NONE => s
			       | SOME s' =>
				 (if String.sub (s', String.size s' - 1) = #"\n"
				  then s' else s' ^ "\n") ^ s
			 end
	    in
		processBasic process (Source.urlDesc url, s')
	    end handle (Url.NotLocal | Option) =>
		    error ("could not locate source file " ^ filename)

	local
	    fun compileSign' (desc, s) =
		let
		    val sigFilename = Url.toStringRaw (valOf (Source.url desc))
		    val _ = trace ("reading signature from " ^ sigFilename)
		    val s' = implicitImport() ^ "\n" ^ s
		    val (_, target) =
			Compiler.compile (Compiler.empty, desc,
					  Source.fromString s')
		    val _ = trace "done"
		    val inf' =
			case target of
			    Target.COMPONENT {component, ...} =>
				valOf (Component.inf (component ()))
			  | Target.FOREIGN {inf, ...} => inf
		    val inf = Inf.asSingKind
			      (#2 (Inf.asInfItem
				   (List.hd (Inf.items (Inf.asSig inf')))))
			      handle e as ( Inf.Interface | Inf.Kind | Inf.Item
					  | List.Empty | Option.Option) =>
				 error ("signature file " ^ sigFilename ^
					" does not contain a proper\
					\ signature declaration")
		in
		    inf
		end
	in
	    fun compileSign filename = processFile compileSign' filename
	end

	local
	    fun compile' outFilename (desc, s) =
		case Compiler.compile (empty, desc, Source.fromString s) of
		    (_, Target.COMPONENT {component, ...}) =>
			let
			    val component = component ()
			in
			    Component.save (outFilename, component);
			    valOf (Component.inf component)
			end
		  | (_, Target.FOREIGN {save, inf}) =>
			(save outFilename;
			 inf)

	    val fileStack: string list ref = ref nil
	in
	    fun compileFileToFile' (sourceFilename, targetFilename) =
		(trace ("compiling file " ^ sourceFilename);
		 fileStack := sourceFilename::(!fileStack);
		 processFile (compile' targetFilename) sourceFilename
		 before (trace ("wrote file " ^ targetFilename);
			 case fileStack of
			     ref (_::(rest as resumeFilename::_)) =>
				 (fileStack := rest;
				  trace ("resuming compilation of " ^
					 resumeFilename))
			   | ref [_] => fileStack := nil
			   | ref nil => ()))
	end

	(* Define signature acquisition via recursive compiler invocation *)

	fun existsFile filename = (*--** use OS.FileSys.access *)
	    (BinIO.closeIn (BinIO.openIn filename); true)
	    handle IO.Io {...} => false

	fun pathCeil filename =
	    let
		val fro = "." ^ extension
		val n = String.size filename
		val m = String.size fro
	    in
		if n > m andalso String.substring (filename, n - m, m) = fro
		then filename
		else filename ^ fro
	    end

	fun pathFloor filename =
	    let
		val fro = "." ^ extension
		val n = String.size filename
		val m = String.size fro
	    in
		if n > m andalso String.substring (filename, n - m, m) = fro
		then String.substring (filename, 0, n - m)
		else filename
	    end

	fun urlCeil url =
	    case List.rev (Url.getPath url) of
		last::rest => Url.setPath (url, List.rev (pathCeil last::rest))
	      | nil => url

	(* Try to find a compiled component or source file - search order:
	 *
	 * A              component known to composer, get signature
	 * ceil(A)        component known to composer, get signature
	 * A              pickled component, read signature from pickle
	 * ceil(A)        pickled component, read signature from pickle
	 * -- from here on only if Switches.Global.recursiveCompilation
	 * floor(A).asig  compile as signature for native component
	 * floor(A).aml   compile as new component, write to ceil(A)
	 * floor(A).sml   compile as new component, write to ceil(A)
	 * floor(A).sig   compile as new component, write to ceil(A)
	 *
	 * where ceil(A) = A, if A has the component extension, else A.ozf
	 * where floor(A) = A, if A has not component extension,
	 *                  else A without the component extension
	 *)

	structure UrlMap = MkHashImpMap(Url)

	val sigTable: Inf.sign UrlMap.t = UrlMap.map ()

	fun loadSig url = Component.inf (ComponentManager.link url)

	fun acquireSig (desc, url) =
	    let
		val url' =
		    case Source.url desc of
			SOME base => Url.resolve base url
		      | NONE => resolveWrtCwd url
	    in
		case UrlMap.lookup (sigTable, urlCeil url') of
		    SOME sign => sign
		  | NONE =>
		    let
			val inf =
			    (valOf (loadSig url')
			     before
			     trace ("loaded signature from " ^
				    Url.toStringRaw url'))
			    handle exn as (Component.Failure (_, _) |
					   Option.Option) =>
				acquireFromSigFile (url', exn)
			val sign = Inf.asSig inf
			    handle Inf.Interface =>
				error ("higher-order content found in " ^
				       Url.toStringRaw url)
		    in
			UrlMap.insert (sigTable, urlCeil url', sign);
			sign
		    end
	    end
	and acquireFromSigFile (url, exn) =
	    let
		val targetFilename = Url.toLocalFile url
		    handle Url.NotLocal =>
			error ("could not locate component " ^
			       Url.toStringRaw url)
		val sigFilename = pathFloor targetFilename ^ ".asig"
	    in
		if existsFile sigFilename then
		    compileSign sigFilename
		else if !Switches.Global.recursiveCompilation then
		    acquireFromSource targetFilename
		else
		    error ((case exn of
				Component.Failure (_, IO.Io {...}) =>
				    "could not locate component "
			      | Option.Option => "no signature found in "
			      | _ => "unknown error while accessing ") ^
			   targetFilename)
	    end
	and acquireFromSource targetFilename =
	    case acquireFromSource' (targetFilename, ".aml") of
		SOME inf => inf
	      | NONE =>
	    case acquireFromSource' (targetFilename, ".sml") of
		SOME inf => inf
	      | NONE =>
	    case acquireFromSource' (targetFilename, ".sig") of
		SOME inf => inf
	      | NONE =>
	    error ("could not locate source for " ^ targetFilename)
	and acquireFromSource' (targetFilename, to) =
	    let
		val sourceFilename = pathFloor targetFilename ^ to
	    in
		if existsFile sourceFilename then
		    SOME (compileFileToFile' (sourceFilename,
					      pathCeil targetFilename))
		else NONE
	    end

	fun acquireMod (desc, url) =
	    let
		val url' =
		    case Source.url desc of
			SOME base => Url.resolve base url
		      | NONE => resolveWrtCwd url
	    in
		if Compiler.isCrossCompiler then
		    raise IO.Io {name = Url.toStringRaw url',
				 function = "load",
				 cause = Component.NotFound}
		else
		    (*--** support evaluation during recursive compilation; *)
		    ComponentManager.eval (url', ComponentManager.link url')
	    end

	local
	    fun compile' context (desc, s) =
		Compiler.compile (context, desc, Source.fromString s)
	in
	    val compileFileToFile = ignore o compileFileToFile'

	    fun compileFile context sourceFilename =
		processFile (compile' context) sourceFilename

	    fun compileString context sourceText =
		processString (compile' context) sourceText
	end
    end
