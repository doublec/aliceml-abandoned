(*
 * Authors:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt and Andreas Rossberg, 1999-2005
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure IO                 from "../../lib/system/IO"
import structure BinIO              from "../../lib/system/BinIO"
import structure TextIO             from "../../lib/system/TextIO"
import structure OS                 from "../../lib/system/OS"
import structure Config             from "../../lib/system/Config"
import structure Url                from "../../lib/system/Url"
import structure Resolver           from "../../lib/system/Resolver"
import structure Reflect            from "../../lib/system/Reflect"
import signature COMPONENT_MANAGER  from "../../lib/system/COMPONENT_MANAGER-sig"
import structure Component          from "../../lib/system/Component"
import structure Store              from "../../lib/system/Store"
import structure MkHashImpMap       from "../../lib/data/MkHashImpMap"
import structure Inf                from "../../lib/rtt/Inf"

import structure Crash              from "../infrastructure/Crash"
import structure Source             from "../infrastructure/Source"
import structure Target             from "../infrastructure/Target"
import structure Dependency         from "Dependency"
import signature COMPILER           from "COMPILER-sig"
import signature RECURSIVE_COMPILER from "RECURSIVE_COMPILER-sig"

(*DEBUG*)
import structure PrettyPrint from "../../lib/utility/PrettyPrint"
import structure PPInf from "../../lib/rtt/PPInf"

structure InfLoader = struct type t = Source.desc * Url.t -> Inf.sign end
structure ModLoader = struct type t = Source.desc * Url.t -> Reflect.module end
structure ImportLoader = struct type t = Source.desc * Url.t -> (Url.t * Inf.sign) vector end

functor MkRecursiveCompiler(structure ComponentManager: COMPONENT_MANAGER
			    structure Compiler: COMPILER
			    val extension: string): RECURSIVE_COMPILER =
    struct
	structure Switches = Compiler.Switches
	structure Context = Compiler.Context
	val isCrossCompiler = Compiler.isCrossCompiler

	datatype target = datatype Target.t

	exception Error = Compiler.Error
	exception Crash = Crash.Crash

	val extension = extension

	val errOut = Switches.Global.errOut
	fun error message =
	    (TextIO.output (errOut, "### error: " ^ message ^ "\n");
	     raise Error)
	fun warn message =
	    TextIO.output (errOut, "### warning: " ^ message ^ "\n")

	fun trace message =
	    if !Switches.Global.traceComponentAccess
	    then TextIO.output (Switches.Global.logOut, "### " ^ message ^ "\n")
	    else ()

	fun resolveWrtCwd url =
	    let
		val base =
		    Url.setScheme (Url.fromString (OS.FileSys.getDir () ^ "/"),
				   SOME "file")
	    in
		Url.resolve base url
	    end

	val sourceResolver =
	    Resolver.resolver
	    {name = "source",
	     handlers = case OS.Process.getEnv "ALICE_SOURCE_PATH" of
			     SOME s => Resolver.Handler.parse s
			   | NONE => [Resolver.Handler.default],
	     memoize = false}

	fun readUrl url =
	    case Resolver.localize sourceResolver url of
		SOME (Resolver.FILE name) =>
		    let
			val name' = Url.toStringRaw url
			val f = TextIO.openIn name handle IO.Io _ =>
				    error("could not open " ^ name')
			val s = TextIO.inputAll f handle IO.Io _ =>
				    error("error reading " ^ name')
			val _ = TextIO.closeIn f handle IO.Io _ =>
				    error("error reading " ^ name')
		    in
			SOME s
		    end
	      | SOME (Resolver.STRING s) => SOME s
	      | NONE => NONE

	fun loadDependencyFiles () =
	    List.foldl (fn (filename, dep) =>
			Dependency.load (dep, filename)
			handle IO.Io _ =>
			    error("error reading dependency file " ^ filename)
			  | Dependency.Format =>
			    error("syntax error in dependency file " ^ filename)
		       )
		       Dependency.empty
		       (!Switches.Language.dependencyFiles)

	local
	    val implicitImportRef = ref NONE	(* poor man's laziness *)
	in
	    fun implicitImport() =
		case !Switches.Language.implicitImportFile
		  of NONE => "\n"
		   | SOME "--" => "" (* hack for bootstrapping! *)
		   | SOME url =>
		case !implicitImportRef
		  of SOME s => s
		   | NONE =>
		let
		    val s = String.map (fn #"\n" => #" " | c => c)
				       (valOf (readUrl (Url.fromString url)))
			    ^ "\n"
		in
		    implicitImportRef := SOME s;
		    s
		end handle (Url.NotLocal | Option.Option) =>
			error ("could not locate implicit import file " ^ url)
	end

	fun isBaseSig desc =   (*--** only needed for .NET backend *)
	    case Source.sourceUrl desc of
		SOME url =>
		    ((Url.toLocalFile url =
		      Url.toLocalFile
			  (resolveWrtCwd (Url.fromString (Config.homeDir () ^
							  "Base.asig"))))
		     handle Url.NotLocal => false)
	      | NONE => false

	fun processBasic process (desc, s) =
	    let
		val prefix = if isBaseSig desc then "\n" else implicitImport()
	    in
		process(desc, prefix ^ s)
	    end

	fun processString process source =
	    processBasic process (Source.stringDesc, source)

	fun processFile process (filename, targetFilenameOpt) =
	    let
		val url = resolveWrtCwd (Url.fromString filename)
		val targetUrlOpt =
		    Option.map (resolveWrtCwd o Url.fromString) targetFilenameOpt
		val s = valOf (readUrl url)
		val s' = if not (String.isSuffix ".sml" filename orelse
				 String.isSuffix ".sig" filename) then s else
			 let
			     val filename' =
				 String.substring (filename, 0,
						   String.size filename - 3)
				 ^ "import"
			     val url' = resolveWrtCwd (Url.fromString filename')
			 in
			     case readUrl url' of
			         NONE => s
			       | SOME s' =>
				 String.map (fn #"\n" => #" " | c => c) s'
				 ^ "\n" ^ s
			 end
		val d = loadDependencyFiles ()
		val s'' = List.foldr (fn (f, s) =>
				      "import \"" ^ f ^ "\" " ^ s)
				     s' (Dependency.lookup
					 (d, OS.Path.base filename))
		val desc = Source.urlDesc {source = url, target = targetUrlOpt}
	    in
		processBasic process (desc, s'')
	    end handle (Url.NotLocal | Option.Option) =>
		    error ("could not locate source file " ^ filename)

	local
	    fun compileSign' (desc, s) =
		let
		    val sigFilename =
			Url.toStringRaw (valOf (Source.sourceUrl desc))
		    val _ = trace ("reading signature from " ^ sigFilename)
		    val switch =
			Ref.exchange (Switches.Warn.unusedImport, false)
		    val (_, target) =
			Compiler.compile (desc, Context.empty,
					  Source.fromString s)
		    val _ = Switches.Warn.unusedImport := switch
		    val _ = trace ("finished reading signature from " ^ sigFilename)
		    val {export, imports} =
			case target of
			    Target.COMPONENT {component, ...} =>
			    let
				val component = component ()
			    in
				{export = valOf (Component.inf component),
				 imports = Vector.map (Pair.mapSnd valOf)
					   (Component.imports component)}
			    end
			  | Target.FOREIGN {inf, ...} =>
				{export = inf, imports = #[]} (*--** *)
		    val export' =
			Inf.asSingKind
			(#2 (Inf.asInfItem
			     (List.hd (Inf.items (Inf.asSig export)))))
			handle e as ( Inf.Interface | Inf.Kind | Inf.Item
				    | List.Empty | Option.Option) =>
			   error ("signature file " ^ sigFilename ^
				  " does not contain a proper\
				  \ signature declaration")
		in
		    {export = export', imports = imports}
		end
	in
	    fun compileSign filename = processFile compileSign' (filename, NONE)
	end

	local
	    fun compile' outFilename (desc, s) =
		case Compiler.compile (desc, Context.empty,
				       Source.fromString s) of
		    (_, Target.COMPONENT {component, ...}) =>
			let
			    val component = component ()
			    val component =
				if !Switches.Global.minimizeComponent
				then Store.minimize component
				else component
			in
			    Component.save (outFilename, component);
			    {export = valOf (Component.inf component),
			     imports = Vector.map (Pair.mapSnd valOf)
				       (Component.imports component)}
			end
		  | (_, Target.FOREIGN {save, inf}) =>
			(save outFilename;
			 {export = inf, imports = #[]}) (*--** *)

	    val fileStack: string list ref = ref nil
	in
	    fun compileFileToFile' (sourceFilename, targetFilename) =
		(trace ("compiling file " ^ sourceFilename);
		 fileStack := sourceFilename::(!fileStack);
		 processFile (compile' targetFilename)
			     (sourceFilename, SOME targetFilename)
		 before (trace ("wrote file " ^ targetFilename);
			 case !fileStack of
			     _::(rest as resumeFilename::_) =>
				 (fileStack := rest;
				  trace ("resuming compilation of " ^
					 resumeFilename))
			   | [_] => fileStack := nil
			   | nil => ()))
	end

	(* Define signature acquisition via recursive compiler invocation *)

	fun existsFile filename = (*--** use OS.FileSys.access *)
	    (BinIO.closeIn (BinIO.openIn filename); true)
	    handle IO.Io {...} => false

	fun pathCeil filename =
	    let
		val fro = "." ^ extension
		val n = String.size filename
		val m = String.size fro
	    in
		if n > m andalso String.substring (filename, n - m, m) = fro
		then filename
		else filename ^ fro
	    end

	fun pathFloor filename =
	    let
		val fro = "." ^ extension
		val n = String.size filename
		val m = String.size fro
	    in
		if n > m andalso String.substring (filename, n - m, m) = fro
		then String.substring (filename, 0, n - m)
		else filename
	    end

	fun urlCeil url =
	    case List.rev (Url.getPath url) of
		last::rest => Url.setPath (url, List.rev (pathCeil last::rest))
	      | nil => url

	(* Try to find a compiled component or source file - search order:
	 *
	 * A              component known to composer, get signature
	 * ceil(A)        component known to composer, get signature
	 * A              pickled component, read signature from pickle
	 * ceil(A)        pickled component, read signature from pickle
	 * -- from here on only if Switches.Global.recursiveCompilation
	 * floor(A).asig  compile as signature for native component
	 * floor(A).aml   compile as new component, write to ceil(A)
	 * floor(A).sml   compile as new component, write to ceil(A)
	 * floor(A).sig   compile as new component, write to ceil(A)
	 *
	 * where ceil(A) = A, if A has the component extension, else A.ozf
	 * where floor(A) = A, if A has not component extension,
	 *                  else A without the component extension
	 *)

	structure UrlMap = MkHashImpMap(Url)
	type import_entry = {export: Inf.t, imports: (Url.t * Inf.t) vector}

	val importTable: import_entry UrlMap.t = UrlMap.map ()

	fun loadInfs url =
	    let
		val component = ComponentManager.load url
		val dummyInf = Inf.sign (Inf.emptySig ())
	    in
		{export = valOf (Component.inf component),
		 imports = Vector.map (fn (url, infOpt) =>
				       (url, Option.getOpt (infOpt, dummyInf)))
				      (Component.imports component)}
	    end

	fun acquireInfs (desc, url) =
	    let
		val url' =
		    case Source.anyUrl desc of
			SOME base => Url.resolve base url
		      | NONE => resolveWrtCwd url
	    in
		case UrlMap.lookup (importTable, urlCeil url') of
		    SOME infs => infs
		  | NONE =>
		    let
			val infs =
			    (loadInfs url'
			     before
			     trace ("loaded signature from " ^
				    Url.toStringRaw url'))
			    handle ( Component.Failure (_, exn as IO.Io _)
				   | exn as Option.Option ) =>
				acquireFromSigFile (url', exn)
		    in
			UrlMap.insert (importTable, urlCeil url', infs);
			infs
		    end
	    end
	and acquireFromSigFile (url, exn) =
	    let
		val targetFilename = Url.toLocalFile url
		    handle Url.NotLocal =>
			error ("could not locate component " ^
			       Url.toStringRaw url)
		val sigFilename = pathFloor targetFilename ^ ".asig"
	    in
		if existsFile sigFilename then
		    compileSign sigFilename
		else if !Switches.Global.recursiveCompilation then
		    acquireFromSource targetFilename
		else
		    error ((case exn of
				IO.Io _ => "could not locate component "
			      | Option.Option => "no signature found in "
			      | _ => "unknown error while accessing ") ^
			   targetFilename)
	    end
	and acquireFromSource targetFilename =
	    case acquireFromSource' (targetFilename, ".aml") of
		SOME infs => infs
	      | NONE =>
	    case acquireFromSource' (targetFilename, ".sml") of
		SOME infs => infs
	      | NONE =>
	    case acquireFromSource' (targetFilename, ".sig") of
		SOME infs => infs
	      | NONE =>
	    error ("could not locate source for " ^ targetFilename)
	and acquireFromSource' (targetFilename, to) =
	    let
		val sourceFilename = pathFloor targetFilename ^ to
	    in
		if existsFile sourceFilename then
		    SOME (compileFileToFile' (sourceFilename,
					      pathCeil targetFilename))
		else NONE
	    end

	fun acquireSig (desc, url) =
(*
	    Inf.asSig (#export (acquireInfs (desc, url)))
*)
let val j = #export (acquireInfs (desc, url))
in Inf.asSig j
	    handle Inf.Interface =>
(*DEBUG*)
(PrettyPrint.output(errOut, PPInf.ppInf j,79);
TextIO.print"\n";
		error ("higher-order content found in " ^ Url.toStringRaw url)
) end
	fun acquireImports (desc, url) =
	    Vector.map (Pair.mapSnd Inf.asSig)
		       (#imports (acquireInfs (desc, url)))
	    handle Inf.Interface =>
		error ("higher-order import found in " ^ Url.toStringRaw url)

	fun acquireMod (desc, url) =
	    let
		val url' =
		    case Source.anyUrl desc of
			SOME base => Url.resolve base url
		      | NONE => resolveWrtCwd url
	    in
		if Compiler.isCrossCompiler then
		    raise IO.Io {name = Url.toStringRaw url',
				 function = "load",
				 cause = Component.NotFound}
		else
		    (*--** support evaluation during recursive compilation; *)
		    #1 (Reflect.reflectPackage (ComponentManager.link url'))
	    end

	local
	    fun compile' context (desc, s) =
		Compiler.compile (desc, context, Source.fromString s)
	in
	    val compileFileToFile = ignore o compileFileToFile'

	    fun compileFile (context, sourceFilename) =
		processFile (compile' context) (sourceFilename, NONE)

	    fun compileString (context, sourceText) =
		processString (compile' context) sourceText
	end
    end
