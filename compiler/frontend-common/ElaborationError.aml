(*
 * Author:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001-2004
i *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Fixity            from "../../lib/rtt/Fixity"
import structure Name              from "../../lib/rtt/Name"
import structure Label             from "../../lib/rtt/Label"
import structure Stamp             from "../common/Stamp"
import structure Type              from "../../lib/rtt/Type"
import structure Inf               from "../../lib/rtt/Inf"
import structure AbstractGrammar   from "AbstractGrammar"

import structure PrettyPrint       from "../../lib/utility/PrettyPrint"
import structure PPMisc            from "../infrastructure/PPMisc"
import structure PPPath            from "../../lib/rtt/PPPath"
import structure PPType            from "../../lib/rtt/PPType"
import structure PPInf             from "../../lib/rtt/PPInf"

import structure Error             from "../infrastructure/Error"
import signature ELABORATION_ERROR from "ELABORATION_ERROR-sig"


structure ElaborationError :> ELABORATION_ERROR =
struct

  (* Pretty printer *)

    open PrettyPrint
    open PPMisc

    infixr ^^ ^/^

  (* Types *)

    type lab       = Label.t
    type typ       = Type.t
    type var       = Type.var
    type kind      = Type.kind
    type inf	   = Inf.t
    type fix       = Fixity.t
    type valid     = AbstractGrammar.valid
    type modlongid = AbstractGrammar.modlongid

    type typ_mismatch = typ * typ * typ * typ
    type inf_mismatch = Inf.mismatch

    datatype error =
	(* Expressions *)
	  NewExpTyp		of typ
	| NewExpResTyp		of typ
	| VecExpMismatch	of typ_mismatch
	| TagExpLab		of lab
	| TagExpArgMismatch	of typ_mismatch
	| TagExpRowMismatch	of typ_mismatch
	| ConExpConMismatch	of typ_mismatch
	| ConExpArgMismatch	of typ_mismatch
	| UpdExpMismatch	of typ_mismatch
	| SelExpMismatch	of typ_mismatch
	| AppExpFunMismatch	of typ_mismatch
	| AppExpArgMismatch	of typ_mismatch
	| AndExpMismatch	of typ_mismatch
	| OrExpMismatch		of typ_mismatch
	| IfExpCondMismatch	of typ_mismatch
	| IfExpBranchMismatch	of typ_mismatch
	| RaiseExpMismatch	of typ_mismatch
	| HandleExpMismatch	of typ_mismatch
	| AnnExpMismatch	of typ_mismatch
	| MatPatMismatch	of typ_mismatch
	| MatExpMismatch	of typ_mismatch
	| OverExpEmpty
	| OverExpArity
	| OverExpNonPrimTyp	of typ
	| OverExpOverlap	of typ * typ
	| OverExpKind		of typ
	| OverExpMismatch	of typ_mismatch
	| OverallExpMismatch	of typ_mismatch
	(* Patterns *)
	| TagPatLab		of lab
	| TagPatArgMismatch	of typ_mismatch
	| TagPatRowMismatch	of typ_mismatch
	| ConPatConMismatch	of typ_mismatch
	| ConPatArgMismatch	of typ_mismatch
	| VecPatMismatch	of typ_mismatch
	| AsPatMismatch		of typ_mismatch
	| AltPatMismatch	of typ_mismatch
	| GuardPatMismatch	of typ_mismatch
	| AnnPatMismatch	of typ_mismatch
	(* Types *)
	| JokTyp
	| JokTypRow
	| StarTypKind		of kind
	| AppTypFunKind		of kind
	| AppTypArgKind		of kind * kind
	| RefTypKind		of kind
	| PervasiveTypUnknown	of string
	(* Declarations *)
	| ValDecMismatch	of typ_mismatch
	| ValDecUnclosed	of typ
	| ValDecLift		of valid * var
	(* Long ids *)
	| ModlongidInf		of modlongid * inf
	(* Modules *)
	| StrModUnclosed	of lab * typ
	| SelModInf		of inf
	| AppModFunMismatch	of inf
	| AppModArgMismatch	of inf_mismatch
	| AnnModMismatch	of inf_mismatch
	| UnpackModMismatch	of typ_mismatch
	(* Interfaces *)
	| GroundInfKind		of Inf.kind
	| AppInfFunMismatch	of inf
	| AppInfArgMismatch	of inf_mismatch
	| InterInfMismatch	of inf_mismatch
	| LetInfGenerative	of inf
	| SingInfNonSing	of inf
	| PervasiveInfUnknown	of string
	(* Imports *)
	| ImpMismatch		of inf_mismatch
	(* Components *)
	| CompUnclosed		of lab * typ

    datatype warning =
	(* Imports *)
	  ValImpUnused		of lab
	| TypImpUnused		of lab
	| ModImpUnused		of lab
	| InfImpUnused		of lab
	(* Imports *)
	| NotGeneralized	of valid * typ


  (* Pretty printing *)

    fun ppQuoted s	= "`" ^ s ^ "'"

    fun ppLab'(AbstractGrammar.Lab(_,l)) = Label.toString l

    fun ppId'(AbstractGrammar.Id(_,_,n)) = Name.toString n
    fun ppId x = ppQuoted(ppId' x)

    fun ppLongid'(AbstractGrammar.ShortId(_,x))  = ppId' x
      | ppLongid'(AbstractGrammar.LongId(_,y,l)) = ppLongid' y ^ "." ^ ppLab' l
    fun ppLongid y = ppQuoted(ppLongid' y)

    fun ppLab l = Label.toString l

    val ppPath = PPPath.ppPath
    val ppTyp  = PPType.ppTyp
    val ppInf  = PPInf.ppInf

    open Fixity

    fun ppFix NONFIX		= text "nonfix"
      | ppFix(PREFIX n)		= text "prefix" ^/^ text(Int.toString n)
      | ppFix(POSTFIX n)	= text "postfix"^/^ text(Int.toString n)
      | ppFix(INFIX(n,LEFT))	= text "infix"  ^/^ text(Int.toString n)
      | ppFix(INFIX(n,RIGHT))	= text "infixr" ^/^ text(Int.toString n)
      | ppFix(INFIX(n,NEITHER))	= text "infixn" ^/^ text(Int.toString n)


    fun ppTypMismatch2(d1, d2, (t1,t2,t3,t4)) =
	vbox(
	    d1 ^^ indent(PPType.ppTyp t1) ^/^
	    d2 ^^ indent(PPType.ppTyp t2)
	)

    fun ppTypMismatch4(d1, d2, (t1,t2,t3,t4)) =
	let
	    val td1 = PPType.ppTyp t1
	    val td2 = PPType.ppTyp t2
	    val td3 = PPType.ppTyp t3
	    val td4 = PPType.ppTyp t4
	in
	    if td3 = td1 andalso td4 = td2 then
		vbox(
		    d1 ^^ indent td1 ^/^
		    d2 ^^ indent td2
		)
	    else
		vbox(
		    d1 ^^ indent td1 ^/^
		    d2 ^^ indent td2 ^/^
		    textpar["because","type"] ^^ indent td3 ^/^
		    textpar["does","not","unify","with"] ^^ indent td4
		)
	end

    fun ppInfMismatch(d, im) =
        vbox(
	    d ^^
	    ppInfMismatch' im
	)

    and ppInfMismatch'(Inf.MissingFix l) =
	    break ^^
	    textpar["fixity","of",ppQuoted(ppLab l),"is","unspecified"]
      | ppInfMismatch'(Inf.MissingVal l) =
	    indent(textpar["val",ppLab l]) ^/^
	    textpar["is","missing"]
      | ppInfMismatch'(Inf.MissingTyp l) =
	    indent(textpar["type",ppLab l]) ^/^
	    textpar["is","missing"]
      | ppInfMismatch'(Inf.MissingMod l) =
	    indent(textpar["structure",ppLab l]) ^/^
	    textpar["is","missing"]
      | ppInfMismatch'(Inf.MissingInf l) =
	    indent(textpar["signature",ppLab l]) ^/^
	    textpar["is","missing"]
      | ppInfMismatch'(Inf.MismatchFix(l,q1,q2)) =
	    indent(par[ppFix q1,text(ppLab l)]) ^/^
	    textpar["does","not","match"] ^^
	    indent(par[ppFix q2,text(ppLab l)])
      | ppInfMismatch'(Inf.MismatchVal(l,t1,t2,m)) =
	    indent(par[text"val",text(ppLab l),text":",ppTyp t1]) ^/^
	    textpar["does","not","match"] ^^
	    indent(par[text"val",text(ppLab l),text":",ppTyp t2]) ^/^
	    textpar["because"] ^^
	    ppTypeMismatch m
      | ppInfMismatch'(Inf.MismatchTyp(l,k1,k2,m)) =
	if not(Type.isSingKind k2) then
	    indent(textpar["type",ppLab l]) ^/^
	    textpar["has","incompatible","arity"]
	else
	    indent(if Type.isSingKind k1
		   then par[text"type",text(ppLab l),text"=",
			    ppTyp(Type.asSingKind k1)]
		   else textpar["type",ppLab l]) ^/^
	    textpar["does","not","match","specification"] ^^
	    indent(par[text"type",text(ppLab l),text"=",
		       ppTyp(Type.asSingKind k2)])
      | ppInfMismatch'(Inf.MismatchMod(l,im)) =
	    indent(textpar["structure",ppLab l]) ^/^
	    textpar["does","not","match,","because"] ^^
	    ppInfMismatch' im
      | ppInfMismatch'(Inf.MismatchInf(l,km)) =
	    indent(textpar["signature",ppLab l]) ^/^
	    textpar["does","not","match,","because"] ^^
	    ppKindMismatch km
      | ppInfMismatch'(Inf.MismatchDom im) =
	    break ^^
	    textpar["argument","signature","is","too","permissive,",
		"because"] ^^
	    ppInfMismatch' im
      | ppInfMismatch'(Inf.MismatchRan im) =
	    break ^^
	    textpar["result","signature","is","too","restrictive,","because"] ^^
	    ppInfMismatch' im
      | ppInfMismatch'(Inf.MismatchParam im) =
	    break ^^
	    textpar["parameter","signature","is","too","permissive,",
		"because"] ^^
	    ppInfMismatch' im
      | ppInfMismatch'(Inf.MismatchBody im) =
	    break ^^
	    textpar["body","signature","is","incompatible,","because"] ^^
	    ppInfMismatch' im
      | ppInfMismatch'(Inf.MismatchFun im) =
	    ppInfMismatch' im
      | ppInfMismatch'(Inf.MismatchArg im) =
	    break ^^
	    textpar["signature","argument","does","not","match,","because"] ^^
	    ppInfMismatch' im
      | ppInfMismatch'(Inf.Incompatible(j1,j2)) =
	    break ^^
	    textpar["signature"] ^^
	    indent(ppInf j1) ^/^
	    textpar["is","incompatible","to"] ^^
	    indent(ppInf j2)
      | ppInfMismatch'(Inf.IncompatibleMod(p1,p2)) =
	    break ^^
	    textpar["module"] ^^
	    indent(ppPath p1) ^/^
	    textpar["is","not","equal","to"] ^^
	    indent(ppPath p2)

    and ppKindMismatch(Inf.MismatchKindDom im) =
	    break ^^
	    textpar["argument","signature","is","too","permissive,",
		"because"] ^^
	    ppInfMismatch' im
      | ppKindMismatch(Inf.MismatchKindRan km) =
	    ppKindMismatch km
      | ppKindMismatch(Inf.IncompatibleKind(k1,k2)) =
	    break ^^
	    textpar["arity","is","incompatible"]
      | ppKindMismatch(Inf.IncompatibleInf im) =
	    break ^^
	    textpar["signature","is","incompatible,","because"] ^^
	    ppInfMismatch' im

    and ppTypeMismatch(t1,t2) =
	    indent(ppTyp t1) ^/^
	    textpar["is","incompatible","with"] ^^
	    indent(ppTyp t2)


    fun ppUnclosed(d, (l,t)) =
	vbox(
	    d ^^
	    indent(
		fbox(nest(
		    text(Label.toString l) ^/^
		    text ":" ^/^
		    below(PPType.ppTyp t)
		))
	    ) ^/^
	    textpar["contains","free","type","variable",
		    "or","unresolved","record","type"]
	)


    fun ppError(NewExpTyp t) =
	vbox(
	    textpar["new","constructor","is","not","of","function","type:"] ^^
	    indent(PPType.ppTyp t)
	)
      | ppError(NewExpResTyp t) =
	vbox(
	    textpar["type","is","not","extensible:"] ^^
	    indent(PPType.ppTyp t)
	)
      | ppError(VecExpMismatch ue) =
	ppTypMismatch2(
	  textpar["inconsistent","types","in","vector","expression:"],
	  textpar["does","not","agree","with","previous","element","type"], ue)
      | ppError(TagExpLab l) =
	  textpar["label",ppLab l,"is","not","contained","in","type"]
      | ppError(TagExpRowMismatch ue) =
	ppTypMismatch4(
	  textpar["constructor","type","and","tag","inconsistent:"],
	  textpar["does","not","match","argument","type"], ue)
      | ppError(TagExpArgMismatch ue | ConExpArgMismatch ue) =
	ppTypMismatch4(
	  textpar["constructor","argument","type","mismatch:"],
	  textpar["does","not","match","argument","type"], ue)
      | ppError(ConExpConMismatch ue) =
	ppTypMismatch2(
	  textpar["applied","value","is","not","a","constructor","function:"],
	  textpar["does","not","match","function","type"], ue)
      | ppError(UpdExpMismatch ue) =
	ppTypMismatch4(
	  textpar["mismatch","on","record","update:"],
	  textpar["does","not","match","type"], ue)
      | ppError(SelExpMismatch ue) =
	ppTypMismatch2(
	  textpar["selection","type","mismatch:"],
	  textpar["does","not","match","record","type"], ue)
      | ppError(AppExpFunMismatch ue) =
	ppTypMismatch2(
	  textpar["applied","value","is","not","a","function:"],
	  textpar["does","not","match","function","type"], ue)
      | ppError(AppExpArgMismatch ue) =
	ppTypMismatch4(
	  textpar["argument","type","mismatch:"],
	  textpar["does","not","match","argument","type"], ue)
      | ppError(AndExpMismatch ue) =
	ppTypMismatch2(
	  textpar["operand","of","`andalso'","is","not","a","boolean:"],
	  textpar["does","not","match","type"], ue)
      | ppError(OrExpMismatch ue) =
	ppTypMismatch2(
	  textpar["operand","of","`orelse'","is","not","a","boolean:"],
	  textpar["does","not","match","type"], ue)
      | ppError(IfExpCondMismatch ue) =
	ppTypMismatch2(
	  textpar["operand","of","`if'","is","not","a","boolean:"],
	  textpar["does","not","match","type"], ue)
      | ppError(IfExpBranchMismatch ue) =
	ppTypMismatch4(
	  textpar["inconsistent","types","in","branches","of","`if':"],
	  textpar["does","not","agree","with","type"], ue)
      | ppError(RaiseExpMismatch ue) =
	ppTypMismatch2(
	  textpar["operand","of","`raise'","is","not","an","exception:"],
	  textpar["does","not","match","type"], ue)
      | ppError(HandleExpMismatch ue) =
	ppTypMismatch4(
	  textpar["inconsistent","types","in","branches","of","`handle':"],
	  textpar["does","not","agree","with","type"], ue)
      | ppError(AnnExpMismatch ue) =
	ppTypMismatch4(
	  textpar["expression","does","not","match","annotation:"],
	  textpar["does","not","match","type"], ue)
      | ppError(MatPatMismatch ue) =
	ppTypMismatch4(
	  textpar["inconsistent","types","in","`case'","patterns:"],
	  textpar["does","not","agree","with","previous","type"], ue)
      | ppError(MatExpMismatch ue) =
	ppTypMismatch4(
	  textpar["inconsistent","types","in","branches","of","`case':"],
	  textpar["does","not","agree","with","previous","type"], ue)
      | ppError(OverExpEmpty) =
	  textpar["empty","overloading"]
      | ppError(OverExpArity) =
	  textpar["number","of","overloaded","types","does","not",
		  "match","number","of","cases"]
      | ppError(OverExpNonPrimTyp t) =
	vbox(
	    textpar["non-abstract","overloaded","type:"] ^^
	    indent(PPType.ppTyp t)
	)
      | ppError(OverExpOverlap(t1,t2)) =
	vbox(
	    textpar["overlapping","overload,","because", "type"] ^^
	    indent(PPType.ppTyp t1) ^/^
	    textpar["is","the","same","as","type"] ^^
	    indent(PPType.ppTyp t2)
	)
      | ppError(OverExpKind t) =
	vbox(
	    textpar["inconsistent","kinds","in","overloading:"] ^^
	    indent(PPType.ppTyp t) ^/^
	    textpar["does","not","agree","with","previous","type"]
	)
      | ppError(OverExpMismatch ue) =
	ppTypMismatch4(
	  textpar["type","mismatch","in","overloading:"],
	  textpar["does","not","match","instance","type"], ue)
      | ppError(OverallExpMismatch ue) =
	ppTypMismatch4(
	  textpar["type","mismatch","in","intensional","overloading:"],
	  textpar["does","not","match","implementation","type"], ue)
      (* Patterns *)
      | ppError(TagPatRowMismatch ue) =
	ppTypMismatch4(
	  textpar["constructor","type","and","tag","inconsistent:"],
	  textpar["does","not","match","argument","type"], ue)
      | ppError(TagPatLab l) =
	  textpar["label",ppLab l,"is","not","contained","in","type"]
      | ppError(TagPatArgMismatch ue | ConPatArgMismatch ue) =
	ppTypMismatch4(
	  textpar["ill-typed","constructor","argument:"],
	  textpar["does","not","match","argument","type"], ue)
      | ppError(ConPatConMismatch ue) =
	ppTypMismatch2(
	  textpar["applied","identifier","is","not","a","constructor",
		  "function:"],
	  textpar["does","not","match","function","type"], ue)
      | ppError(VecPatMismatch ue) =
	ppTypMismatch2(
	  textpar["inconsistent","types","in","vector","pattern:"],
	  textpar["does","not","agree","with","previous","element","type"], ue)
      | ppError(AsPatMismatch ue) =
	ppTypMismatch4(
	  textpar["inconsistent","types","in","`as'","pattern:"],
	  textpar["does","not","agree","with","type"], ue)
      | ppError(AltPatMismatch ue) =
	ppTypMismatch4(
	  textpar["inconsistent","types","in","pattern","alternatives:"],
	  textpar["does","not","agree","with","previous","type"], ue)
      | ppError(GuardPatMismatch ue) =
	ppTypMismatch2(
	  textpar["pattern","guard","is","not","a","boolean:"],
	  textpar["does","not","match","type"], ue)
      | ppError(AnnPatMismatch ue) =
	ppTypMismatch4(
	  textpar["pattern","does","not","match","annotation:"],
	  textpar["does","not","match","type"], ue)
      (* Types *)
      | ppError(JokTyp) =
	  textpar["misplaced","type","wildcard"]
      | ppError(JokTypRow) =
	  textpar["misplaced","type","row","wildcard"]
      | ppError(StarTypKind k) =
	  textpar["missing","arguments","in","type","expression"]
      | ppError(AppTypFunKind k) =
	  textpar["type","expression","is","not","a","type","function"]
      | ppError(AppTypArgKind(k1,k2)) =
	  textpar["missing","arguments","in","type","expression"]
      | ppError(RefTypKind k) =
	  textpar["missing","arguments","in","type","expression"]
      | ppError(PervasiveTypUnknown s) =
	  textpar["unknown","pervasive","type","\""^s^"\""]
      (* Declarations *)
      | ppError(ValDecMismatch ue) =
	ppTypMismatch4(
	  textpar["expression","does","not","match","pattern","type:"],
	  textpar["does","not","match","type"], ue)
      | ppError(ValDecUnclosed t) =
	vbox(
	    textpar["unresolved","type","in","declaration:"] ^^
	    indent(PPType.ppTyp t)
	)
      | ppError(ValDecLift(x,l)) =
	  textpar["could not generalize","type","of",ppId x,
	      "due","to","value","restriction",
	      "although","it","contains","explicit","type","variables"]
      (* Modules *)
      | ppError(ModlongidInf(y,j)) =
	vbox(
	    textpar["module",ppLongid y,"is","not","a","structure,",
		    "it","has","signature"] ^^
	    indent(PPInf.ppInf j)
	)
      | ppError(StrModUnclosed lt) =
	ppUnclosed(
	  textpar["structure","is","not","closed:"], lt)
      | ppError(SelModInf j) =
	  textpar["module","expression","is","not","a","structure"]
      | ppError(AppModFunMismatch j) =
	  textpar["applied","module","is","not","a","functor"]
      | ppError(AppModArgMismatch im) =
	ppInfMismatch(
	  textpar["module","expression","does","not","match",
	      "functor","parameter","signature:"], im)
      | ppError(AnnModMismatch im) =
	ppInfMismatch(
	  textpar["module","expression","does","not","match","signature:"], im)
      | ppError(UnpackModMismatch ue) =
	ppTypMismatch2(
	  textpar["operand","of","`unpack'","is","not","a","package:"],
	  textpar["does","not","match","type"], ue)
      (* Interfaces *)
      | ppError(GroundInfKind k) =
	  textpar["missing","arguments","in","signature","expression"]
      | ppError(AppInfFunMismatch j) =
	  textpar["applied","signature","is","not","parameterised"]
      | ppError(AppInfArgMismatch im) =
	ppInfMismatch(
	  textpar["module","expression","does","not","match",
		  "signature","parameter:"], im)
      | ppError(InterInfMismatch im) =
	ppInfMismatch(
	  textpar["inconsistency","at","signature","specialization:"], im)
      | ppError(LetInfGenerative j) =
	vbox(
	    textpar["signature","contains","names","introduced","in","let:"] ^^
	    indent(PPInf.ppSig(Inf.asSig j))
	)
      | ppError(SingInfNonSing j) =
	  textpar["module","expression","is","not","a","valid","singleton"]
      | ppError(PervasiveInfUnknown s) =
	  textpar["unknown","pervasive","signature","\""^s^"\""]
      (* Imports *)
      | ppError(ImpMismatch im) =
	ppInfMismatch(
	  textpar["component","does","not","match","import,","because"], im)
      (* Components *)
      | ppError(CompUnclosed lt) =
	ppUnclosed(
	  textpar["component","is","not","closed:"], lt)

    fun ppWarning(ValImpUnused l) =
	  textpar["imported","value",ppLab l,"is","not","used",
		  "and","has","been","dropped"]
      | ppWarning(TypImpUnused l) =
	  textpar["imported","type",ppLab l,"is","not","used",
		  "and","has","been","dropped"]
      | ppWarning(ModImpUnused l) =
	  textpar["imported","structure",ppLab l,"is","not","used",
		  "and","has","been","dropped"]
      | ppWarning(InfImpUnused l) =
	  textpar["imported","signature",ppLab l,"is","not","used",
		  "and","has","been","dropped"]
      | ppWarning(NotGeneralized(x,t)) =
	vbox(
	    textpar["type","of",ppId x,"cannot","be","generalized","due","to",
		"value","restriction:"] ^^
	    indent(PPType.ppTyp t)
	)

  (* Export *)

    fun error(region, e)  = Error.error(region, ppError e)
    fun warn(region, w)   = Error.warn(region, ppWarning w)

    (*UNFINISHED*)
    fun unfinished(region, funname, casename) =
	Error.warn(region, text("Elab." ^ funname ^ ": " ^ casename ^
				" not checked yet"))
end
