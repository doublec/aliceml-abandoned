(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2000-2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure BinIO        from "../../lib/system/BinIO"
import structure MkHashImpMap from "../../lib/data/MkHashImpMap"
import structure Crash        from "../infrastructure/Crash"
import structure StringMap    from "../infrastructure/StringMap"
import signature PRIM_PICKLE  from "PRIM_PICKLE-sig"

structure PrimPickle :> PRIM_PICKLE =
    struct
	open LargeInt

	structure AtomMap = MkHashImpMap(Atom)

	type id = int

	type outstream =
	     {stream: BinIO.outstream,
	      id: id ref,
	      stringMap: id StringMap.t,
	      atomMap: id AtomMap.t,
	      expect: int ref}

	fun inc ({id = r as ref id, ...}: outstream) = (r := id + 1; id)

	type label = int
	type size = Int.int

	val tPOSINT    = Word8.fromInt 0
	val tNEGINT    = Word8.fromInt 1
	val tCHUNK     = Word8.fromInt 2
	val tUNIQUE    = Word8.fromInt 3
	val tBLOCK     = Word8.fromInt 4
	val tTUPLE     = Word8.fromInt 5
	val tCLOSURE   = Word8.fromInt 6
	val tREF       = Word8.fromInt 7
	val tTRANSFORM = Word8.fromInt 8

	fun outputByte ({stream, ...}: outstream, w) =
	    BinIO.output1 (stream, w)

	fun outputUInt (q, i) =
	    if i >= 0x80 then
		(outputByte (q, Word8.fromLargeInt (i mod 0x80 + 0x80));
		 outputUInt (q, i div 0x80))
	    else if i >= 0 then outputByte (q, Word8.fromLargeInt i)
	    else raise Crash.Crash "PrimPickle.outputUInt"

	fun openOut name: outstream =
	    {stream = BinIO.openOut name,
	     id = ref 0,
	     stringMap = StringMap.map (),
	     atomMap = AtomMap.map (),
	     expect = ref 1}

	fun done ({expect = r as ref n, ...}: outstream) = r := n - 1
	fun more ({expect = r as ref n, ...}: outstream, m) =
	    r := n - 1 + fromInt m

	fun outputInt (q, i) =
	    if i >= 0 then (done q; outputByte (q, tPOSINT); outputUInt (q, i))
	    else (done q; outputByte (q, tNEGINT); outputUInt (q, ~(i + 1)))

	fun outputChunk (q, bytes) =
	    (done q; outputByte (q, tCHUNK);
	     outputUInt (q, fromInt (Vector.length bytes));
	     Vector.app (fn b => outputByte (q, b)) bytes; inc q)

	fun outputUnique q =
	    (more (q, 1); outputByte (q, tUNIQUE); inc q)

	fun outputBlock (q, label, size) =
	    (more (q, size); outputByte (q, tBLOCK);
	     outputUInt (q, label); outputUInt (q, fromInt size); inc q)

	fun outputTuple (q, size) =
	    (more (q, size); outputByte (q, tTUPLE);
	     outputUInt (q, fromInt size); inc q)

	fun outputClosure (q, size) =
	    (more (q, size); outputByte (q, tCLOSURE);
	     outputUInt (q, fromInt size); inc q)

	fun outputReference (q, id) =
	    (done q; outputByte (q, tREF); outputUInt (q, id))

	fun outputString (q as {stringMap, ...}: outstream, s) =
	    case StringMap.lookup (stringMap, s) of
		SOME id => (outputReference (q, id); id)
	      | NONE =>
		    let
			val id = inc q
		    in
			StringMap.insertDisjoint (stringMap, s, id);
			done q; outputByte (q, tCHUNK);
			outputUInt (q, fromInt (String.size s));
			CharVector.app
			(fn c => outputByte (q, Word8.fromInt (Char.ord c))) s;
			id
		    end

	fun outputAtom (q as {atomMap, ...}: outstream, s) =
	    case AtomMap.lookup (atomMap, s) of
		SOME id => (outputReference (q, id); id)
	      | NONE =>
		    let
			val id = outputUnique q
		    in
			AtomMap.insertDisjoint (atomMap, s, id);
			outputString (q, Atom.toString s);
			id
		    end

	fun outputTransform (q, name) =
	    let
		val id = inc q
	    in
		more (q, 2); outputByte (q, tTRANSFORM);
		outputString (q, name); id
	    end

	fun closeOut ({stream, expect = ref n, ...}: outstream) =
	    (BinIO.closeOut stream;
	     if n = 0 then ()
	     else
		 let
		     exception PickleSize
		 in
		     TextIO.output
			 (TextIO.stdErr,
			  "pickle size off by " ^ toString n ^ "\n");
		     raise PickleSize
		 end)
    end
