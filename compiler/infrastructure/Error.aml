(*
 * Author:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001-2005
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(* Error handling. *)

import structure Url         from "../../lib/system/Url"
import structure TextIO      from "../../lib/system/TextIO"
import structure OS          from "../../lib/system/OS"
import signature ERROR       from "ERROR-sig"
import structure Source      from "Source"
import structure PrettyPrint from "../../lib/utility/PrettyPrint"

structure Error :> ERROR =
struct
    open PrettyPrint
    infixr ^^ ^/^

    (* Import *)

    type region = Source.region

    (* Export *)

    exception Error of region * doc

    val outstream = ref TextIO.stdErr
    fun setOutstream os = outstream := os

    val currentUrl : Url.t option ref = ref NONE
    fun setCurrentUrl uo = currentUrl := uo

    fun resolveWrtCwd url =
	let
	    val base = Url.setScheme(Url.fromString(OS.FileSys.getDir() ^ "/"),
				     SOME "file")
	in
	    Url.resolve base url
	end

    fun urlToString url =
	case (Url.getScheme url, Url.getAuthority url) of
	    ((NONE | SOME "file"), NONE) =>
	    OS.Path.mkRelative{path = Url.toString(Url.setScheme(url, NONE)),
			       relativeTo = OS.FileSys.getDir()}
	  | _ =>
	    Url.toString url

    fun print(reg, doc) =
	output(!outstream,
	       fbox(
		   (case !currentUrl of NONE   => empty
			| SOME f => text(urlToString f) ^^ text ":") ^^
		   text(Source.regionToString reg) ^^ text ":" ^^ break
		) ^^ doc ^^ break, 78)

    fun error(reg, message)   = ( print(reg,message) ; raise Error(reg,message) )
    fun warn(b, reg, message) = if not b then () else
				print(reg, fbox(text "warning:" ^^ break) ^^
					   message)

    (*UNFINISHED: provisory*)
    fun error'(reg, s)   = error(reg, text s)
    fun warn'(b, reg, s) = warn(b, reg, text s)
    fun unfinished(region, phasename, casename) =
	error(region, text(phasename ^ ": "^ casename ^ " not implemented yet"))
end
